/*
HeadHunter API

По-русски | [Switch to English](https://api.hh.ru/openapi/en/redoc)  В OpenAPI ведется пока что только небольшая часть документации [Основная документация](https://github.com/hhru/api).  Для поиска по документации можно использовать Ctrl+F.  # Общая информация  * Всё API работает по протоколу HTTPS. * Авторизация осуществляется по протоколу OAuth2. * Все данные доступны только в формате JSON. * Базовый URL — `https://api.hh.ru/` * Возможны запросы к данным [любого сайта группы компаний HeadHunter](#section/Obshaya-informaciya/Vybor-sajta) * <a name=\"date-format\"></a> Даты форматируются в соответствии с [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601): `YYYY-MM-DDThh:mm:ss±hhmm`.   <a name=\"request-requirements\"></a> ## Требования к запросам  В запросе необходимо передавать заголовок `User-Agent`, но если ваша реализация http клиента не позволяет, можно отправить `HH-User-Agent`. Если не отправлен ни один заголовок, то ответом будет `400 Bad Request`. Указание в заголовке названия приложения и контактной почты разработчика позволит нам оперативно с вами связаться в случае необходимости. Заголовки `User-Agent` и `HH-User-Agent` взаимозаменяемы, в случае, если вы отправите оба заголовка, обработан будет только `HH-User-Agent`.  ``` User-Agent: MyApp/1.0 (my-app-feedback@example.com) ```  Подробнее про [ошибки в заголовке User-Agent](https://github.com/hhru/api/blob/master/docs/errors.md#user-agent).   <a name=\"request-body\"></a> ## Формат тела запроса при отправке JSON  Данные, передающиеся в теле запроса, должны удовлетворять требованиям:  * Валидный JSON (допускается передача как минифицированного варианта, так и pretty print варианта с дополнительными пробелами и сбросами строк). * Рекомендуется использование кодировки UTF-8 без дополнительного экранирования (`{\"name\": \"Иванов Иван\"}`). * Также возможно использовать ascii кодировку с экранированием (`{\"name\": \"\\u0418\\u0432\\u0430\\u043d\\u043e\\u0432 \\u0418\\u0432\\u0430\\u043d\"}`). * К типам данных в определённым полях накладываются дополнительные условия, описанные в каждом конкретном методе. В JSON типами данных являются `string`, `number`, `boolean`, `null`, `object`, `array`.  ### Ответ Ответ свыше определенной длины будет сжиматься методом gzip.  ### Ошибки и коды ответов  API широко использует информирование при помощи кодов ответов. Приложение должно корректно их обрабатывать.  В случае неполадок и сбоев, возможны ответы с кодом `503` и `500`.  При каждой ошибке, помимо кода ответа, в теле ответа может быть выдана дополнительная информация, позволяющая разработчику понять причину соответствующего ответа.  [Более подробно про возможные ошибки](https://github.com/hhru/api/blob/master/docs/errors.md).   ## Недокументированные поля и параметры запросов  В ответах и параметрах API можно найти ключи, не описанные в документации. Обычно это означает, что они оставлены для совместимости со старыми версиями. Их использование не рекомендуется. Если ваше приложение использует такие ключи, перейдите на использование актуальных ключей, описанных в документации.   ## Пагинация  К любому запросу, подразумевающему выдачу списка объектов, можно в параметрах указать `page=N&per_page=M`. Нумерация идёт с нуля, по умолчанию выдаётся первая (нулевая) страница с 20 объектами на странице. Во всех ответах, где доступна пагинация, единообразный корневой объект:  ```json {   \"found\": 1,   \"per_page\": 1,   \"pages\": 1,   \"page\": 0,   \"items\": [{}] } ``` ## Выбор сайта  API HeadHunter позволяет получать данные со всех сайтов группы компании HeadHunter.  В частности:  * hh.ru * rabota.by * hh1.az * hh.uz * hh.kz * headhunter.ge * headhunter.kg  Запросы к данным на всех сайтах следует направлять на `https://api.hh.ru/`.  При необходимости учесть специфику сайта, можно добавить в запрос параметр `?host=`. По умолчанию используется `hh.ru`.  Например, для получения [локализаций](https://api.hh.ru/openapi/redoc#tag/Obshie-spravochniki/operation/get-locales), доступных на hh.kz необходимо сделать GET запрос на `https://api.hh.ru/locales?host=hh.kz`.  ## CORS (Cross-Origin Resource Sharing)  API поддерживает технологию CORS для запроса данных из браузера с произвольного домена. Этот метод более предпочтителен, чем использование JSONP. Он не ограничен методом GET. Для отладки CORS доступен [специальный метод](https://github.com/hhru/api/blob/master/docs/cors.md). Для использования JSONP передайте параметр `?callback=callback_name`.  * [CORS specification on w3.org](http://www.w3.org/TR/cors/) * [HTML5Rocks CORS Tutorial](http://www.html5rocks.com/en/tutorials/cors/) * [CORS on dev.opera.com](http://dev.opera.com/articles/view/dom-access-control-using-cross-origin-resource-sharing/) * [CORS on caniuse.com](http://caniuse.com/#feat=cors) * [CORS on en.wikipedia.org](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing)   ## Внешние ссылки на статьи и стандарты  * [HTTP/1.1](http://tools.ietf.org/html/rfc2616) * [JSON](http://json.org/) * [URI Template](http://tools.ietf.org/html/rfc6570) * [OAuth 2.0](http://tools.ietf.org/html/rfc6749) * [REST](http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) * [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601)  # Авторизация  API поддерживает следующие уровни авторизации:   - [авторизация приложения](#tag/Avtorizaciya-prilozheniya)   - [авторизация пользователя](#section/Avtorizaciya/Avtorizaciya-polzovatelya)  * [Авторизация пользователя](#section/Avtorizaciya/Avtorizaciya-polzovatelya)   * [Правила формирования специального redirect_uri](#section/Avtorizaciya/Pravila-formirovaniya-specialnogo-redirect_uri)   * [Процесс авторизации](#section/Avtorizaciya/Process-avtorizacii)   * [Успешное получение временного `authorization_code`](#get-authorization_code)   * [Получение access и refresh токенов](#section/Avtorizaciya/Poluchenie-access-i-refresh-tokenov) * [Обновление пары access и refresh токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) * [Инвалидация токена](#tag/Avtorizaciya-rabotodatelya/operation/invalidate-token) * [Запрос авторизации под другим пользователем](#section/Avtorizaciya/Zapros-avtorizacii-pod-drugim-polzovatelem) * [Авторизация под разными рабочими аккаунтами](#section/Avtorizaciya/Avtorizaciya-pod-raznymi-rabochimi-akkauntami) * [Авторизация приложения](#tag/Avtorizaciya-prilozheniya)       ## Авторизация пользователя Для выполнения запросов от имени пользователя необходимо пользоваться токеном пользователя.  В начале приложению необходимо направить пользователя (открыть страницу) по адресу:  ``` https://hh.ru/oauth/authorize? response_type=code& client_id={client_id}& state={state}& redirect_uri={redirect_uri} ```  Обязательные параметры:  * `response_type=code` — указание на способ получения авторизации, используя `authorization code` * `client_id` — идентификатор, полученный при создании приложения   Необязательные параметры:  * `state` — в случае указания, будет включен в ответный редирект. Это позволяет исключить возможность взлома путём подделки межсайтовых запросов. Подробнее об этом: [RFC 6749. Section 10.12](http://tools.ietf.org/html/rfc6749#section-10.12) * `redirect_uri` — uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра.  ## Правила формирования специального redirect_uri  К примеру, если в настройках сохранен `http://example.com/oauth`, то разрешено указывать:  * `http://www.example.com/oauth` — поддомен; * `http://www.example.com/oauth/sub/path` — уточнение пути; * `http://example.com/oauth?lang=RU` — дополнительный параметр; * `http://www.example.com/oauth/sub/path?lang=RU` — всё вместе.  Запрещено:  * `https://example.com/oauth` — различные протоколы; * `http://wwwexample.com/oauth` — различные домены; * `http://wwwexample.com/` — другой путь; * `http://example.com/oauths` — другой путь; * `http://example.com:80/oauths` — указание изначально отсутствующего порта;  ## Процесс авторизации  Если пользователь не авторизован на сайте, ему будет показана форма авторизации на сайте. После прохождения авторизации на сайте, пользователю будет выведена форма с запросом разрешения доступа вашего приложения к его персональным данным.  Если пользователь не разрешает доступ приложению, пользователь будет перенаправлен на указанный `redirect_uri` с `?error=access_denied` и `state={state}`, если таковой был указан при первом запросе.  <a name=\"get-authorization_code\"></a> ### Успешное получение временного `authorization_code`  В случае разрешения прав, в редиректе будет указан временный `authorization_code`:  ```http HTTP/1.1 302 FOUND Location: {redirect_uri}?code={authorization_code} ```  Если пользователь авторизован на сайте и доступ данному приложению однажды ранее выдан, ответом будет сразу вышеописанный редирект с `authorization_code` (без показа формы логина и выдачи прав).  ## Получение access и refresh токенов  После получения `authorization_code` приложению необходимо сделать сервер-сервер запрос `POST https://api.hh.ru/token` для обмена полученного `authorization_code` на `access_token` (старый запрос `POST https://hh.ru/oauth/token` считается устаревшим).  В теле запроса необходимо передать [дополнительные параметры](#required_parameters).  Тело запроса необходимо передавать в стандартном `application/x-www-form-urlencoded` с указанием соответствующего заголовка `Content-Type`.  `authorization_code` имеет довольно короткий срок жизни, при его истечении необходимо запросить новый.  ## Обновление пары access и refresh токенов `access_token` также имеет срок жизни (ключ `expires_in`, в секундах), при его истечении приложение должно сделать запрос с `refresh_token` для получения нового.  Запрос необходимо делать в `application/x-www-form-urlencoded`.  ``` POST https://api.hh.ru/token ```  (старый запрос `POST https://hh.ru/oauth/token` считается устаревшим)  В теле запроса необходимо передать [дополнительные параметры](#required_parameters)  `refresh_token` можно использовать только один раз и только по истечению срока действия `access_token`.  После получения новой пары access и refresh токенов, их необходимо использовать в дальнейших запросах в api и запросах на продление токена.  ## Запрос авторизации под другим пользователем  Возможен следующий сценарий:  1. Приложение перенаправляет пользователя на сайт с запросом авторизации. 2. Пользователь на сайте уже авторизован и данному приложение доступ уже был разрешен. 3. Пользователю будет предложена возможность продолжить работу под текущим аккаунтом, либо зайти под другим аккаунтом.  Если есть необходимость, чтобы на шаге 3 сразу происходило перенаправление (redirect) с временным токеном, необходимо добавить к запросу `/oauth/authorize...` параметр `skip_choose_account=true`. В этом случае автоматически выдаётся доступ пользователю авторизованному на сайте.  Если есть необходимость всегда показывать форму авторизации, приложение может добавить к запросу `/oauth/authorize...` параметр `force_login=true`. В этом случае, пользователю будет показана форма авторизации с логином и паролем даже в случае, если пользователь уже авторизован.  Это может быть полезно приложениям, которые предоставляют сервис только для соискателей. Если пришел пользователь-работодатель, приложение может предложить пользователю повторно разрешить доступ на сайте, уже указав другую учетную запись.  Также, после авторизации приложение может показать пользователю сообщение:  ``` Вы вошли как %Имя_Фамилия%. Это не вы? ``` и предоставить ссылку с `force_login=true` для возможности захода под другим логином.  ## Авторизация под разными рабочими аккаунтами  Для получения списка рабочих аккаунтов менеджера и для работы под разными рабочими аккаунтами менеджера необходимо прочитать документацию по [рабочим аккаунтам менеджера](#tag/Menedzhery-rabotodatelya/operation/get-manager-accounts)  В случае компрометации токена необходимо [инвалидировать](#tag/Avtorizaciya-rabotodatelya/operation/invalidate-token) скомпрометированный токен и запросить токен заново!  <!-- ReDoc-Inject: <security-definitions> --> 

API version: 1.0.0
Contact: api@hh.ru
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package hh

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAddApplicantCommentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicantId string
	hHUserAgent *string
	text *string
	accessType *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddApplicantCommentRequest) HHUserAgent(hHUserAgent string) ApiAddApplicantCommentRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Текст комментария
func (r ApiAddApplicantCommentRequest) Text(text string) ApiAddApplicantCommentRequest {
	r.text = &text
	return r
}

// Тип доступа. Доступные значения перечислены [в справочнике](#tag/Obshie-spravochniki/operation/get-dictionaries) в поле &#x60;applicant_comment_access_type&#x60;
func (r ApiAddApplicantCommentRequest) AccessType(accessType string) ApiAddApplicantCommentRequest {
	r.accessType = &accessType
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddApplicantCommentRequest) Locale(locale string) ApiAddApplicantCommentRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddApplicantCommentRequest) Host(host string) ApiAddApplicantCommentRequest {
	r.host = &host
	return r
}

func (r ApiAddApplicantCommentRequest) Execute() (*ApplicantCommentsApplicantCommentItem, *http.Response, error) {
	return r.ApiService.AddApplicantCommentExecute(r)
}

/*
AddApplicantComment Добавление комментария

Метод требует наличия [платного доступа для работодателя](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicantId Идентификатор соискателя, который можно узнать из поля `owner` [в резюме](https://github.com/hhru/api/blob/master/docs/employer_resumes.md#owner-field)
 @return ApiAddApplicantCommentRequest
*/
func (a *DefaultApiService) AddApplicantComment(ctx context.Context, applicantId string) ApiAddApplicantCommentRequest {
	return ApiAddApplicantCommentRequest{
		ApiService: a,
		ctx: ctx,
		applicantId: applicantId,
	}
}

// Execute executes the request
//  @return ApplicantCommentsApplicantCommentItem
func (a *DefaultApiService) AddApplicantCommentExecute(r ApiAddApplicantCommentRequest) (*ApplicantCommentsApplicantCommentItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicantCommentsApplicantCommentItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddApplicantComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applicant_comments/{applicant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicant_id"+"}", url.PathEscape(parameterValueToString(r.applicantId, "applicantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.accessType == nil {
		return localVarReturnValue, nil, reportError("accessType is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "access_type", r.accessType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddEmployerManagerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	employerManagersAddEmployerManager *EmployerManagersAddEmployerManager
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddEmployerManagerRequest) HHUserAgent(hHUserAgent string) ApiAddEmployerManagerRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiAddEmployerManagerRequest) EmployerManagersAddEmployerManager(employerManagersAddEmployerManager EmployerManagersAddEmployerManager) ApiAddEmployerManagerRequest {
	r.employerManagersAddEmployerManager = &employerManagersAddEmployerManager
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddEmployerManagerRequest) Locale(locale string) ApiAddEmployerManagerRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddEmployerManagerRequest) Host(host string) ApiAddEmployerManagerRequest {
	r.host = &host
	return r
}

func (r ApiAddEmployerManagerRequest) Execute() (*EmployerManagersEmployerManagerId, *http.Response, error) {
	return r.ApiService.AddEmployerManagerExecute(r)
}

/*
AddEmployerManager Добавление менеджера

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя. Чтобы получить его, используйте метод [Информация о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiAddEmployerManagerRequest
*/
func (a *DefaultApiService) AddEmployerManager(ctx context.Context, employerId string) ApiAddEmployerManagerRequest {
	return ApiAddEmployerManagerRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerManagersEmployerManagerId
func (a *DefaultApiService) AddEmployerManagerExecute(r ApiAddEmployerManagerRequest) (*EmployerManagersEmployerManagerId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersEmployerManagerId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddEmployerManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.employerManagersAddEmployerManager == nil {
		return localVarReturnValue, nil, reportError("employerManagersAddEmployerManager is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.employerManagersAddEmployerManager
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerManagerBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsEmployerManagerBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddEmployerToBlacklistedRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddEmployerToBlacklistedRequest) HHUserAgent(hHUserAgent string) ApiAddEmployerToBlacklistedRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddEmployerToBlacklistedRequest) Locale(locale string) ApiAddEmployerToBlacklistedRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddEmployerToBlacklistedRequest) Host(host string) ApiAddEmployerToBlacklistedRequest {
	r.host = &host
	return r
}

func (r ApiAddEmployerToBlacklistedRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddEmployerToBlacklistedExecute(r)
}

/*
AddEmployerToBlacklisted Добавление работодателя в список скрытых

Добавляет указанного работодателя в [список скрытых работодателей](#tag/Skrytye-vakansii/operation/get-blacklisted-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiAddEmployerToBlacklistedRequest
*/
func (a *DefaultApiService) AddEmployerToBlacklisted(ctx context.Context, employerId string) ApiAddEmployerToBlacklistedRequest {
	return ApiAddEmployerToBlacklistedRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddEmployerToBlacklistedExecute(r ApiAddEmployerToBlacklistedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddEmployerToBlacklisted")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/blacklisted/{employer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerBlacklistedErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsEmployerBlacklistedNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddResumeVisibilityListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	listType string
	hHUserAgent *string
	resumesPostResumeVisibilityListBody *ResumesPostResumeVisibilityListBody
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddResumeVisibilityListRequest) HHUserAgent(hHUserAgent string) ApiAddResumeVisibilityListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiAddResumeVisibilityListRequest) ResumesPostResumeVisibilityListBody(resumesPostResumeVisibilityListBody ResumesPostResumeVisibilityListBody) ApiAddResumeVisibilityListRequest {
	r.resumesPostResumeVisibilityListBody = &resumesPostResumeVisibilityListBody
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddResumeVisibilityListRequest) Locale(locale string) ApiAddResumeVisibilityListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddResumeVisibilityListRequest) Host(host string) ApiAddResumeVisibilityListRequest {
	r.host = &host
	return r
}

func (r ApiAddResumeVisibilityListRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddResumeVisibilityListExecute(r)
}

/*
AddResumeVisibilityList Добавление работодателей в список видимости

Добавляет указанных работодателей в список видимости указанного типа.

За один запрос можно добавить не больше 100 компаний.

Добавление в список идемпотентно, то есть добавление работодателей, уже присутствующих в списке, игнорируется и не приводит к дублированию записей.

Можно добавить в список заблокированного работодателя


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @param listType Тип списка. Допустимые значения — `whitelist` или `blacklist`
 @return ApiAddResumeVisibilityListRequest
*/
func (a *DefaultApiService) AddResumeVisibilityList(ctx context.Context, resumeId string, listType string) ApiAddResumeVisibilityListRequest {
	return ApiAddResumeVisibilityListRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
		listType: listType,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddResumeVisibilityListExecute(r ApiAddResumeVisibilityListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddResumeVisibilityList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/{list_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list_type"+"}", url.PathEscape(parameterValueToString(r.listType, "listType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.resumesPostResumeVisibilityListBody == nil {
		return nil, reportError("resumesPostResumeVisibilityListBody is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.resumesPostResumeVisibilityListBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsResumeVisibilityErrorsBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddVacancyToArchiveRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddVacancyToArchiveRequest) HHUserAgent(hHUserAgent string) ApiAddVacancyToArchiveRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddVacancyToArchiveRequest) Locale(locale string) ApiAddVacancyToArchiveRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddVacancyToArchiveRequest) Host(host string) ApiAddVacancyToArchiveRequest {
	r.host = &host
	return r
}

func (r ApiAddVacancyToArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddVacancyToArchiveExecute(r)
}

/*
AddVacancyToArchive Архивация вакансии

Переносит вакансию в архив

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @param vacancyId Идентификатор вакансии
 @return ApiAddVacancyToArchiveRequest
*/
func (a *DefaultApiService) AddVacancyToArchive(ctx context.Context, employerId string, vacancyId string) ApiAddVacancyToArchiveRequest {
	return ApiAddVacancyToArchiveRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddVacancyToArchiveExecute(r ApiAddVacancyToArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddVacancyToArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/archived/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddVacancyToArchive_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddVacancyToArchive_0Request) HHUserAgent(hHUserAgent string) ApiAddVacancyToArchive_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddVacancyToArchive_0Request) Locale(locale string) ApiAddVacancyToArchive_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddVacancyToArchive_0Request) Host(host string) ApiAddVacancyToArchive_0Request {
	r.host = &host
	return r
}

func (r ApiAddVacancyToArchive_0Request) Execute() (*http.Response, error) {
	return r.ApiService.AddVacancyToArchive_1Execute(r)
}

/*
AddVacancyToArchive_0 Архивация вакансии

Переносит вакансию в архив

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @param vacancyId Идентификатор вакансии
 @return ApiAddVacancyToArchive_0Request
*/
func (a *DefaultApiService) AddVacancyToArchive_1(ctx context.Context, employerId string, vacancyId string) ApiAddVacancyToArchive_0Request {
	return ApiAddVacancyToArchive_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddVacancyToArchive_1Execute(r ApiAddVacancyToArchive_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddVacancyToArchive_1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/archived/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddVacancyToBlacklistedRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddVacancyToBlacklistedRequest) HHUserAgent(hHUserAgent string) ApiAddVacancyToBlacklistedRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddVacancyToBlacklistedRequest) Locale(locale string) ApiAddVacancyToBlacklistedRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddVacancyToBlacklistedRequest) Host(host string) ApiAddVacancyToBlacklistedRequest {
	r.host = &host
	return r
}

func (r ApiAddVacancyToBlacklistedRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddVacancyToBlacklistedExecute(r)
}

/*
AddVacancyToBlacklisted Добавление вакансии в список скрытых

Добавляет указанную вакансию в [список скрытых вакансий](#tag/Skrytye-vakansii/operation/get-blacklisted-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiAddVacancyToBlacklistedRequest
*/
func (a *DefaultApiService) AddVacancyToBlacklisted(ctx context.Context, vacancyId string) ApiAddVacancyToBlacklistedRequest {
	return ApiAddVacancyToBlacklistedRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddVacancyToBlacklistedExecute(r ApiAddVacancyToBlacklistedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddVacancyToBlacklisted")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/blacklisted/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyBlacklistedBadRequestErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsVacancyBlacklistedNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddVacancyToFavoriteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddVacancyToFavoriteRequest) HHUserAgent(hHUserAgent string) ApiAddVacancyToFavoriteRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddVacancyToFavoriteRequest) Locale(locale string) ApiAddVacancyToFavoriteRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddVacancyToFavoriteRequest) Host(host string) ApiAddVacancyToFavoriteRequest {
	r.host = &host
	return r
}

func (r ApiAddVacancyToFavoriteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddVacancyToFavoriteExecute(r)
}

/*
AddVacancyToFavorite Добавление вакансии в список отобранных

Добавляет указанную вакансию в [список отобранных вакансий](#tag/Otobrannye-vakansii/operation/get-favorite-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiAddVacancyToFavoriteRequest
*/
func (a *DefaultApiService) AddVacancyToFavorite(ctx context.Context, vacancyId string) ApiAddVacancyToFavoriteRequest {
	return ApiAddVacancyToFavoriteRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddVacancyToFavoriteExecute(r ApiAddVacancyToFavoriteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddVacancyToFavorite")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/favorited/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyFavoritedCombinedBadAuthErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddVacancyToHiddenRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiAddVacancyToHiddenRequest) HHUserAgent(hHUserAgent string) ApiAddVacancyToHiddenRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiAddVacancyToHiddenRequest) Locale(locale string) ApiAddVacancyToHiddenRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiAddVacancyToHiddenRequest) Host(host string) ApiAddVacancyToHiddenRequest {
	r.host = &host
	return r
}

func (r ApiAddVacancyToHiddenRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddVacancyToHiddenExecute(r)
}

/*
AddVacancyToHidden Удаление вакансий

Удалить можно только вакансию из архива

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @param vacancyId Идентификатор вакансии
 @return ApiAddVacancyToHiddenRequest
*/
func (a *DefaultApiService) AddVacancyToHidden(ctx context.Context, employerId string, vacancyId string) ApiAddVacancyToHiddenRequest {
	return ApiAddVacancyToHiddenRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddVacancyToHiddenExecute(r ApiAddVacancyToHiddenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddVacancyToHidden")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/hidden/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApplyToVacancyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	resumeId *string
	vacancyId *string
	locale *string
	host *string
	message *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiApplyToVacancyRequest) HHUserAgent(hHUserAgent string) ApiApplyToVacancyRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор резюме, которым производится отклик
func (r ApiApplyToVacancyRequest) ResumeId(resumeId string) ApiApplyToVacancyRequest {
	r.resumeId = &resumeId
	return r
}

// Идентификатор вакансии, на которую происходит отклик
func (r ApiApplyToVacancyRequest) VacancyId(vacancyId string) ApiApplyToVacancyRequest {
	r.vacancyId = &vacancyId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiApplyToVacancyRequest) Locale(locale string) ApiApplyToVacancyRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiApplyToVacancyRequest) Host(host string) ApiApplyToVacancyRequest {
	r.host = &host
	return r
}

// Сопроводительное письмо к отклику.  Является обязательным, если в вакансии указано, что обязательно сопроводительное письмо.  Максимальная длина — 10000 символов 
func (r ApiApplyToVacancyRequest) Message(message string) ApiApplyToVacancyRequest {
	r.message = &message
	return r
}

func (r ApiApplyToVacancyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApplyToVacancyExecute(r)
}

/*
ApplyToVacancy Отклик на вакансию

Запрос позволяет пользователю откликнуться на вакансию.

Чтобы узнать, какими резюме возможно откликнуться на конкретную вакансию, воспользуйтесь [списком подходящих резюме](#tag/Rezyume.-Prosmotr-informacii/operation/get-suitable-resumes)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplyToVacancyRequest
*/
func (a *DefaultApiService) ApplyToVacancy(ctx context.Context) ApiApplyToVacancyRequest {
	return ApiApplyToVacancyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) ApplyToVacancyExecute(r ApiApplyToVacancyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ApplyToVacancy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.resumeId == nil {
		return localVarReturnValue, nil, reportError("resumeId is required and must be specified")
	}
	if r.vacancyId == nil {
		return localVarReturnValue, nil, reportError("vacancyId is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "resume_id", r.resumeId, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "vacancy_id", r.vacancyId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 303 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApplyToVacancy400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyApplyForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorizeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	clientId *string
	clientSecret *string
	code *string
	grantType *string
	redirectUri *string
	refreshToken *string
}

// Идентификатор, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorizeRequest) ClientId(clientId string) ApiAuthorizeRequest {
	r.clientId = &clientId
	return r
}

// Защищенный ключ, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorizeRequest) ClientSecret(clientSecret string) ApiAuthorizeRequest {
	r.clientSecret = &clientSecret
	return r
}

// Значение &#x60;authorization_code&#x60;, полученное при [перенаправлении пользователя](#get-authorization_code) 
func (r ApiAuthorizeRequest) Code(code string) ApiAuthorizeRequest {
	r.code = &code
	return r
}

// Cпособ запроса токена
func (r ApiAuthorizeRequest) GrantType(grantType string) ApiAuthorizeRequest {
	r.grantType = &grantType
	return r
}

// Uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра 
func (r ApiAuthorizeRequest) RedirectUri(redirectUri string) ApiAuthorizeRequest {
	r.redirectUri = &redirectUri
	return r
}

// Refresh-токен, полученный ранее при [получении пары токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) или прошлом обновлении пары
func (r ApiAuthorizeRequest) RefreshToken(refreshToken string) ApiAuthorizeRequest {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiAuthorizeRequest) Execute() (*AuthUserTokenAndAppToken, *http.Response, error) {
	return r.ApiService.AuthorizeExecute(r)
}

/*
Authorize Получение access-токена

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorizeRequest
*/
func (a *DefaultApiService) Authorize(ctx context.Context) ApiAuthorizeRequest {
	return ApiAuthorizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthUserTokenAndAppToken
func (a *DefaultApiService) AuthorizeExecute(r ApiAuthorizeRequest) (*AuthUserTokenAndAppToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthUserTokenAndAppToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Authorize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_id", r.clientId, "")
	}
	if r.clientSecret != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_secret", r.clientSecret, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "code", r.code, "")
	}
	if r.grantType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "grant_type", r.grantType, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "redirect_uri", r.redirectUri, "")
	}
	if r.refreshToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "refresh_token", r.refreshToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadAuthorizationBadParameters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorize_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	clientId *string
	clientSecret *string
	code *string
	grantType *string
	redirectUri *string
	refreshToken *string
}

// Идентификатор, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorize_0Request) ClientId(clientId string) ApiAuthorize_0Request {
	r.clientId = &clientId
	return r
}

// Защищенный ключ, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorize_0Request) ClientSecret(clientSecret string) ApiAuthorize_0Request {
	r.clientSecret = &clientSecret
	return r
}

// Значение &#x60;authorization_code&#x60;, полученное при [перенаправлении пользователя](#get-authorization_code) 
func (r ApiAuthorize_0Request) Code(code string) ApiAuthorize_0Request {
	r.code = &code
	return r
}

// Cпособ запроса токена
func (r ApiAuthorize_0Request) GrantType(grantType string) ApiAuthorize_0Request {
	r.grantType = &grantType
	return r
}

// Uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра 
func (r ApiAuthorize_0Request) RedirectUri(redirectUri string) ApiAuthorize_0Request {
	r.redirectUri = &redirectUri
	return r
}

// Refresh-токен, полученный ранее при [получении пары токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) или прошлом обновлении пары
func (r ApiAuthorize_0Request) RefreshToken(refreshToken string) ApiAuthorize_0Request {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiAuthorize_0Request) Execute() (*AuthUserTokenAndAppToken, *http.Response, error) {
	return r.ApiService.Authorize_2Execute(r)
}

/*
Authorize_0 Получение access-токена

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorize_0Request
*/
func (a *DefaultApiService) Authorize_2(ctx context.Context) ApiAuthorize_0Request {
	return ApiAuthorize_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthUserTokenAndAppToken
func (a *DefaultApiService) Authorize_2Execute(r ApiAuthorize_0Request) (*AuthUserTokenAndAppToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthUserTokenAndAppToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Authorize_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_id", r.clientId, "")
	}
	if r.clientSecret != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_secret", r.clientSecret, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "code", r.code, "")
	}
	if r.grantType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "grant_type", r.grantType, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "redirect_uri", r.redirectUri, "")
	}
	if r.refreshToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "refresh_token", r.refreshToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadAuthorizationBadParameters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuthorize_1Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	clientId *string
	clientSecret *string
	code *string
	grantType *string
	redirectUri *string
	refreshToken *string
}

// Идентификатор, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorize_1Request) ClientId(clientId string) ApiAuthorize_1Request {
	r.clientId = &clientId
	return r
}

// Защищенный ключ, полученный при [создании приложения](https://dev.hh.ru/admin)
func (r ApiAuthorize_1Request) ClientSecret(clientSecret string) ApiAuthorize_1Request {
	r.clientSecret = &clientSecret
	return r
}

// Значение &#x60;authorization_code&#x60;, полученное при [перенаправлении пользователя](#get-authorization_code) 
func (r ApiAuthorize_1Request) Code(code string) ApiAuthorize_1Request {
	r.code = &code
	return r
}

// Cпособ запроса токена
func (r ApiAuthorize_1Request) GrantType(grantType string) ApiAuthorize_1Request {
	r.grantType = &grantType
	return r
}

// Uri для перенаправления пользователя после авторизации. Если не указать, используется из настроек приложения. При наличии происходит валидация значения. Вероятнее всего, потребуется сделать urlencode значения параметра 
func (r ApiAuthorize_1Request) RedirectUri(redirectUri string) ApiAuthorize_1Request {
	r.redirectUri = &redirectUri
	return r
}

// Refresh-токен, полученный ранее при [получении пары токенов](#section/Avtorizaciya/Obnovlenie-pary-access-i-refresh-tokenov) или прошлом обновлении пары
func (r ApiAuthorize_1Request) RefreshToken(refreshToken string) ApiAuthorize_1Request {
	r.refreshToken = &refreshToken
	return r
}

func (r ApiAuthorize_1Request) Execute() (*AuthUserTokenAndAppToken, *http.Response, error) {
	return r.ApiService.Authorize_3Execute(r)
}

/*
Authorize_1 Получение access-токена

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthorize_1Request
*/
func (a *DefaultApiService) Authorize_3(ctx context.Context) ApiAuthorize_1Request {
	return ApiAuthorize_1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AuthUserTokenAndAppToken
func (a *DefaultApiService) Authorize_3Execute(r ApiAuthorize_1Request) (*AuthUserTokenAndAppToken, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthUserTokenAndAppToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Authorize_3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_id", r.clientId, "")
	}
	if r.clientSecret != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "client_secret", r.clientSecret, "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "code", r.code, "")
	}
	if r.grantType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "grant_type", r.grantType, "")
	}
	if r.redirectUri != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "redirect_uri", r.redirectUri, "")
	}
	if r.refreshToken != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "refresh_token", r.refreshToken, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadAuthorizationBadParameters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeVacancyDraftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId string
	hHUserAgent *string
	vacancyDraftVacancyDraftEdit *VacancyDraftVacancyDraftEdit
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiChangeVacancyDraftRequest) HHUserAgent(hHUserAgent string) ApiChangeVacancyDraftRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiChangeVacancyDraftRequest) VacancyDraftVacancyDraftEdit(vacancyDraftVacancyDraftEdit VacancyDraftVacancyDraftEdit) ApiChangeVacancyDraftRequest {
	r.vacancyDraftVacancyDraftEdit = &vacancyDraftVacancyDraftEdit
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiChangeVacancyDraftRequest) Locale(locale string) ApiChangeVacancyDraftRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiChangeVacancyDraftRequest) Host(host string) ApiChangeVacancyDraftRequest {
	r.host = &host
	return r
}

func (r ApiChangeVacancyDraftRequest) Execute() (*VacancyDraftDraftResponseSchema, *http.Response, error) {
	return r.ApiService.ChangeVacancyDraftExecute(r)
}

/*
ChangeVacancyDraft Изменение черновика вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param draftId Идентификатор черновика
 @return ApiChangeVacancyDraftRequest
*/
func (a *DefaultApiService) ChangeVacancyDraft(ctx context.Context, draftId string) ApiChangeVacancyDraftRequest {
	return ApiChangeVacancyDraftRequest{
		ApiService: a,
		ctx: ctx,
		draftId: draftId,
	}
}

// Execute executes the request
//  @return VacancyDraftDraftResponseSchema
func (a *DefaultApiService) ChangeVacancyDraftExecute(r ApiChangeVacancyDraftRequest) (*VacancyDraftDraftResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDraftDraftResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangeVacancyDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts/{draft_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"draft_id"+"}", url.PathEscape(parameterValueToString(r.draftId, "draftId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyDraftVacancyDraftEdit == nil {
		return localVarReturnValue, nil, reportError("vacancyDraftVacancyDraftEdit is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyDraftVacancyDraftEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiConfirmPhoneInResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	phone *string
	confirmationCode *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiConfirmPhoneInResumeRequest) HHUserAgent(hHUserAgent string) ApiConfirmPhoneInResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Телефон который надо подтвердить
func (r ApiConfirmPhoneInResumeRequest) Phone(phone string) ApiConfirmPhoneInResumeRequest {
	r.phone = &phone
	return r
}

// Код для подтверждения
func (r ApiConfirmPhoneInResumeRequest) ConfirmationCode(confirmationCode string) ApiConfirmPhoneInResumeRequest {
	r.confirmationCode = &confirmationCode
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiConfirmPhoneInResumeRequest) Locale(locale string) ApiConfirmPhoneInResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiConfirmPhoneInResumeRequest) Host(host string) ApiConfirmPhoneInResumeRequest {
	r.host = &host
	return r
}

func (r ApiConfirmPhoneInResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfirmPhoneInResumeExecute(r)
}

/*
ConfirmPhoneInResume Подтвердить телефон кодом

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfirmPhoneInResumeRequest
*/
func (a *DefaultApiService) ConfirmPhoneInResume(ctx context.Context) ApiConfirmPhoneInResumeRequest {
	return ApiConfirmPhoneInResumeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) ConfirmPhoneInResumeExecute(r ApiConfirmPhoneInResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConfirmPhoneInResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resume_phone_confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.phone == nil {
		return nil, reportError("phone is required and must be specified")
	}
	if r.confirmationCode == nil {
		return nil, reportError("confirmationCode is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "phone", r.phone, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "confirmation_code", r.confirmationCode, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	sourceResumeId *string
	locale *string
	host *string
	resumeAddResumeRequest *ResumeAddResumeRequest
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiCreateResumeRequest) HHUserAgent(hHUserAgent string) ApiCreateResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор исходного резюме для клонирования
func (r ApiCreateResumeRequest) SourceResumeId(sourceResumeId string) ApiCreateResumeRequest {
	r.sourceResumeId = &sourceResumeId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiCreateResumeRequest) Locale(locale string) ApiCreateResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiCreateResumeRequest) Host(host string) ApiCreateResumeRequest {
	r.host = &host
	return r
}

func (r ApiCreateResumeRequest) ResumeAddResumeRequest(resumeAddResumeRequest ResumeAddResumeRequest) ApiCreateResumeRequest {
	r.resumeAddResumeRequest = &resumeAddResumeRequest
	return r
}

func (r ApiCreateResumeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CreateResumeExecute(r)
}

/*
CreateResume Создание резюме

Создает резюме с полями, переданными в теле запроса.

Если передан параметр `source_resume_id`, новое резюме будет склонировано из указанного. Склонировать можно только собственное резюме


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateResumeRequest
*/
func (a *DefaultApiService) CreateResume(ctx context.Context) ApiCreateResumeRequest {
	return ApiCreateResumeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) CreateResumeExecute(r ApiCreateResumeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateResume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.sourceResumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_resume_id", r.sourceResumeId, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.resumeAddResumeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsResumeBadArgTooManyResumesErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSavedResumeSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	text *string
	textLogic *string
	textField *string
	textPeriod *string
	ageFrom *float32
	ageTo *float32
	area *string
	relocation *string
	period *float32
	dateFrom *string
	dateTo *string
	educationLevel *string
	employment *string
	experience *string
	skill *string
	gender *string
	label *string
	language *string
	languageLevel *string
	metro *string
	currency *string
	salaryFrom *float32
	salaryTo *float32
	schedule *string
	orderBy *string
	citizenship *string
	workTicket *string
	educationalInstitution *string
	searchInResponses *bool
	byTextPrefix *bool
	driverLicenseTypes *string
	vacancyId *string
	page *float32
	perPage *float32
	professionalRole *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiCreateSavedResumeSearchRequest) HHUserAgent(hHUserAgent string) ApiCreateSavedResumeSearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Поисковая фраза. Метод найдет резюме, в которых встречаются все слова заданной фразы.  Особенности:  * Можно указать несколько значений. Каждое дополнительное значение уточняет поиск. * В качестве поисковой фразы можно использовать [язык поисковых запросов](http://hh.ru/article.xml?articleId&#x3D;1175). * Специально для этого поля предусмотрено [автодополнение по подсказкам](#tag/Podskazki/operation/get-resume-search-keywords-suggests). * Для тонкой настройки по фразе можно использовать параметры &#x60;text.logic&#x60;, &#x60;text.field&#x60;, &#x60;text.period&#x60;. При использовании дополнительных &#x60;text.*&#x60; полей, необходимо указывать весь набор (триаду) параметров 
func (r ApiCreateSavedResumeSearchRequest) Text(text string) ApiCreateSavedResumeSearchRequest {
	r.text = &text
	return r
}

// Описывает, как производится поиск. Возможные значения перечислены в поле &#x60;resume_search_logic&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiCreateSavedResumeSearchRequest) TextLogic(textLogic string) ApiCreateSavedResumeSearchRequest {
	r.textLogic = &textLogic
	return r
}

// Описывает, где должны встречаться слова из поисковой фразы &#x60;text&#x60;. Можно указать несколько значений через запятую, например &#x60;?text.field&#x3D;education,keywords&#x60;. Возможные значения перечислены в поле &#x60;resume_search_fields&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiCreateSavedResumeSearchRequest) TextField(textField string) ApiCreateSavedResumeSearchRequest {
	r.textField = &textField
	return r
}

// Период опыта работы.  Параметр имеет смысл только при &#x60;text.field&#x60; равным одному из значений: &#x60;experience&#x60;, &#x60;experience_company&#x60;, &#x60;experience_position&#x60;, &#x60;experience_description&#x60;, но указывать его необходимо всегда при указании других &#x60;text.*&#x60;. Если параметр не имеет смысла, то его значение можно оставить пустым 
func (r ApiCreateSavedResumeSearchRequest) TextPeriod(textPeriod string) ApiCreateSavedResumeSearchRequest {
	r.textPeriod = &textPeriod
	return r
}

// Нижняя граница возраста соискателя в годах.  По умолчанию в выдачу добавляются также резюме с неуказанным возрастом. Для выдачи резюме только с указанным возрастом передайте значение &#x60;only_with_age&#x60; в параметре &#x60;label&#x60; 
func (r ApiCreateSavedResumeSearchRequest) AgeFrom(ageFrom float32) ApiCreateSavedResumeSearchRequest {
	r.ageFrom = &ageFrom
	return r
}

// Верхняя граница возраста соискателя в годах.  По умолчанию в выдачу добавляются также резюме с неуказанным возрастом. Для выдачи резюме только с указанным возрастом передайте значение &#x60;only_with_age&#x60; в параметре &#x60;label&#x60; 
func (r ApiCreateSavedResumeSearchRequest) AgeTo(ageTo float32) ApiCreateSavedResumeSearchRequest {
	r.ageTo = &ageTo
	return r
}

// Регион. Возможные значения указаны в [справочнике регионов](#tag/Obshie-spravochniki/operation/get-areas). Можно указать несколько значений.  По умолчанию выбираются резюме, в которых соискатели живут в указанных регионах или готовы в них переехать. Поменять это поведение поиска можно, указав параметр &#x60;relocation&#x60; 
func (r ApiCreateSavedResumeSearchRequest) Area(area string) ApiCreateSavedResumeSearchRequest {
	r.area = &area
	return r
}

// Готовность к переезду. Возможные значения указаны в поле &#x60;resume_search_relocation&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Необходимо указывать вместе с параметром &#x60;area&#x60; 
func (r ApiCreateSavedResumeSearchRequest) Relocation(relocation string) ApiCreateSavedResumeSearchRequest {
	r.relocation = &relocation
	return r
}

// Поиск ведется по резюме, опубликованным за указанный период в днях. Если период не указан, поиск ведется без ограничений по дате публикации 
func (r ApiCreateSavedResumeSearchRequest) Period(period float32) ApiCreateSavedResumeSearchRequest {
	r.period = &period
	return r
}

// Дата, от которой нужно начать поиск. Значение указывается в формате [ISO 8601](#date-format) — &#x60;YYYY-MM-DD&#x60; или с точностью до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Нельзя передавать вместе с параметром &#x60;period&#x60; 
func (r ApiCreateSavedResumeSearchRequest) DateFrom(dateFrom string) ApiCreateSavedResumeSearchRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, до которой нужно искать. Значение указывается в формате [ISO 8601](#date-format) — &#x60;YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Можно передавать только в паре с параметром &#x60;date_from&#x60;. Нельзя передавать вместе с параметром &#x60;period&#x60; 
func (r ApiCreateSavedResumeSearchRequest) DateTo(dateTo string) ApiCreateSavedResumeSearchRequest {
	r.dateTo = &dateTo
	return r
}

// Уровень образования. Возможные значения перечислены в поле &#x60;education_level&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Если параметр не указан, поиск ведется без ограничений на уровень образования 
func (r ApiCreateSavedResumeSearchRequest) EducationLevel(educationLevel string) ApiCreateSavedResumeSearchRequest {
	r.educationLevel = &educationLevel
	return r
}

// Тип занятости. Возможные значения перечислены в поле &#x60;employment&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) Employment(employment string) ApiCreateSavedResumeSearchRequest {
	r.employment = &employment
	return r
}

// Опыт работы. Возможные значения перечислены в поле &#x60;experience&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiCreateSavedResumeSearchRequest) Experience(experience string) ApiCreateSavedResumeSearchRequest {
	r.experience = &experience
	return r
}

// Ключевые навыки. Указывается один или несколько идентификаторов ключевых навыков. Значения можно получить из поля &#x60;id&#x60; в [подсказке по ключевым навыкам](#tag/Podskazki/operation/get-skill-set-suggests) 
func (r ApiCreateSavedResumeSearchRequest) Skill(skill string) ApiCreateSavedResumeSearchRequest {
	r.skill = &skill
	return r
}

// Пол соискателя. Возможные значения перечислены в поле &#x60;gender&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries).  По умолчанию вне зависимости от значения параметра будут найдены резюме, в которых пол не указан, убрать такие резюме можно с помощью параметра &#x60;label&#x3D;only_with_gender&#x60; 
func (r ApiCreateSavedResumeSearchRequest) Gender(gender string) ApiCreateSavedResumeSearchRequest {
	r.gender = &gender
	return r
}

// Дополнительный фильтр. Возможные значения перечислены в поле &#x60;resume_search_label&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) Label(label string) ApiCreateSavedResumeSearchRequest {
	r.label = &label
	return r
}

// Знание языка. Можно указать несколько значений.  Возможные значения перечислены в [справочнике языков](#tag/Obshie-spravochniki/operation/get-languages) 
func (r ApiCreateSavedResumeSearchRequest) Language(language string) ApiCreateSavedResumeSearchRequest {
	r.language = &language
	return r
}

// Уровень знания языка. Можно указать несколько значений.  Возможные значения перечислены в поле &#x60;language_level&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiCreateSavedResumeSearchRequest) LanguageLevel(languageLevel string) ApiCreateSavedResumeSearchRequest {
	r.languageLevel = &languageLevel
	return r
}

// Линия, либо станция метро. Возможные значения перечислены в [справочнике метро](#tag/Obshie-spravochniki/operation/get-metro-stations) 
func (r ApiCreateSavedResumeSearchRequest) Metro(metro string) ApiCreateSavedResumeSearchRequest {
	r.metro = &metro
	return r
}

// Код валюты. Возможные значения перечислены в поле &#x60;currency.code&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiCreateSavedResumeSearchRequest) Currency(currency string) ApiCreateSavedResumeSearchRequest {
	r.currency = &currency
	return r
}

// Нижняя граница желаемой заработной платы (ЗП).  По умолчанию в выдачу добавляются также резюме с неуказанной ЗП. Для выдачи резюме только с указанной ЗП передайте параметр &#x60;label&#x3D;only_with_salary&#x60; 
func (r ApiCreateSavedResumeSearchRequest) SalaryFrom(salaryFrom float32) ApiCreateSavedResumeSearchRequest {
	r.salaryFrom = &salaryFrom
	return r
}

// Верхняя граница желаемой заработной платы (ЗП).  По умолчанию в выдачу добавляются также резюме с неуказанной ЗП. Для выдачи резюме только с указанной ЗП передайте параметр &#x60;label&#x3D;only_with_salary&#x60; 
func (r ApiCreateSavedResumeSearchRequest) SalaryTo(salaryTo float32) ApiCreateSavedResumeSearchRequest {
	r.salaryTo = &salaryTo
	return r
}

// График работы. Возможные значения перечислены в поле &#x60;schedule&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) Schedule(schedule string) ApiCreateSavedResumeSearchRequest {
	r.schedule = &schedule
	return r
}

// Сортировка списка резюме. Возможные значения перечислены в поле &#x60;resume_search_order&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiCreateSavedResumeSearchRequest) OrderBy(orderBy string) ApiCreateSavedResumeSearchRequest {
	r.orderBy = &orderBy
	return r
}

// Страна гражданства соискателя. Возможные значения перечислены в [справочнике стран](#tag/Obshie-spravochniki/operation/get-countries). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) Citizenship(citizenship string) ApiCreateSavedResumeSearchRequest {
	r.citizenship = &citizenship
	return r
}

// Страна, в которой у соискателя есть разрешение на работу. Возможные значения перечислены в [справочнике стран](#tag/Obshie-spravochniki/operation/get-countries). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) WorkTicket(workTicket string) ApiCreateSavedResumeSearchRequest {
	r.workTicket = &workTicket
	return r
}

// Учебные заведения соискателя. В качестве параметров используются [подсказки по названиям университетов](#tag/Podskazki). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) EducationalInstitution(educationalInstitution string) ApiCreateSavedResumeSearchRequest {
	r.educationalInstitution = &educationalInstitution
	return r
}

// Если &#x60;true&#x60;, то поиск осуществляется только по резюме, которыми соискатели откликались на вакансии компании текущего пользователя, если &#x60;false&#x60; — поиск осуществляется по всем резюме. По умолчанию — &#x60;false&#x60; 
func (r ApiCreateSavedResumeSearchRequest) SearchInResponses(searchInResponses bool) ApiCreateSavedResumeSearchRequest {
	r.searchInResponses = &searchInResponses
	return r
}

// Если &#x60;true&#x60;, включается поиск по префиксу. Для каждого параметра &#x60;text&#x60; будут находиться не только полные совпадения слов, но еще и слова, начинающиеся с &#x60;text&#x60;. По умолчанию — &#x60;false&#x60; 
func (r ApiCreateSavedResumeSearchRequest) ByTextPrefix(byTextPrefix bool) ApiCreateSavedResumeSearchRequest {
	r.byTextPrefix = &byTextPrefix
	return r
}

// Категории водительских прав соискателя. Возможные значения перечислены в поле &#x60;driver_license_types&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiCreateSavedResumeSearchRequest) DriverLicenseTypes(driverLicenseTypes string) ApiCreateSavedResumeSearchRequest {
	r.driverLicenseTypes = &driverLicenseTypes
	return r
}

// Идентификатор вакансии для поиска похожих резюме. Необходимо передавать идентификатор активной вакансии работодателя или вакансии работодателя в архиве 
func (r ApiCreateSavedResumeSearchRequest) VacancyId(vacancyId string) ApiCreateSavedResumeSearchRequest {
	r.vacancyId = &vacancyId
	return r
}

// Номер страницы (считается от 0, по умолчанию — 0)
func (r ApiCreateSavedResumeSearchRequest) Page(page float32) ApiCreateSavedResumeSearchRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию — 10, максимальное значение — 50)
func (r ApiCreateSavedResumeSearchRequest) PerPage(perPage float32) ApiCreateSavedResumeSearchRequest {
	r.perPage = &perPage
	return r
}

// Профессиональная роль. Элемент справочника [профессиональных ролей](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary). Можно указать несколько значений 
func (r ApiCreateSavedResumeSearchRequest) ProfessionalRole(professionalRole string) ApiCreateSavedResumeSearchRequest {
	r.professionalRole = &professionalRole
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiCreateSavedResumeSearchRequest) Locale(locale string) ApiCreateSavedResumeSearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiCreateSavedResumeSearchRequest) Host(host string) ApiCreateSavedResumeSearchRequest {
	r.host = &host
	return r
}

func (r ApiCreateSavedResumeSearchRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CreateSavedResumeSearchExecute(r)
}

/*
CreateSavedResumeSearch Создание нового сохраненного поиска резюме

Некоторые параметры принимают множественные значения: `key=value&key=value`.

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше 2000. Например, возможен запрос `per_page=10&page=199` (выдача с 1991 по 2000 вакансию), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с 2001 до 2010 вакансию)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSavedResumeSearchRequest
*/
func (a *DefaultApiService) CreateSavedResumeSearch(ctx context.Context) ApiCreateSavedResumeSearchRequest {
	return ApiCreateSavedResumeSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) CreateSavedResumeSearchExecute(r ApiCreateSavedResumeSearchRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSavedResumeSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.textLogic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.logic", r.textLogic, "")
	}
	if r.textField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.field", r.textField, "")
	}
	if r.textPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.period", r.textPeriod, "")
	}
	if r.ageFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age_from", r.ageFrom, "")
	}
	if r.ageTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age_to", r.ageTo, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.relocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relocation", r.relocation, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.educationLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "education_level", r.educationLevel, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.skill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skill", r.skill, "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.languageLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language.level", r.languageLevel, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salaryFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary_from", r.salaryFrom, "")
	}
	if r.salaryTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary_to", r.salaryTo, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.citizenship != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citizenship", r.citizenship, "")
	}
	if r.workTicket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "work_ticket", r.workTicket, "")
	}
	if r.educationalInstitution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "educational_institution", r.educationalInstitution, "")
	}
	if r.searchInResponses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_in_responses", r.searchInResponses, "")
	}
	if r.byTextPrefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "by_text_prefix", r.byTextPrefix, "")
	}
	if r.driverLicenseTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "driver_license_types", r.driverLicenseTypes, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSavedVacancySearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	text *string
	searchField *string
	experience *string
	employment *string
	schedule *string
	area *string
	metro *string
	professionalRole *string
	industry *string
	employerId *string
	currency *string
	salary *float32
	label *string
	onlyWithSalary *bool
	period *float32
	dateFrom *string
	dateTo *string
	topLat *float32
	bottomLat *float32
	leftLng *float32
	rightLng *float32
	orderBy *string
	sortPointLat *float32
	sortPointLng *float32
	clusters *bool
	describeArguments *bool
	noMagic *bool
	premium *bool
	responsesCountEnabled *bool
	partTime *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiCreateSavedVacancySearchRequest) HHUserAgent(hHUserAgent string) ApiCreateSavedVacancySearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiCreateSavedVacancySearchRequest) Page(page float32) ApiCreateSavedVacancySearchRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию - 10, максимальное значение - 100)
func (r ApiCreateSavedVacancySearchRequest) PerPage(perPage float32) ApiCreateSavedVacancySearchRequest {
	r.perPage = &perPage
	return r
}

// Переданное значение ищется в полях вакансии, указанных в параметре &#x60;search_field&#x60;. Доступен [язык запросов](https://hh.ru/article/1175). Специально для этого поля есть [автодополнение](#tag/Podskazki/operation/get-vacancy-search-keywords)
func (r ApiCreateSavedVacancySearchRequest) Text(text string) ApiCreateSavedVacancySearchRequest {
	r.text = &text
	return r
}

// Область поиска. Справочник с возможными значениями: &#x60;vacancy_search_fields&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). По умолчанию, используются все поля. Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) SearchField(searchField string) ApiCreateSavedVacancySearchRequest {
	r.searchField = &searchField
	return r
}

// Опыт работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;experience&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Experience(experience string) ApiCreateSavedVacancySearchRequest {
	r.experience = &experience
	return r
}

// Тип занятости. Необходимо передавать &#x60;id&#x60; из справочника &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Employment(employment string) ApiCreateSavedVacancySearchRequest {
	r.employment = &employment
	return r
}

// График работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;schedule&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Schedule(schedule string) ApiCreateSavedVacancySearchRequest {
	r.schedule = &schedule
	return r
}

// Регион. Необходимо передавать &#x60;id&#x60; из справочника [/areas](#tag/Obshie-spravochniki/operation/get-areas). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Area(area string) ApiCreateSavedVacancySearchRequest {
	r.area = &area
	return r
}

// Ветка или станция метро. Необходимо передавать &#x60;id&#x60; из справочника [/metro](#tag/Obshie-spravochniki/operation/get-metro-stations). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Metro(metro string) ApiCreateSavedVacancySearchRequest {
	r.metro = &metro
	return r
}

// Профессиональная область. Необходимо передавать &#x60;id&#x60; из справочника [/professional_roles](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary) 
func (r ApiCreateSavedVacancySearchRequest) ProfessionalRole(professionalRole string) ApiCreateSavedVacancySearchRequest {
	r.professionalRole = &professionalRole
	return r
}

// Индустрия компании, разместившей вакансию. Необходимо передавать &#x60;id&#x60; из справочника [/industries](#tag/Obshie-spravochniki/operation/get-industries). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Industry(industry string) ApiCreateSavedVacancySearchRequest {
	r.industry = &industry
	return r
}

// Идентификатор [работодателя](#tag/Rabotodatel). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) EmployerId(employerId string) ApiCreateSavedVacancySearchRequest {
	r.employerId = &employerId
	return r
}

// Код валюты. Справочник с возможными значениями: &#x60;currency&#x60; (ключ &#x60;code&#x60;) в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Имеет смысл указывать только совместно с параметром &#x60;salary&#x60; 
func (r ApiCreateSavedVacancySearchRequest) Currency(currency string) ApiCreateSavedVacancySearchRequest {
	r.currency = &currency
	return r
}

// Размер заработной платы. Если указано это поле, но не указано &#x60;currency&#x60;, то для &#x60;currency&#x60; используется значение RUR.  При указании значения будут найдены вакансии, в которых вилка зарплаты близка к указанной в запросе. При этом значения пересчитываются по текущим курсам ЦБ РФ. Например, при указании &#x60;salary&#x3D;100&amp;currency&#x3D;EUR&#x60; будут найдены вакансии, где вилка зарплаты указана в рублях и после пересчёта в Евро близка к 100 EUR.  По умолчанию будут также найдены вакансии, в которых вилка зарплаты не указана, чтобы такие вакансии отфильтровать, используйте &#x60;only_with_salary&#x3D;true&#x60; 
func (r ApiCreateSavedVacancySearchRequest) Salary(salary float32) ApiCreateSavedVacancySearchRequest {
	r.salary = &salary
	return r
}

// Фильтр по меткам вакансий. Необходимо передавать &#x60;id&#x60; из справочника &#x60;vacancy_label&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) Label(label string) ApiCreateSavedVacancySearchRequest {
	r.label = &label
	return r
}

// Показывать вакансии только с указанием зарплаты. По умолчанию &#x60;false&#x60; 
func (r ApiCreateSavedVacancySearchRequest) OnlyWithSalary(onlyWithSalary bool) ApiCreateSavedVacancySearchRequest {
	r.onlyWithSalary = &onlyWithSalary
	return r
}

// Количество дней, в пределах которых производится поиск по вакансиям 
func (r ApiCreateSavedVacancySearchRequest) Period(period float32) ApiCreateSavedVacancySearchRequest {
	r.period = &period
	return r
}

// Дата, которая ограничивает снизу диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;.  Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiCreateSavedVacancySearchRequest) DateFrom(dateFrom string) ApiCreateSavedVacancySearchRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, которая ограничивает сверху диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;.  Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiCreateSavedVacancySearchRequest) DateTo(dateTo string) ApiCreateSavedVacancySearchRequest {
	r.dateTo = &dateTo
	return r
}

// Верхняя граница широты.  При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби.  Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiCreateSavedVacancySearchRequest) TopLat(topLat float32) ApiCreateSavedVacancySearchRequest {
	r.topLat = &topLat
	return r
}

// Нижняя граница широты.  При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби.  Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiCreateSavedVacancySearchRequest) BottomLat(bottomLat float32) ApiCreateSavedVacancySearchRequest {
	r.bottomLat = &bottomLat
	return r
}

// Левая граница долготы.  При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби.  Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiCreateSavedVacancySearchRequest) LeftLng(leftLng float32) ApiCreateSavedVacancySearchRequest {
	r.leftLng = &leftLng
	return r
}

// Правая граница долготы.  При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби.  Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiCreateSavedVacancySearchRequest) RightLng(rightLng float32) ApiCreateSavedVacancySearchRequest {
	r.rightLng = &rightLng
	return r
}

// Сортировка списка вакансий. Справочник с возможными значениями: &#x60;vacancy_search_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries).  Если выбрана сортировка по удалённости от гео-точки &#x60;distance&#x60;, необходимо также задать её координаты: &#x60;sort_point_lat&#x60;, &#x60;sort_point_lng&#x60; 
func (r ApiCreateSavedVacancySearchRequest) OrderBy(orderBy string) ApiCreateSavedVacancySearchRequest {
	r.orderBy = &orderBy
	return r
}

// Значение географической широты точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiCreateSavedVacancySearchRequest) SortPointLat(sortPointLat float32) ApiCreateSavedVacancySearchRequest {
	r.sortPointLat = &sortPointLat
	return r
}

// Значение географической долготы точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiCreateSavedVacancySearchRequest) SortPointLng(sortPointLng float32) ApiCreateSavedVacancySearchRequest {
	r.sortPointLng = &sortPointLng
	return r
}

// Возвращать ли [кластеры для данного поиска](#tag/Poisk-vakansij/Klastery-v-poiske-vakansij). По умолчанию — &#x60;false&#x60; 
func (r ApiCreateSavedVacancySearchRequest) Clusters(clusters bool) ApiCreateSavedVacancySearchRequest {
	r.clusters = &clusters
	return r
}

// Возвращать ли описание использованных параметров поиска. Успешный ответ будет содержать поле [&#x60;arguments&#x60;]((#tag/Poisk-vakansij/operation/get-vacancies))).  По умолчанию — &#x60;false&#x60; 
func (r ApiCreateSavedVacancySearchRequest) DescribeArguments(describeArguments bool) ApiCreateSavedVacancySearchRequest {
	r.describeArguments = &describeArguments
	return r
}

// Если значение &#x60;true&#x60; — автоматическое преобразование вакансий отключено. По умолчанию – false.  При включённом автоматическом преобразовании, будет предпринята попытка изменить текстовый запрос пользователя на набор параметров. Например, запрос &#x60;text&#x3D;москва бухгалтер 100500&#x60; будет преобразован в &#x60;text&#x3D;бухгалтер&amp;only_with_salary&#x3D;true&amp;area&#x3D;1&amp;salary&#x3D;100500&#x60; 
func (r ApiCreateSavedVacancySearchRequest) NoMagic(noMagic bool) ApiCreateSavedVacancySearchRequest {
	r.noMagic = &noMagic
	return r
}

// Если значение &#x60;true&#x60; — в сортировке вакансий будет учтены премиум вакансии. Такая сортировка используется на сайте. По умолчанию — false 
func (r ApiCreateSavedVacancySearchRequest) Premium(premium bool) ApiCreateSavedVacancySearchRequest {
	r.premium = &premium
	return r
}

// Если значение &#x60;true&#x60; — дополнительное поле &#x60;counters&#x60; с количеством откликов для вакансии включено. По-умолчанию — &#x60;false&#x60; 
func (r ApiCreateSavedVacancySearchRequest) ResponsesCountEnabled(responsesCountEnabled bool) ApiCreateSavedVacancySearchRequest {
	r.responsesCountEnabled = &responsesCountEnabled
	return r
}

// Вакансии для подработки. Возможные значения:  * Все элементы из &#x60;working_days&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_intervals&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_modes&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элементы &#x60;part&#x60; или &#x60;project&#x60; из &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элемент &#x60;accept_temporary&#x60;, показывает вакансии только с временным трудоустройством.  Можно указать несколько значений 
func (r ApiCreateSavedVacancySearchRequest) PartTime(partTime bool) ApiCreateSavedVacancySearchRequest {
	r.partTime = &partTime
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiCreateSavedVacancySearchRequest) Locale(locale string) ApiCreateSavedVacancySearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiCreateSavedVacancySearchRequest) Host(host string) ApiCreateSavedVacancySearchRequest {
	r.host = &host
	return r
}

func (r ApiCreateSavedVacancySearchRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.CreateSavedVacancySearchExecute(r)
}

/*
CreateSavedVacancySearch Создание нового сохраненного поиска вакансий

Некоторые параметры принимают множественные значения: `key=value&key=value`.

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше 2000. Например, возможен запрос `per_page=10&page=199` (выдача с 1991 по 2000 вакансию), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с 2001 до 2010 вакансию)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSavedVacancySearchRequest
*/
func (a *DefaultApiService) CreateSavedVacancySearch(ctx context.Context) ApiCreateSavedVacancySearchRequest {
	return ApiCreateSavedVacancySearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultApiService) CreateSavedVacancySearchExecute(r ApiCreateSavedVacancySearchRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSavedVacancySearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/vacancies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_field", r.searchField, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.employerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employer_id", r.employerId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary", r.salary, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.onlyWithSalary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_with_salary", r.onlyWithSalary, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.topLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_lat", r.topLat, "")
	}
	if r.bottomLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bottom_lat", r.bottomLat, "")
	}
	if r.leftLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "left_lng", r.leftLng, "")
	}
	if r.rightLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right_lng", r.rightLng, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.sortPointLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lat", r.sortPointLat, "")
	}
	if r.sortPointLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lng", r.sortPointLng, "")
	}
	if r.clusters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", r.clusters, "")
	}
	if r.describeArguments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe_arguments", r.describeArguments, "")
	}
	if r.noMagic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_magic", r.noMagic, "")
	}
	if r.premium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "premium", r.premium, "")
	}
	if r.responsesCountEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responses_count_enabled", r.responsesCountEnabled, "")
	}
	if r.partTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part_time", r.partTime, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVacancyDraftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	vacancyDraftVacancyDraftCreate *VacancyDraftVacancyDraftCreate
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiCreateVacancyDraftRequest) HHUserAgent(hHUserAgent string) ApiCreateVacancyDraftRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiCreateVacancyDraftRequest) VacancyDraftVacancyDraftCreate(vacancyDraftVacancyDraftCreate VacancyDraftVacancyDraftCreate) ApiCreateVacancyDraftRequest {
	r.vacancyDraftVacancyDraftCreate = &vacancyDraftVacancyDraftCreate
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiCreateVacancyDraftRequest) Locale(locale string) ApiCreateVacancyDraftRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiCreateVacancyDraftRequest) Host(host string) ApiCreateVacancyDraftRequest {
	r.host = &host
	return r
}

func (r ApiCreateVacancyDraftRequest) Execute() (*VacancyDraftDraftResponseSchema, *http.Response, error) {
	return r.ApiService.CreateVacancyDraftExecute(r)
}

/*
CreateVacancyDraft Создание черновика вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVacancyDraftRequest
*/
func (a *DefaultApiService) CreateVacancyDraft(ctx context.Context) ApiCreateVacancyDraftRequest {
	return ApiCreateVacancyDraftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacancyDraftDraftResponseSchema
func (a *DefaultApiService) CreateVacancyDraftExecute(r ApiCreateVacancyDraftRequest) (*VacancyDraftDraftResponseSchema, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDraftDraftResponseSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateVacancyDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyDraftVacancyDraftCreate == nil {
		return localVarReturnValue, nil, reportError("vacancyDraftVacancyDraftCreate is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyDraftVacancyDraftCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsDraftError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApplicantCommentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicantId string
	commentId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteApplicantCommentRequest) HHUserAgent(hHUserAgent string) ApiDeleteApplicantCommentRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteApplicantCommentRequest) Locale(locale string) ApiDeleteApplicantCommentRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteApplicantCommentRequest) Host(host string) ApiDeleteApplicantCommentRequest {
	r.host = &host
	return r
}

func (r ApiDeleteApplicantCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteApplicantCommentExecute(r)
}

/*
DeleteApplicantComment Удаление комментария

Метод требует наличия [платного доступа для работодателя](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).

Удалить комментарий может только его автор


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicantId Идентификатор соискателя, который можно узнать из поля `owner` [в резюме](https://github.com/hhru/api/blob/master/docs/employer_resumes.md#owner-field)
 @param commentId Идентификатор комментария, который будет удален. Его можно узнать в [списке комментариев](#tag/Kommentarii-k-soiskatelyu/operation/get-applicant-comments-list)
 @return ApiDeleteApplicantCommentRequest
*/
func (a *DefaultApiService) DeleteApplicantComment(ctx context.Context, applicantId string, commentId string) ApiDeleteApplicantCommentRequest {
	return ApiDeleteApplicantCommentRequest{
		ApiService: a,
		ctx: ctx,
		applicantId: applicantId,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteApplicantCommentExecute(r ApiDeleteApplicantCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteApplicantComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applicant_comments/{applicant_id}/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicant_id"+"}", url.PathEscape(parameterValueToString(r.applicantId, "applicantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteArtifactRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteArtifactRequest) HHUserAgent(hHUserAgent string) ApiDeleteArtifactRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteArtifactRequest) Locale(locale string) ApiDeleteArtifactRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteArtifactRequest) Host(host string) ApiDeleteArtifactRequest {
	r.host = &host
	return r
}

func (r ApiDeleteArtifactRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteArtifactExecute(r)
}

/*
DeleteArtifact Удаление артефакта

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор артефакта. Чтобы получить его, используйте метод [Получение портфолио](#tag/Rabota-s-artefaktami/operation/get-artifacts-portfolio) или [Получение фотографий](#tag/Rabota-s-artefaktami/operation/get-artifact-photos)
 @return ApiDeleteArtifactRequest
*/
func (a *DefaultApiService) DeleteArtifact(ctx context.Context, id string) ApiDeleteArtifactRequest {
	return ApiDeleteArtifactRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteArtifactExecute(r ApiDeleteArtifactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteArtifact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEmployerFromBlacklistedRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteEmployerFromBlacklistedRequest) HHUserAgent(hHUserAgent string) ApiDeleteEmployerFromBlacklistedRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteEmployerFromBlacklistedRequest) Locale(locale string) ApiDeleteEmployerFromBlacklistedRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteEmployerFromBlacklistedRequest) Host(host string) ApiDeleteEmployerFromBlacklistedRequest {
	r.host = &host
	return r
}

func (r ApiDeleteEmployerFromBlacklistedRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEmployerFromBlacklistedExecute(r)
}

/*
DeleteEmployerFromBlacklisted Удаление работодателя из списка скрытых

Удаляет указанного работодателя из [списка скрытых работодателей](#tag/Skrytye-vakansii/operation/get-blacklisted-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiDeleteEmployerFromBlacklistedRequest
*/
func (a *DefaultApiService) DeleteEmployerFromBlacklisted(ctx context.Context, employerId string) ApiDeleteEmployerFromBlacklistedRequest {
	return ApiDeleteEmployerFromBlacklistedRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteEmployerFromBlacklistedExecute(r ApiDeleteEmployerFromBlacklistedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteEmployerFromBlacklisted")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/blacklisted/{employer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsEmployerBlacklistedNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEmployerFromResumeVisibilityListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	listType string
	id *string
	hHUserAgent *string
	locale *string
	host *string
}

// Идентификатор работодателя. Множественный параметр
func (r ApiDeleteEmployerFromResumeVisibilityListRequest) Id(id string) ApiDeleteEmployerFromResumeVisibilityListRequest {
	r.id = &id
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteEmployerFromResumeVisibilityListRequest) HHUserAgent(hHUserAgent string) ApiDeleteEmployerFromResumeVisibilityListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteEmployerFromResumeVisibilityListRequest) Locale(locale string) ApiDeleteEmployerFromResumeVisibilityListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteEmployerFromResumeVisibilityListRequest) Host(host string) ApiDeleteEmployerFromResumeVisibilityListRequest {
	r.host = &host
	return r
}

func (r ApiDeleteEmployerFromResumeVisibilityListRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEmployerFromResumeVisibilityListExecute(r)
}

/*
DeleteEmployerFromResumeVisibilityList Удаление работодателя из списка видимости

Удаление из списка идемпотентно, то есть удаление отсутствующих в списке или несуществующих работодателей игнорируется и не приводит к ошибкам.

Можно удалить из списка заблокированного работодателя.

За один запрос можно удалить не более 100 компаний


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @param listType Тип списка. Допустимые значения — `whitelist` или `blacklist`
 @return ApiDeleteEmployerFromResumeVisibilityListRequest
*/
func (a *DefaultApiService) DeleteEmployerFromResumeVisibilityList(ctx context.Context, resumeId string, listType string) ApiDeleteEmployerFromResumeVisibilityListRequest {
	return ApiDeleteEmployerFromResumeVisibilityListRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
		listType: listType,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteEmployerFromResumeVisibilityListExecute(r ApiDeleteEmployerFromResumeVisibilityListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteEmployerFromResumeVisibilityList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/{list_type}/employer"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list_type"+"}", url.PathEscape(parameterValueToString(r.listType, "listType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsResumeVisibilityErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEmployerManagerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	successorId *string
	hHUserAgent *string
	locale *string
	host *string
}

// Идентификатор менеджера, которому передаются данные, связанные с удаляемым менеджером, в частности: вакансии, отклики, папки отобранных резюме, комментарии к соискателю, автопоиски и прочее
func (r ApiDeleteEmployerManagerRequest) SuccessorId(successorId string) ApiDeleteEmployerManagerRequest {
	r.successorId = &successorId
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteEmployerManagerRequest) HHUserAgent(hHUserAgent string) ApiDeleteEmployerManagerRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteEmployerManagerRequest) Locale(locale string) ApiDeleteEmployerManagerRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteEmployerManagerRequest) Host(host string) ApiDeleteEmployerManagerRequest {
	r.host = &host
	return r
}

func (r ApiDeleteEmployerManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEmployerManagerExecute(r)
}

/*
DeleteEmployerManager Удаление менеджера

Удаление менеджера занимает некоторое время. По этой причине, если сразу после успешного удаления менеджера вы запросите, например, список менеджеров, в ответе может вернуться удаленный менеджер

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера
 @return ApiDeleteEmployerManagerRequest
*/
func (a *DefaultApiService) DeleteEmployerManager(ctx context.Context, employerId string, managerId string) ApiDeleteEmployerManagerRequest {
	return ApiDeleteEmployerManagerRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteEmployerManagerExecute(r ApiDeleteEmployerManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteEmployerManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.successorId == nil {
		return nil, reportError("successorId is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "successor_id", r.successorId, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerManagerBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsEmployerManagerBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteResumeRequest) HHUserAgent(hHUserAgent string) ApiDeleteResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteResumeRequest) Locale(locale string) ApiDeleteResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteResumeRequest) Host(host string) ApiDeleteResumeRequest {
	r.host = &host
	return r
}

func (r ApiDeleteResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteResumeExecute(r)
}

/*
DeleteResume Удаление резюме

Резюме удаляется без возможности восстановления. Все связанные с ним отклики исчезают

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiDeleteResumeRequest
*/
func (a *DefaultApiService) DeleteResume(ctx context.Context, resumeId string) ApiDeleteResumeRequest {
	return ApiDeleteResumeRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteResumeExecute(r ApiDeleteResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteResumeVisibilityListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	listType string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteResumeVisibilityListRequest) HHUserAgent(hHUserAgent string) ApiDeleteResumeVisibilityListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteResumeVisibilityListRequest) Locale(locale string) ApiDeleteResumeVisibilityListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteResumeVisibilityListRequest) Host(host string) ApiDeleteResumeVisibilityListRequest {
	r.host = &host
	return r
}

func (r ApiDeleteResumeVisibilityListRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteResumeVisibilityListExecute(r)
}

/*
DeleteResumeVisibilityList Очистка списка видимости

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @param listType Тип списка. Допустимые значения — `whitelist` или `blacklist`
 @return ApiDeleteResumeVisibilityListRequest
*/
func (a *DefaultApiService) DeleteResumeVisibilityList(ctx context.Context, resumeId string, listType string) ApiDeleteResumeVisibilityListRequest {
	return ApiDeleteResumeVisibilityListRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
		listType: listType,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteResumeVisibilityListExecute(r ApiDeleteResumeVisibilityListRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteResumeVisibilityList")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/{list_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list_type"+"}", url.PathEscape(parameterValueToString(r.listType, "listType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSavedResumeSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteSavedResumeSearchRequest) HHUserAgent(hHUserAgent string) ApiDeleteSavedResumeSearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteSavedResumeSearchRequest) Locale(locale string) ApiDeleteSavedResumeSearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteSavedResumeSearchRequest) Host(host string) ApiDeleteSavedResumeSearchRequest {
	r.host = &host
	return r
}

func (r ApiDeleteSavedResumeSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSavedResumeSearchExecute(r)
}

/*
DeleteSavedResumeSearch Удаление сохраненного поиска резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска
 @return ApiDeleteSavedResumeSearchRequest
*/
func (a *DefaultApiService) DeleteSavedResumeSearch(ctx context.Context, id string) ApiDeleteSavedResumeSearchRequest {
	return ApiDeleteSavedResumeSearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSavedResumeSearchExecute(r ApiDeleteSavedResumeSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSavedResumeSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSavedVacancySearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteSavedVacancySearchRequest) HHUserAgent(hHUserAgent string) ApiDeleteSavedVacancySearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteSavedVacancySearchRequest) Locale(locale string) ApiDeleteSavedVacancySearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteSavedVacancySearchRequest) Host(host string) ApiDeleteSavedVacancySearchRequest {
	r.host = &host
	return r
}

func (r ApiDeleteSavedVacancySearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSavedVacancySearchExecute(r)
}

/*
DeleteSavedVacancySearch Удаление сохраненного поиска вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска
 @return ApiDeleteSavedVacancySearchRequest
*/
func (a *DefaultApiService) DeleteSavedVacancySearch(ctx context.Context, id string) ApiDeleteSavedVacancySearchRequest {
	return ApiDeleteSavedVacancySearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSavedVacancySearchExecute(r ApiDeleteSavedVacancySearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSavedVacancySearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/vacancies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVacancyDraftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteVacancyDraftRequest) HHUserAgent(hHUserAgent string) ApiDeleteVacancyDraftRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteVacancyDraftRequest) Locale(locale string) ApiDeleteVacancyDraftRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteVacancyDraftRequest) Host(host string) ApiDeleteVacancyDraftRequest {
	r.host = &host
	return r
}

func (r ApiDeleteVacancyDraftRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVacancyDraftExecute(r)
}

/*
DeleteVacancyDraft Удаление черновика вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param draftId Идентификатор черновика
 @return ApiDeleteVacancyDraftRequest
*/
func (a *DefaultApiService) DeleteVacancyDraft(ctx context.Context, draftId string) ApiDeleteVacancyDraftRequest {
	return ApiDeleteVacancyDraftRequest{
		ApiService: a,
		ctx: ctx,
		draftId: draftId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteVacancyDraftExecute(r ApiDeleteVacancyDraftRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteVacancyDraft")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts/{draft_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"draft_id"+"}", url.PathEscape(parameterValueToString(r.draftId, "draftId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVacancyFromBlacklistedRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteVacancyFromBlacklistedRequest) HHUserAgent(hHUserAgent string) ApiDeleteVacancyFromBlacklistedRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteVacancyFromBlacklistedRequest) Locale(locale string) ApiDeleteVacancyFromBlacklistedRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteVacancyFromBlacklistedRequest) Host(host string) ApiDeleteVacancyFromBlacklistedRequest {
	r.host = &host
	return r
}

func (r ApiDeleteVacancyFromBlacklistedRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVacancyFromBlacklistedExecute(r)
}

/*
DeleteVacancyFromBlacklisted Удаление вакансии из списка скрытых

Удаляет указанную вакансию из [списка скрытых вакансий](#tag/Skrytye-vakansii/operation/get-blacklisted-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiDeleteVacancyFromBlacklistedRequest
*/
func (a *DefaultApiService) DeleteVacancyFromBlacklisted(ctx context.Context, vacancyId string) ApiDeleteVacancyFromBlacklistedRequest {
	return ApiDeleteVacancyFromBlacklistedRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteVacancyFromBlacklistedExecute(r ApiDeleteVacancyFromBlacklistedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteVacancyFromBlacklisted")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/blacklisted/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsVacancyBlacklistedNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteVacancyFromFavoriteRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDeleteVacancyFromFavoriteRequest) HHUserAgent(hHUserAgent string) ApiDeleteVacancyFromFavoriteRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDeleteVacancyFromFavoriteRequest) Locale(locale string) ApiDeleteVacancyFromFavoriteRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDeleteVacancyFromFavoriteRequest) Host(host string) ApiDeleteVacancyFromFavoriteRequest {
	r.host = &host
	return r
}

func (r ApiDeleteVacancyFromFavoriteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVacancyFromFavoriteExecute(r)
}

/*
DeleteVacancyFromFavorite Удаление вакансии из списка отобранных

Удаляет указанную вакансию из [списка отобранных вакансий](#tag/Otobrannye-vakansii/operation/get-favorite-vacancies)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiDeleteVacancyFromFavoriteRequest
*/
func (a *DefaultApiService) DeleteVacancyFromFavorite(ctx context.Context, vacancyId string) ApiDeleteVacancyFromFavoriteRequest {
	return ApiDeleteVacancyFromFavoriteRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteVacancyFromFavoriteExecute(r ApiDeleteVacancyFromFavoriteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteVacancyFromFavorite")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/favorited/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableAutomaticVacancyPublicationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId *string
	hHUserAgent *string
	locale *string
	host *string
}

// Идентификатор черновика
func (r ApiDisableAutomaticVacancyPublicationRequest) DraftId(draftId string) ApiDisableAutomaticVacancyPublicationRequest {
	r.draftId = &draftId
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiDisableAutomaticVacancyPublicationRequest) HHUserAgent(hHUserAgent string) ApiDisableAutomaticVacancyPublicationRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiDisableAutomaticVacancyPublicationRequest) Locale(locale string) ApiDisableAutomaticVacancyPublicationRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiDisableAutomaticVacancyPublicationRequest) Host(host string) ApiDisableAutomaticVacancyPublicationRequest {
	r.host = &host
	return r
}

func (r ApiDisableAutomaticVacancyPublicationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableAutomaticVacancyPublicationExecute(r)
}

/*
DisableAutomaticVacancyPublication Отмена автопубликации вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDisableAutomaticVacancyPublicationRequest
*/
func (a *DefaultApiService) DisableAutomaticVacancyPublication(ctx context.Context) ApiDisableAutomaticVacancyPublicationRequest {
	return ApiDisableAutomaticVacancyPublicationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) DisableAutomaticVacancyPublicationExecute(r ApiDisableAutomaticVacancyPublicationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DisableAutomaticVacancyPublication")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/auto_publication"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.draftId == nil {
		return nil, reportError("draftId is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "draft_id", r.draftId, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditArtifactRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	description *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditArtifactRequest) HHUserAgent(hHUserAgent string) ApiEditArtifactRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Описание изображения
func (r ApiEditArtifactRequest) Description(description string) ApiEditArtifactRequest {
	r.description = &description
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditArtifactRequest) Locale(locale string) ApiEditArtifactRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditArtifactRequest) Host(host string) ApiEditArtifactRequest {
	r.host = &host
	return r
}

func (r ApiEditArtifactRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditArtifactExecute(r)
}

/*
EditArtifact Редактирование артефакта

Метод позволяет отредактировать описание портфолио

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор артефакта. Чтобы получить его, используйте метод [Получение портфолио](#tag/Rabota-s-artefaktami/operation/get-artifacts-portfolio)
 @return ApiEditArtifactRequest
*/
func (a *DefaultApiService) EditArtifact(ctx context.Context, id string) ApiEditArtifactRequest {
	return ApiEditArtifactRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditArtifactExecute(r ApiEditArtifactRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditArtifact")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.description == nil {
		return nil, reportError("description is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditCurrentUserInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
	firstName *string
	lastName *string
	middleName *string
	isInSearch *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditCurrentUserInfoRequest) HHUserAgent(hHUserAgent string) ApiEditCurrentUserInfoRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditCurrentUserInfoRequest) Locale(locale string) ApiEditCurrentUserInfoRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditCurrentUserInfoRequest) Host(host string) ApiEditCurrentUserInfoRequest {
	r.host = &host
	return r
}

// Имя
func (r ApiEditCurrentUserInfoRequest) FirstName(firstName string) ApiEditCurrentUserInfoRequest {
	r.firstName = &firstName
	return r
}

// Фамилия
func (r ApiEditCurrentUserInfoRequest) LastName(lastName string) ApiEditCurrentUserInfoRequest {
	r.lastName = &lastName
	return r
}

// Отчество, поле может быть пустым
func (r ApiEditCurrentUserInfoRequest) MiddleName(middleName string) ApiEditCurrentUserInfoRequest {
	r.middleName = &middleName
	return r
}

// Флаг «ищу работу». Возможные значения: &#x60;true&#x60;/&#x60;false&#x60;
func (r ApiEditCurrentUserInfoRequest) IsInSearch(isInSearch string) ApiEditCurrentUserInfoRequest {
	r.isInSearch = &isInSearch
	return r
}

func (r ApiEditCurrentUserInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditCurrentUserInfoExecute(r)
}

/*
EditCurrentUserInfo Редактирование информации авторизованного пользователя

Редактирование ФИО или изменение флага «ищу работу». Данные можно редактировать только группами

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEditCurrentUserInfoRequest
*/
func (a *DefaultApiService) EditCurrentUserInfo(ctx context.Context) ApiEditCurrentUserInfoRequest {
	return ApiEditCurrentUserInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditCurrentUserInfoExecute(r ApiEditCurrentUserInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditCurrentUserInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.firstName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "first_name", r.firstName, "")
	}
	if r.lastName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "last_name", r.lastName, "")
	}
	if r.middleName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "middle_name", r.middleName, "")
	}
	if r.isInSearch != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_in_search", r.isInSearch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditEmployerManagerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	employerManagersManagerData *EmployerManagersManagerData
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditEmployerManagerRequest) HHUserAgent(hHUserAgent string) ApiEditEmployerManagerRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiEditEmployerManagerRequest) EmployerManagersManagerData(employerManagersManagerData EmployerManagersManagerData) ApiEditEmployerManagerRequest {
	r.employerManagersManagerData = &employerManagersManagerData
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditEmployerManagerRequest) Locale(locale string) ApiEditEmployerManagerRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditEmployerManagerRequest) Host(host string) ApiEditEmployerManagerRequest {
	r.host = &host
	return r
}

func (r ApiEditEmployerManagerRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditEmployerManagerExecute(r)
}

/*
EditEmployerManager Редактирование менеджера

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера. Можно узнать из списка [менеджеров](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers)
 @return ApiEditEmployerManagerRequest
*/
func (a *DefaultApiService) EditEmployerManager(ctx context.Context, employerId string, managerId string) ApiEditEmployerManagerRequest {
	return ApiEditEmployerManagerRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditEmployerManagerExecute(r ApiEditEmployerManagerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditEmployerManager")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.employerManagersManagerData == nil {
		return nil, reportError("employerManagersManagerData is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.employerManagersManagerData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerManagerBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsEmployerManagerBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditNegotiationMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nid string
	mid string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditNegotiationMessageRequest) HHUserAgent(hHUserAgent string) ApiEditNegotiationMessageRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditNegotiationMessageRequest) Locale(locale string) ApiEditNegotiationMessageRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditNegotiationMessageRequest) Host(host string) ApiEditNegotiationMessageRequest {
	r.host = &host
	return r
}

func (r ApiEditNegotiationMessageRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditNegotiationMessageExecute(r)
}

/*
EditNegotiationMessage Редактирование сообщения в отклике

На данный момент доступно редактирование только сообщения при отклике. 

Текст сообщения можно редактировать после отправки при соблюдении следующих условий:
- сообщение еще не прочитано другой стороной;
- вакансия, на которую отправлялся отклик, должна быть активна (не в архиве); 
- резюме из отклика не должно быть скрыто или удалено. 

Условия могут измениться.

У каждого сообщения в [списке сообщений в отклике](https://github.com/hhru/api/blob/master/docs/negotiations.md#%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D0%BE%D1%82%D0%BA%D0%BB%D0%B8%D0%BA%D0%B5) в поле `editable` указана возможность редактирования


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nid Идентификатор отклика
 @param mid Идентификатор сообщения в отклике
 @return ApiEditNegotiationMessageRequest
*/
func (a *DefaultApiService) EditNegotiationMessage(ctx context.Context, nid string, mid string) ApiEditNegotiationMessageRequest {
	return ApiEditNegotiationMessageRequest{
		ApiService: a,
		ctx: ctx,
		nid: nid,
		mid: mid,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditNegotiationMessageExecute(r ApiEditNegotiationMessageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditNegotiationMessage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{nid}/messages/{mid}"
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterValueToString(r.nid, "nid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mid"+"}", url.PathEscape(parameterValueToString(r.mid, "mid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsNegotiationEditMessageForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
	resumeEditResumeRequest *ResumeEditResumeRequest
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditResumeRequest) HHUserAgent(hHUserAgent string) ApiEditResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditResumeRequest) Locale(locale string) ApiEditResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditResumeRequest) Host(host string) ApiEditResumeRequest {
	r.host = &host
	return r
}

func (r ApiEditResumeRequest) ResumeEditResumeRequest(resumeEditResumeRequest ResumeEditResumeRequest) ApiEditResumeRequest {
	r.resumeEditResumeRequest = &resumeEditResumeRequest
	return r
}

func (r ApiEditResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditResumeExecute(r)
}

/*
EditResume Обновление резюме

Обновляет переданные в теле запроса поля указанного резюме.

Любой упомянутый в теле запроса массив полностью переопределит существующий. Чтобы добавить к существующему массиву новый элемент, перечислите также в запросе все элементы существующего массива. Так, в приведенном примере запроса к ранее указанному русскому языку добавляется английский.

Дополнительные правила заполнения резюме:

* У соискателя не может быть несколько резюме с одинаковым `title`.
* Специализации должны быть из одной профессиональной области.
* Город проживания должен быть одним из элементов справочника `/areas`, и у этого элемента не должно быть потомков. Например, нельзя указать город проживания «Россия».
* Ближайшая станция метро должна находиться в городе проживания.
* Для специализаций из профессиональной области «Начало карьеры, студенты» (`id=15`) можно не указывать опыт работы и навыки. Для остальных профессиональных областей данные поля должны содержать хотя бы по одной записи


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiEditResumeRequest
*/
func (a *DefaultApiService) EditResume(ctx context.Context, resumeId string) ApiEditResumeRequest {
	return ApiEditResumeRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditResumeExecute(r ApiEditResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.resumeEditResumeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsResumeBadArgumentResumeErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditVacancyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	vacancyEdit *VacancyEdit
	ignoreDuplicates *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditVacancyRequest) HHUserAgent(hHUserAgent string) ApiEditVacancyRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiEditVacancyRequest) VacancyEdit(vacancyEdit VacancyEdit) ApiEditVacancyRequest {
	r.vacancyEdit = &vacancyEdit
	return r
}

// Игнорировать [появление дубликата](https://github.com/hhru/api/blob/master/docs/employer_vacancies.md#edit-ignore-duplicates), после редактирования вакансии. По умолчанию — &#x60;false&#x60;
func (r ApiEditVacancyRequest) IgnoreDuplicates(ignoreDuplicates bool) ApiEditVacancyRequest {
	r.ignoreDuplicates = &ignoreDuplicates
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditVacancyRequest) Locale(locale string) ApiEditVacancyRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditVacancyRequest) Host(host string) ApiEditVacancyRequest {
	r.host = &host
	return r
}

func (r ApiEditVacancyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditVacancyExecute(r)
}

/*
EditVacancy Редактирование вакансий

Изменяет поля вакансии, передаваемые в теле запроса.

Составные поля (например, `salary`, `contacts`, `professional_roles`) можно редактировать только целиком, передавая полный объект. Например, для изменения валюты в зарплате, необходимо передавать также и значение зарплаты.

Поля `billing_type` и `manager` необходимо передавать в отдельном запросе


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiEditVacancyRequest
*/
func (a *DefaultApiService) EditVacancy(ctx context.Context, vacancyId string) ApiEditVacancyRequest {
	return ApiEditVacancyRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditVacancyExecute(r ApiEditVacancyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditVacancy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyEdit == nil {
		return nil, reportError("vacancyEdit is required and must be specified")
	}

	if r.ignoreDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_duplicates", r.ignoreDuplicates, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyAddEditCombinedBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyAddEditBadAuthForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditVacancy_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	vacancyEdit *VacancyEdit
	ignoreDuplicates *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiEditVacancy_0Request) HHUserAgent(hHUserAgent string) ApiEditVacancy_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiEditVacancy_0Request) VacancyEdit(vacancyEdit VacancyEdit) ApiEditVacancy_0Request {
	r.vacancyEdit = &vacancyEdit
	return r
}

// Игнорировать [появление дубликата](https://github.com/hhru/api/blob/master/docs/employer_vacancies.md#edit-ignore-duplicates), после редактирования вакансии. По умолчанию — &#x60;false&#x60;
func (r ApiEditVacancy_0Request) IgnoreDuplicates(ignoreDuplicates bool) ApiEditVacancy_0Request {
	r.ignoreDuplicates = &ignoreDuplicates
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiEditVacancy_0Request) Locale(locale string) ApiEditVacancy_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiEditVacancy_0Request) Host(host string) ApiEditVacancy_0Request {
	r.host = &host
	return r
}

func (r ApiEditVacancy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EditVacancy_4Execute(r)
}

/*
EditVacancy_0 Редактирование вакансий

Изменяет поля вакансии, передаваемые в теле запроса.

Составные поля (например, `salary`, `contacts`, `professional_roles`) можно редактировать только целиком, передавая полный объект. Например, для изменения валюты в зарплате, необходимо передавать также и значение зарплаты.

Поля `billing_type` и `manager` необходимо передавать в отдельном запросе


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiEditVacancy_0Request
*/
func (a *DefaultApiService) EditVacancy_4(ctx context.Context, vacancyId string) ApiEditVacancy_0Request {
	return ApiEditVacancy_0Request{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) EditVacancy_4Execute(r ApiEditVacancy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.EditVacancy_4")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyEdit == nil {
		return nil, reportError("vacancyEdit is required and must be specified")
	}

	if r.ignoreDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_duplicates", r.ignoreDuplicates, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyEdit
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyAddEditCombinedBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyAddEditBadAuthForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActiveNegotiationsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	orderBy *string
	order *string
	vacancyId *string
	hasUpdates *bool
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetActiveNegotiationsRequest) HHUserAgent(hHUserAgent string) ApiGetActiveNegotiationsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetActiveNegotiationsRequest) Page(page float32) ApiGetActiveNegotiationsRequest {
	r.page = &page
	return r
}

// Количество элементов на странице
func (r ApiGetActiveNegotiationsRequest) PerPage(perPage float32) ApiGetActiveNegotiationsRequest {
	r.perPage = &perPage
	return r
}

// Тип сортировки. Возможные значения указаны в поле &#x60;negotiations_order&#x60; [справочника полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiGetActiveNegotiationsRequest) OrderBy(orderBy string) ApiGetActiveNegotiationsRequest {
	r.orderBy = &orderBy
	return r
}

// Направление сортировки. Возможные значения: &#x60;asc&#x60; — по возрастанию, &#x60;desc&#x60; — по убыванию
func (r ApiGetActiveNegotiationsRequest) Order(order string) ApiGetActiveNegotiationsRequest {
	r.order = &order
	return r
}

// Фильтр по ID вакансии
func (r ApiGetActiveNegotiationsRequest) VacancyId(vacancyId string) ApiGetActiveNegotiationsRequest {
	r.vacancyId = &vacancyId
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет только те отклики, для которых есть непросмотренные сообщения. По умолчанию &#x60;false&#x60; 
func (r ApiGetActiveNegotiationsRequest) HasUpdates(hasUpdates bool) ApiGetActiveNegotiationsRequest {
	r.hasUpdates = &hasUpdates
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет статус поиска работы кандидатом 
func (r ApiGetActiveNegotiationsRequest) WithJobSearchStatus(withJobSearchStatus bool) ApiGetActiveNegotiationsRequest {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetActiveNegotiationsRequest) Locale(locale string) ApiGetActiveNegotiationsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetActiveNegotiationsRequest) Host(host string) ApiGetActiveNegotiationsRequest {
	r.host = &host
	return r
}

func (r ApiGetActiveNegotiationsRequest) Execute() (*NegotiationsListResponse, *http.Response, error) {
	return r.ApiService.GetActiveNegotiationsExecute(r)
}

/*
GetActiveNegotiations Список активных откликов

Возвращает список активных откликов соискателя.

Запрос является устаревшим и поддерживается для обратной совместимости. Вместо него используйте [запрос списка откликов](#tag/Perepiska-(otklikipriglasheniya)-dlya-soiskatelya/operation/get-negotiation-list) с параметром `?status=active`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveNegotiationsRequest

Deprecated
*/
func (a *DefaultApiService) GetActiveNegotiations(ctx context.Context) ApiGetActiveNegotiationsRequest {
	return ApiGetActiveNegotiationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NegotiationsListResponse
// Deprecated
func (a *DefaultApiService) GetActiveNegotiationsExecute(r ApiGetActiveNegotiationsRequest) (*NegotiationsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetActiveNegotiations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 20
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.hasUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_updates", r.hasUpdates, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveVacancyListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	page *float32
	perPage *float32
	managerId *string
	text *string
	area *string
	resumeId *string
	orderBy *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetActiveVacancyListRequest) HHUserAgent(hHUserAgent string) ApiGetActiveVacancyListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0)
func (r ApiGetActiveVacancyListRequest) Page(page float32) ApiGetActiveVacancyListRequest {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetActiveVacancyListRequest) PerPage(perPage float32) ApiGetActiveVacancyListRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор менеджера, вакансии которого будут получены в ответе. По умолчанию возвращаются вакансии текущего пользователя.  Если передать несколько &#x60;manager_id&#x60;, будет использован последний. Значения можно взять из [списка](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers) 
func (r ApiGetActiveVacancyListRequest) ManagerId(managerId string) ApiGetActiveVacancyListRequest {
	r.managerId = &managerId
	return r
}

// Строка для поиска по названию вакансии
func (r ApiGetActiveVacancyListRequest) Text(text string) ApiGetActiveVacancyListRequest {
	r.text = &text
	return r
}

// Идентификатор региона с вакансией. Чтобы получить идентификаторы регионов, в которых есть активные вакансии, воспользуйтесь [соответствующим методом](#tag/Informaciya-o-rabotodatele/operation/get-employer-vacancy-areas)
func (r ApiGetActiveVacancyListRequest) Area(area string) ApiGetActiveVacancyListRequest {
	r.area = &area
	return r
}

// Идентификатор резюме. Этот параметр нельзя передавать в комбинации с другими параметрами, только отдельно. Если параметр передан, в ответе возвращаются только те вакансии, которые подходят для указанного резюме, а также дополнительные поля
func (r ApiGetActiveVacancyListRequest) ResumeId(resumeId string) ApiGetActiveVacancyListRequest {
	r.resumeId = &resumeId
	return r
}

// Способ сортировки вакансий. Доступные значения перечислены в поле &#x60;employer_active_vacancies_order&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiGetActiveVacancyListRequest) OrderBy(orderBy string) ApiGetActiveVacancyListRequest {
	r.orderBy = &orderBy
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetActiveVacancyListRequest) Locale(locale string) ApiGetActiveVacancyListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetActiveVacancyListRequest) Host(host string) ApiGetActiveVacancyListRequest {
	r.host = &host
	return r
}

func (r ApiGetActiveVacancyListRequest) Execute() (*VacanciesVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetActiveVacancyListExecute(r)
}

/*
GetActiveVacancyList Просмотр списка опубликованных вакансий

Возвращает список опубликованных вакансий.

Если передан параметр `resume_id`, то в список попадут только те вакансии, которые подходят для указанного резюме. Кроме того, ответ будет содержать дополнительные поля


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetActiveVacancyListRequest
*/
func (a *DefaultApiService) GetActiveVacancyList(ctx context.Context, employerId string) ApiGetActiveVacancyListRequest {
	return ApiGetActiveVacancyListRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyListResponse
func (a *DefaultApiService) GetActiveVacancyListExecute(r ApiGetActiveVacancyListRequest) (*VacanciesVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetActiveVacancyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/active"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 20
		r.perPage = &defaultValue
	}
	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.resumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resume_id", r.resumeId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveVacancyList_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	page *float32
	perPage *float32
	managerId *string
	text *string
	area *string
	resumeId *string
	orderBy *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetActiveVacancyList_0Request) HHUserAgent(hHUserAgent string) ApiGetActiveVacancyList_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0)
func (r ApiGetActiveVacancyList_0Request) Page(page float32) ApiGetActiveVacancyList_0Request {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetActiveVacancyList_0Request) PerPage(perPage float32) ApiGetActiveVacancyList_0Request {
	r.perPage = &perPage
	return r
}

// Идентификатор менеджера, вакансии которого будут получены в ответе. По умолчанию возвращаются вакансии текущего пользователя.  Если передать несколько &#x60;manager_id&#x60;, будет использован последний. Значения можно взять из [списка](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers) 
func (r ApiGetActiveVacancyList_0Request) ManagerId(managerId string) ApiGetActiveVacancyList_0Request {
	r.managerId = &managerId
	return r
}

// Строка для поиска по названию вакансии
func (r ApiGetActiveVacancyList_0Request) Text(text string) ApiGetActiveVacancyList_0Request {
	r.text = &text
	return r
}

// Идентификатор региона с вакансией. Чтобы получить идентификаторы регионов, в которых есть активные вакансии, воспользуйтесь [соответствующим методом](#tag/Informaciya-o-rabotodatele/operation/get-employer-vacancy-areas)
func (r ApiGetActiveVacancyList_0Request) Area(area string) ApiGetActiveVacancyList_0Request {
	r.area = &area
	return r
}

// Идентификатор резюме. Этот параметр нельзя передавать в комбинации с другими параметрами, только отдельно. Если параметр передан, в ответе возвращаются только те вакансии, которые подходят для указанного резюме, а также дополнительные поля
func (r ApiGetActiveVacancyList_0Request) ResumeId(resumeId string) ApiGetActiveVacancyList_0Request {
	r.resumeId = &resumeId
	return r
}

// Способ сортировки вакансий. Доступные значения перечислены в поле &#x60;employer_active_vacancies_order&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiGetActiveVacancyList_0Request) OrderBy(orderBy string) ApiGetActiveVacancyList_0Request {
	r.orderBy = &orderBy
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetActiveVacancyList_0Request) Locale(locale string) ApiGetActiveVacancyList_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetActiveVacancyList_0Request) Host(host string) ApiGetActiveVacancyList_0Request {
	r.host = &host
	return r
}

func (r ApiGetActiveVacancyList_0Request) Execute() (*VacanciesVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetActiveVacancyList_5Execute(r)
}

/*
GetActiveVacancyList_0 Просмотр списка опубликованных вакансий

Возвращает список опубликованных вакансий.

Если передан параметр `resume_id`, то в список попадут только те вакансии, которые подходят для указанного резюме. Кроме того, ответ будет содержать дополнительные поля


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetActiveVacancyList_0Request
*/
func (a *DefaultApiService) GetActiveVacancyList_5(ctx context.Context, employerId string) ApiGetActiveVacancyList_0Request {
	return ApiGetActiveVacancyList_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyListResponse
func (a *DefaultApiService) GetActiveVacancyList_5Execute(r ApiGetActiveVacancyList_0Request) (*VacanciesVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetActiveVacancyList_5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/active"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 20
		r.perPage = &defaultValue
	}
	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.resumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resume_id", r.resumeId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddressRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	addressId string
	hHUserAgent *string
	withManager *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAddressRequest) HHUserAgent(hHUserAgent string) ApiGetAddressRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Если true, ответ будет содержать информацию о менеджере создавшем адрес
func (r ApiGetAddressRequest) WithManager(withManager bool) ApiGetAddressRequest {
	r.withManager = &withManager
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAddressRequest) Locale(locale string) ApiGetAddressRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAddressRequest) Host(host string) ApiGetAddressRequest {
	r.host = &host
	return r
}

func (r ApiGetAddressRequest) Execute() (*EmployerAddressesEmployerAddressItemResponse, *http.Response, error) {
	return r.ApiService.GetAddressExecute(r)
}

/*
GetAddress Получение адреса

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя. Чтобы получить его, используйте метод [Информация о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param addressId Идентификатор адреса работодателя
 @return ApiGetAddressRequest
*/
func (a *DefaultApiService) GetAddress(ctx context.Context, employerId string, addressId string) ApiGetAddressRequest {
	return ApiGetAddressRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return EmployerAddressesEmployerAddressItemResponse
func (a *DefaultApiService) GetAddressExecute(r ApiGetAddressRequest) (*EmployerAddressesEmployerAddressItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerAddressesEmployerAddressItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/addresses/{address_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address_id"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_manager", r.withManager, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddress_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	addressId string
	hHUserAgent *string
	withManager *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAddress_0Request) HHUserAgent(hHUserAgent string) ApiGetAddress_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Если true, ответ будет содержать информацию о менеджере создавшем адрес
func (r ApiGetAddress_0Request) WithManager(withManager bool) ApiGetAddress_0Request {
	r.withManager = &withManager
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAddress_0Request) Locale(locale string) ApiGetAddress_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAddress_0Request) Host(host string) ApiGetAddress_0Request {
	r.host = &host
	return r
}

func (r ApiGetAddress_0Request) Execute() (*EmployerAddressesEmployerAddressItemResponse, *http.Response, error) {
	return r.ApiService.GetAddress_6Execute(r)
}

/*
GetAddress_0 Получение адреса

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя. Чтобы получить его, используйте метод [Информация о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param addressId Идентификатор адреса работодателя
 @return ApiGetAddress_0Request
*/
func (a *DefaultApiService) GetAddress_6(ctx context.Context, employerId string, addressId string) ApiGetAddress_0Request {
	return ApiGetAddress_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return EmployerAddressesEmployerAddressItemResponse
func (a *DefaultApiService) GetAddress_6Execute(r ApiGetAddress_0Request) (*EmployerAddressesEmployerAddressItemResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerAddressesEmployerAddressItemResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAddress_6")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/addresses/{address_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address_id"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_manager", r.withManager, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllDistrictsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAllDistrictsRequest) HHUserAgent(hHUserAgent string) ApiGetAllDistrictsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAllDistrictsRequest) Locale(locale string) ApiGetAllDistrictsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAllDistrictsRequest) Host(host string) ApiGetAllDistrictsRequest {
	r.host = &host
	return r
}

func (r ApiGetAllDistrictsRequest) Execute() ([]DistrictsDistrictItem, *http.Response, error) {
	return r.ApiService.GetAllDistrictsExecute(r)
}

/*
GetAllDistricts Список районов во всех городах

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllDistrictsRequest
*/
func (a *DefaultApiService) GetAllDistricts(ctx context.Context) ApiGetAllDistrictsRequest {
	return ApiGetAllDistrictsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DistrictsDistrictItem
func (a *DefaultApiService) GetAllDistrictsExecute(r ApiGetAllDistrictsRequest) ([]DistrictsDistrictItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DistrictsDistrictItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllDistricts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/districts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicantCommentsListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicantId string
	hHUserAgent *string
	page *float32
	perPage *float32
	orderBy *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetApplicantCommentsListRequest) HHUserAgent(hHUserAgent string) ApiGetApplicantCommentsListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetApplicantCommentsListRequest) Page(page float32) ApiGetApplicantCommentsListRequest {
	r.page = &page
	return r
}

// Результатов на странице
func (r ApiGetApplicantCommentsListRequest) PerPage(perPage float32) ApiGetApplicantCommentsListRequest {
	r.perPage = &perPage
	return r
}

// Сортировка комментариев. Доступные значения перечислены [в справочнике](#tag/Obshie-spravochniki/operation/get-dictionaries) в поле &#x60;applicant_comments_order&#x60;
func (r ApiGetApplicantCommentsListRequest) OrderBy(orderBy string) ApiGetApplicantCommentsListRequest {
	r.orderBy = &orderBy
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetApplicantCommentsListRequest) Locale(locale string) ApiGetApplicantCommentsListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetApplicantCommentsListRequest) Host(host string) ApiGetApplicantCommentsListRequest {
	r.host = &host
	return r
}

func (r ApiGetApplicantCommentsListRequest) Execute() (*ApplicantCommentsApplicantCommentsList, *http.Response, error) {
	return r.ApiService.GetApplicantCommentsListExecute(r)
}

/*
GetApplicantCommentsList Получение списка комментариев

Метод требует наличия [платного доступа для работодателя](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).

Список будет содержать комментарии текущего пользователя, а также комментарии других менеджеров компании, если они открыли доступ к ним при публикации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicantId Идентификатор соискателя, который можно узнать из поля `owner` [в резюме](https://github.com/hhru/api/blob/master/docs/employer_resumes.md#owner-field)
 @return ApiGetApplicantCommentsListRequest
*/
func (a *DefaultApiService) GetApplicantCommentsList(ctx context.Context, applicantId string) ApiGetApplicantCommentsListRequest {
	return ApiGetApplicantCommentsListRequest{
		ApiService: a,
		ctx: ctx,
		applicantId: applicantId,
	}
}

// Execute executes the request
//  @return ApplicantCommentsApplicantCommentsList
func (a *DefaultApiService) GetApplicantCommentsListExecute(r ApiGetApplicantCommentsListRequest) (*ApplicantCommentsApplicantCommentsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplicantCommentsApplicantCommentsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplicantCommentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applicant_comments/{applicant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicant_id"+"}", url.PathEscape(parameterValueToString(r.applicantId, "applicantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicantPhoneInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	phone *string
	hHUserAgent *string
	locale *string
	host *string
}

// Номер телефона в любом формате
func (r ApiGetApplicantPhoneInfoRequest) Phone(phone string) ApiGetApplicantPhoneInfoRequest {
	r.phone = &phone
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetApplicantPhoneInfoRequest) HHUserAgent(hHUserAgent string) ApiGetApplicantPhoneInfoRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetApplicantPhoneInfoRequest) Locale(locale string) ApiGetApplicantPhoneInfoRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetApplicantPhoneInfoRequest) Host(host string) ApiGetApplicantPhoneInfoRequest {
	r.host = &host
	return r
}

func (r ApiGetApplicantPhoneInfoRequest) Execute() (*ResumeShouldSendSmsContainer, *http.Response, error) {
	return r.ApiService.GetApplicantPhoneInfoExecute(r)
}

/*
GetApplicantPhoneInfo Получить информацию о телефоне соискателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApplicantPhoneInfoRequest
*/
func (a *DefaultApiService) GetApplicantPhoneInfo(ctx context.Context) ApiGetApplicantPhoneInfoRequest {
	return ApiGetApplicantPhoneInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumeShouldSendSmsContainer
func (a *DefaultApiService) GetApplicantPhoneInfoExecute(r ApiGetApplicantPhoneInfoRequest) (*ResumeShouldSendSmsContainer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeShouldSendSmsContainer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetApplicantPhoneInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resume_should_send_sms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.phone == nil {
		return localVarReturnValue, nil, reportError("phone is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArchivedVacanciesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	managerId *string
	orderBy *string
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArchivedVacanciesRequest) HHUserAgent(hHUserAgent string) ApiGetArchivedVacanciesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор менеджера из [списка менеджеров работодателя](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers). Передайте, если требуется получить вакансии другого менеджера.   Если передать несколько параметров &#x60;manager_id&#x60;, будет использоваться только последний.  По умолчанию возвращаются вакансии текущего пользователя 
func (r ApiGetArchivedVacanciesRequest) ManagerId(managerId string) ApiGetArchivedVacanciesRequest {
	r.managerId = &managerId
	return r
}

// Сортировка списка вакансий в архиве. Справочник с возможными значениями: &#x60;employer_archived_vacancies_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetArchivedVacanciesRequest) OrderBy(orderBy string) ApiGetArchivedVacanciesRequest {
	r.orderBy = &orderBy
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение &#x60;per_page&#x60; составляет 1000 
func (r ApiGetArchivedVacanciesRequest) PerPage(perPage int32) ApiGetArchivedVacanciesRequest {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetArchivedVacanciesRequest) Page(page int32) ApiGetArchivedVacanciesRequest {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArchivedVacanciesRequest) Locale(locale string) ApiGetArchivedVacanciesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArchivedVacanciesRequest) Host(host string) ApiGetArchivedVacanciesRequest {
	r.host = &host
	return r
}

func (r ApiGetArchivedVacanciesRequest) Execute() (*VacanciesArchivedVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetArchivedVacanciesExecute(r)
}

/*
GetArchivedVacancies Список архивных вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetArchivedVacanciesRequest
*/
func (a *DefaultApiService) GetArchivedVacancies(ctx context.Context, employerId string) ApiGetArchivedVacanciesRequest {
	return ApiGetArchivedVacanciesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesArchivedVacancyListResponse
func (a *DefaultApiService) GetArchivedVacanciesExecute(r ApiGetArchivedVacanciesRequest) (*VacanciesArchivedVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesArchivedVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArchivedVacancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/archived"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArchivedVacancies_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	managerId *string
	orderBy *string
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArchivedVacancies_0Request) HHUserAgent(hHUserAgent string) ApiGetArchivedVacancies_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор менеджера из [списка менеджеров работодателя](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers). Передайте, если требуется получить вакансии другого менеджера.   Если передать несколько параметров &#x60;manager_id&#x60;, будет использоваться только последний.  По умолчанию возвращаются вакансии текущего пользователя 
func (r ApiGetArchivedVacancies_0Request) ManagerId(managerId string) ApiGetArchivedVacancies_0Request {
	r.managerId = &managerId
	return r
}

// Сортировка списка вакансий в архиве. Справочник с возможными значениями: &#x60;employer_archived_vacancies_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetArchivedVacancies_0Request) OrderBy(orderBy string) ApiGetArchivedVacancies_0Request {
	r.orderBy = &orderBy
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение &#x60;per_page&#x60; составляет 1000 
func (r ApiGetArchivedVacancies_0Request) PerPage(perPage int32) ApiGetArchivedVacancies_0Request {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetArchivedVacancies_0Request) Page(page int32) ApiGetArchivedVacancies_0Request {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArchivedVacancies_0Request) Locale(locale string) ApiGetArchivedVacancies_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArchivedVacancies_0Request) Host(host string) ApiGetArchivedVacancies_0Request {
	r.host = &host
	return r
}

func (r ApiGetArchivedVacancies_0Request) Execute() (*VacanciesArchivedVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetArchivedVacancies_7Execute(r)
}

/*
GetArchivedVacancies_0 Список архивных вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetArchivedVacancies_0Request
*/
func (a *DefaultApiService) GetArchivedVacancies_7(ctx context.Context, employerId string) ApiGetArchivedVacancies_0Request {
	return ApiGetArchivedVacancies_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesArchivedVacancyListResponse
func (a *DefaultApiService) GetArchivedVacancies_7Execute(r ApiGetArchivedVacancies_0Request) (*VacanciesArchivedVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesArchivedVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArchivedVacancies_7")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/archived"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAreaLeavesSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	areaId *string
	locale *string
	host *string
}

// Текст для поиска региона. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetAreaLeavesSuggestsRequest) Text(text string) ApiGetAreaLeavesSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAreaLeavesSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetAreaLeavesSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор региона из [справочника](#tag/Obshie-spravochniki/operation/get-areas). Сужает подсказки поддеревом переданного идентификатора региона
func (r ApiGetAreaLeavesSuggestsRequest) AreaId(areaId string) ApiGetAreaLeavesSuggestsRequest {
	r.areaId = &areaId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAreaLeavesSuggestsRequest) Locale(locale string) ApiGetAreaLeavesSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAreaLeavesSuggestsRequest) Host(host string) ApiGetAreaLeavesSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetAreaLeavesSuggestsRequest) Execute() (*SuggestsAreas, *http.Response, error) {
	return r.ApiService.GetAreaLeavesSuggestsExecute(r)
}

/*
GetAreaLeavesSuggests Подсказки по регионам, являющимися листами в дереве регионов

Также доступна загрузка [полного дерева регионов](#tag/Obshie-spravochniki/operation/get-areas) и [части дерева от определенного элемента](#tag/Obshie-spravochniki/operation/get-areas-from-specified)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAreaLeavesSuggestsRequest
*/
func (a *DefaultApiService) GetAreaLeavesSuggests(ctx context.Context) ApiGetAreaLeavesSuggestsRequest {
	return ApiGetAreaLeavesSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsAreas
func (a *DefaultApiService) GetAreaLeavesSuggestsExecute(r ApiGetAreaLeavesSuggestsRequest) (*SuggestsAreas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsAreas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAreaLeavesSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/area_leaves"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area_id", r.areaId, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAreasRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	additionalCase *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAreasRequest) HHUserAgent(hHUserAgent string) ApiGetAreasRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Применимо только к русской локализации.  В дополнительном поле вернется название региона в указанном падеже. Поддерживается только значение &#x60;prepositional&#x60; — предложный падеж 
func (r ApiGetAreasRequest) AdditionalCase(additionalCase string) ApiGetAreasRequest {
	r.additionalCase = &additionalCase
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAreasRequest) Locale(locale string) ApiGetAreasRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAreasRequest) Host(host string) ApiGetAreasRequest {
	r.host = &host
	return r
}

func (r ApiGetAreasRequest) Execute() ([]DictionariesAreaItem, *http.Response, error) {
	return r.ApiService.GetAreasExecute(r)
}

/*
GetAreas Дерево всех регионов

Возвращает древовидный список всех регионов.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAreasRequest
*/
func (a *DefaultApiService) GetAreas(ctx context.Context) ApiGetAreasRequest {
	return ApiGetAreasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesAreaItem
func (a *DefaultApiService) GetAreasExecute(r ApiGetAreasRequest) ([]DictionariesAreaItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesAreaItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.additionalCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_case", r.additionalCase, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsDictionariesBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAreasFromSpecifiedRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	areaId string
	hHUserAgent *string
	additionalCase *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAreasFromSpecifiedRequest) HHUserAgent(hHUserAgent string) ApiGetAreasFromSpecifiedRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Применимо только к русской локализации.  В дополнительном поле вернется название региона в указанном падеже. Поддерживается только значение &#x60;prepositional&#x60; — предложный падеж 
func (r ApiGetAreasFromSpecifiedRequest) AdditionalCase(additionalCase string) ApiGetAreasFromSpecifiedRequest {
	r.additionalCase = &additionalCase
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAreasFromSpecifiedRequest) Locale(locale string) ApiGetAreasFromSpecifiedRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAreasFromSpecifiedRequest) Host(host string) ApiGetAreasFromSpecifiedRequest {
	r.host = &host
	return r
}

func (r ApiGetAreasFromSpecifiedRequest) Execute() (*DictionariesAreaItem, *http.Response, error) {
	return r.ApiService.GetAreasFromSpecifiedExecute(r)
}

/*
GetAreasFromSpecified Справочник регионов, начиная с указанного

Возвращает древовидный список регионов, начиная с указанного.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param areaId Идентификатор региона из справочника [/areas](#tag/Obshie-spravochniki/operation/get-areas)
 @return ApiGetAreasFromSpecifiedRequest
*/
func (a *DefaultApiService) GetAreasFromSpecified(ctx context.Context, areaId string) ApiGetAreasFromSpecifiedRequest {
	return ApiGetAreasFromSpecifiedRequest{
		ApiService: a,
		ctx: ctx,
		areaId: areaId,
	}
}

// Execute executes the request
//  @return DictionariesAreaItem
func (a *DefaultApiService) GetAreasFromSpecifiedExecute(r ApiGetAreasFromSpecifiedRequest) (*DictionariesAreaItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DictionariesAreaItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAreasFromSpecified")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/areas/{area_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"area_id"+"}", url.PathEscape(parameterValueToString(r.areaId, "areaId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.additionalCase != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_case", r.additionalCase, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsDictionariesBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAreasSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	areaId *string
	includeParent *bool
	locale *string
	host *string
}

// Текст для поиска региона. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetAreasSuggestsRequest) Text(text string) ApiGetAreasSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAreasSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetAreasSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор региона из [справочника](#tag/Obshie-spravochniki/operation/get-areas). Сужает подсказки поддеревом переданного идентификатора региона
func (r ApiGetAreasSuggestsRequest) AreaId(areaId string) ApiGetAreasSuggestsRequest {
	r.areaId = &areaId
	return r
}

// Включать ли в ответ регион, переданный в параметре &#x60;area_id&#x60;, если он подходит по искомому тексту
func (r ApiGetAreasSuggestsRequest) IncludeParent(includeParent bool) ApiGetAreasSuggestsRequest {
	r.includeParent = &includeParent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAreasSuggestsRequest) Locale(locale string) ApiGetAreasSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAreasSuggestsRequest) Host(host string) ApiGetAreasSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetAreasSuggestsRequest) Execute() (*SuggestsAreas, *http.Response, error) {
	return r.ApiService.GetAreasSuggestsExecute(r)
}

/*
GetAreasSuggests Подсказки по регионам

Также доступна загрузка [полного дерева регионов](#tag/Obshie-spravochniki/operation/get-areas) и [части дерева от определенного элемента](#tag/Obshie-spravochniki/operation/get-areas-from-specified)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAreasSuggestsRequest
*/
func (a *DefaultApiService) GetAreasSuggests(ctx context.Context) ApiGetAreasSuggestsRequest {
	return ApiGetAreasSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsAreas
func (a *DefaultApiService) GetAreasSuggestsExecute(r ApiGetAreasSuggestsRequest) (*SuggestsAreas, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsAreas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAreasSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.areaId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area_id", r.areaId, "")
	}
	if r.includeParent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_parent", r.includeParent, "")
	} else {
		var defaultValue bool = false
		r.includeParent = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactPhotosRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArtifactPhotosRequest) HHUserAgent(hHUserAgent string) ApiGetArtifactPhotosRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArtifactPhotosRequest) Locale(locale string) ApiGetArtifactPhotosRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArtifactPhotosRequest) Host(host string) ApiGetArtifactPhotosRequest {
	r.host = &host
	return r
}

func (r ApiGetArtifactPhotosRequest) Execute() (*ArtifactsArtifactPhotoResponse, *http.Response, error) {
	return r.ApiService.GetArtifactPhotosExecute(r)
}

/*
GetArtifactPhotos Получение фотографий

Возвращает список ранее загруженных изображений с фотографиями. Их можно использовать при создании/редактировании резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArtifactPhotosRequest
*/
func (a *DefaultApiService) GetArtifactPhotos(ctx context.Context) ApiGetArtifactPhotosRequest {
	return ApiGetArtifactPhotosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArtifactsArtifactPhotoResponse
func (a *DefaultApiService) GetArtifactPhotosExecute(r ApiGetArtifactPhotosRequest) (*ArtifactsArtifactPhotoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactsArtifactPhotoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArtifactPhotos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/photo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactPhotosConditionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArtifactPhotosConditionsRequest) HHUserAgent(hHUserAgent string) ApiGetArtifactPhotosConditionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArtifactPhotosConditionsRequest) Locale(locale string) ApiGetArtifactPhotosConditionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArtifactPhotosConditionsRequest) Host(host string) ApiGetArtifactPhotosConditionsRequest {
	r.host = &host
	return r
}

func (r ApiGetArtifactPhotosConditionsRequest) Execute() (*ArtifactsArtifactConditions, *http.Response, error) {
	return r.ApiService.GetArtifactPhotosConditionsExecute(r)
}

/*
GetArtifactPhotosConditions Условия загрузки фотографий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArtifactPhotosConditionsRequest
*/
func (a *DefaultApiService) GetArtifactPhotosConditions(ctx context.Context) ApiGetArtifactPhotosConditionsRequest {
	return ApiGetArtifactPhotosConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArtifactsArtifactConditions
func (a *DefaultApiService) GetArtifactPhotosConditionsExecute(r ApiGetArtifactPhotosConditionsRequest) (*ArtifactsArtifactConditions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactsArtifactConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArtifactPhotosConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/photo/conditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactsPortfolioRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArtifactsPortfolioRequest) HHUserAgent(hHUserAgent string) ApiGetArtifactsPortfolioRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArtifactsPortfolioRequest) Locale(locale string) ApiGetArtifactsPortfolioRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArtifactsPortfolioRequest) Host(host string) ApiGetArtifactsPortfolioRequest {
	r.host = &host
	return r
}

func (r ApiGetArtifactsPortfolioRequest) Execute() (*ArtifactsArtifactPortfolioResponse, *http.Response, error) {
	return r.ApiService.GetArtifactsPortfolioExecute(r)
}

/*
GetArtifactsPortfolio Получение портфолио

Возвращает список ранее загруженных изображений с портфолио. Их можно использовать при создании/редактировании резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArtifactsPortfolioRequest
*/
func (a *DefaultApiService) GetArtifactsPortfolio(ctx context.Context) ApiGetArtifactsPortfolioRequest {
	return ApiGetArtifactsPortfolioRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArtifactsArtifactPortfolioResponse
func (a *DefaultApiService) GetArtifactsPortfolioExecute(r ApiGetArtifactsPortfolioRequest) (*ArtifactsArtifactPortfolioResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactsArtifactPortfolioResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArtifactsPortfolio")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/portfolio"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactsPortfolioConditionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetArtifactsPortfolioConditionsRequest) HHUserAgent(hHUserAgent string) ApiGetArtifactsPortfolioConditionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetArtifactsPortfolioConditionsRequest) Locale(locale string) ApiGetArtifactsPortfolioConditionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetArtifactsPortfolioConditionsRequest) Host(host string) ApiGetArtifactsPortfolioConditionsRequest {
	r.host = &host
	return r
}

func (r ApiGetArtifactsPortfolioConditionsRequest) Execute() (*ArtifactsArtifactConditions, *http.Response, error) {
	return r.ApiService.GetArtifactsPortfolioConditionsExecute(r)
}

/*
GetArtifactsPortfolioConditions Условия загрузки портфолио

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetArtifactsPortfolioConditionsRequest
*/
func (a *DefaultApiService) GetArtifactsPortfolioConditions(ctx context.Context) ApiGetArtifactsPortfolioConditionsRequest {
	return ApiGetArtifactsPortfolioConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArtifactsArtifactConditions
func (a *DefaultApiService) GetArtifactsPortfolioConditionsExecute(r ApiGetArtifactsPortfolioConditionsRequest) (*ArtifactsArtifactConditions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactsArtifactConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetArtifactsPortfolioConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts/portfolio/conditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAvailableVacancyTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetAvailableVacancyTypesRequest) HHUserAgent(hHUserAgent string) ApiGetAvailableVacancyTypesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetAvailableVacancyTypesRequest) Locale(locale string) ApiGetAvailableVacancyTypesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetAvailableVacancyTypesRequest) Host(host string) ApiGetAvailableVacancyTypesRequest {
	r.host = &host
	return r
}

func (r ApiGetAvailableVacancyTypesRequest) Execute() (*VacanciesAvailableVacancyTypeResponse, *http.Response, error) {
	return r.ApiService.GetAvailableVacancyTypesExecute(r)
}

/*
GetAvailableVacancyTypes Варианты публикации вакансий у текущего менеджера

Метод позволяет понять, может ли менеджер публиковать вакансии и какие типы вакансий ему доступны. Возвращает все возможные типы публикации

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetAvailableVacancyTypesRequest
*/
func (a *DefaultApiService) GetAvailableVacancyTypes(ctx context.Context, employerId string, managerId string) ApiGetAvailableVacancyTypesRequest {
	return ApiGetAvailableVacancyTypesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return VacanciesAvailableVacancyTypeResponse
func (a *DefaultApiService) GetAvailableVacancyTypesExecute(r ApiGetAvailableVacancyTypesRequest) (*VacanciesAvailableVacancyTypeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesAvailableVacancyTypeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAvailableVacancyTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}/vacancies/available_types"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlacklistedEmployersRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetBlacklistedEmployersRequest) HHUserAgent(hHUserAgent string) ApiGetBlacklistedEmployersRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetBlacklistedEmployersRequest) Locale(locale string) ApiGetBlacklistedEmployersRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetBlacklistedEmployersRequest) Host(host string) ApiGetBlacklistedEmployersRequest {
	r.host = &host
	return r
}

func (r ApiGetBlacklistedEmployersRequest) Execute() (*EmployersEmployersBlacklistedResponse, *http.Response, error) {
	return r.ApiService.GetBlacklistedEmployersExecute(r)
}

/*
GetBlacklistedEmployers Список скрытых работодателей

Возвращает [подмножество работодателей](#tag/Rabotodatel/operation/search-employer), скрытых пользователем, а также один дополнительный параметр

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlacklistedEmployersRequest
*/
func (a *DefaultApiService) GetBlacklistedEmployers(ctx context.Context) ApiGetBlacklistedEmployersRequest {
	return ApiGetBlacklistedEmployersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmployersEmployersBlacklistedResponse
func (a *DefaultApiService) GetBlacklistedEmployersExecute(r ApiGetBlacklistedEmployersRequest) (*EmployersEmployersBlacklistedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployersBlacklistedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBlacklistedEmployers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/blacklisted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlacklistedVacanciesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetBlacklistedVacanciesRequest) HHUserAgent(hHUserAgent string) ApiGetBlacklistedVacanciesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetBlacklistedVacanciesRequest) Locale(locale string) ApiGetBlacklistedVacanciesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetBlacklistedVacanciesRequest) Host(host string) ApiGetBlacklistedVacanciesRequest {
	r.host = &host
	return r
}

func (r ApiGetBlacklistedVacanciesRequest) Execute() (*VacanciesVacanciesBlacklistedResponse, *http.Response, error) {
	return r.ApiService.GetBlacklistedVacanciesExecute(r)
}

/*
GetBlacklistedVacancies Список скрытых вакансий

Возвращает [подмножество вакансий](#tag/Vakansii/operation/get-vacancy), скрытых пользователем, а также один дополнительный параметр

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlacklistedVacanciesRequest
*/
func (a *DefaultApiService) GetBlacklistedVacancies(ctx context.Context) ApiGetBlacklistedVacanciesRequest {
	return ApiGetBlacklistedVacanciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacanciesVacanciesBlacklistedResponse
func (a *DefaultApiService) GetBlacklistedVacanciesExecute(r ApiGetBlacklistedVacanciesRequest) (*VacanciesVacanciesBlacklistedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacanciesBlacklistedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetBlacklistedVacancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/blacklisted"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCountriesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCountriesRequest) HHUserAgent(hHUserAgent string) ApiGetCountriesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCountriesRequest) Locale(locale string) ApiGetCountriesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCountriesRequest) Host(host string) ApiGetCountriesRequest {
	r.host = &host
	return r
}

func (r ApiGetCountriesRequest) Execute() ([]IncludesArea, *http.Response, error) {
	return r.ApiService.GetCountriesExecute(r)
}

/*
GetCountries Справочник стран

Возвращает подмножество регионов, являющихся странами

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCountriesRequest
*/
func (a *DefaultApiService) GetCountries(ctx context.Context) ApiGetCountriesRequest {
	return ApiGetCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IncludesArea
func (a *DefaultApiService) GetCountriesExecute(r ApiGetCountriesRequest) ([]IncludesArea, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IncludesArea
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/areas/countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentUserInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCurrentUserInfoRequest) HHUserAgent(hHUserAgent string) ApiGetCurrentUserInfoRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCurrentUserInfoRequest) Locale(locale string) ApiGetCurrentUserInfoRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCurrentUserInfoRequest) Host(host string) ApiGetCurrentUserInfoRequest {
	r.host = &host
	return r
}

func (r ApiGetCurrentUserInfoRequest) Execute() (*MeProfile, *http.Response, error) {
	return r.ApiService.GetCurrentUserInfoExecute(r)
}

/*
GetCurrentUserInfo Информация о текущем пользователе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentUserInfoRequest
*/
func (a *DefaultApiService) GetCurrentUserInfo(ctx context.Context) ApiGetCurrentUserInfoRequest {
	return ApiGetCurrentUserInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MeProfile
func (a *DefaultApiService) GetCurrentUserInfoExecute(r ApiGetCurrentUserInfoRequest) (*MeProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCurrentUserInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentUserInfo_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCurrentUserInfo_0Request) HHUserAgent(hHUserAgent string) ApiGetCurrentUserInfo_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCurrentUserInfo_0Request) Locale(locale string) ApiGetCurrentUserInfo_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCurrentUserInfo_0Request) Host(host string) ApiGetCurrentUserInfo_0Request {
	r.host = &host
	return r
}

func (r ApiGetCurrentUserInfo_0Request) Execute() (*MeProfile, *http.Response, error) {
	return r.ApiService.GetCurrentUserInfo_8Execute(r)
}

/*
GetCurrentUserInfo_0 Информация о текущем пользователе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentUserInfo_0Request
*/
func (a *DefaultApiService) GetCurrentUserInfo_8(ctx context.Context) ApiGetCurrentUserInfo_0Request {
	return ApiGetCurrentUserInfo_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MeProfile
func (a *DefaultApiService) GetCurrentUserInfo_8Execute(r ApiGetCurrentUserInfo_0Request) (*MeProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCurrentUserInfo_8")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentUserInfo_1Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCurrentUserInfo_1Request) HHUserAgent(hHUserAgent string) ApiGetCurrentUserInfo_1Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCurrentUserInfo_1Request) Locale(locale string) ApiGetCurrentUserInfo_1Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCurrentUserInfo_1Request) Host(host string) ApiGetCurrentUserInfo_1Request {
	r.host = &host
	return r
}

func (r ApiGetCurrentUserInfo_1Request) Execute() (*MeProfile, *http.Response, error) {
	return r.ApiService.GetCurrentUserInfo_9Execute(r)
}

/*
GetCurrentUserInfo_1 Информация о текущем пользователе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentUserInfo_1Request
*/
func (a *DefaultApiService) GetCurrentUserInfo_9(ctx context.Context) ApiGetCurrentUserInfo_1Request {
	return ApiGetCurrentUserInfo_1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MeProfile
func (a *DefaultApiService) GetCurrentUserInfo_9Execute(r ApiGetCurrentUserInfo_1Request) (*MeProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCurrentUserInfo_9")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentUserInfo_2Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCurrentUserInfo_2Request) HHUserAgent(hHUserAgent string) ApiGetCurrentUserInfo_2Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCurrentUserInfo_2Request) Locale(locale string) ApiGetCurrentUserInfo_2Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCurrentUserInfo_2Request) Host(host string) ApiGetCurrentUserInfo_2Request {
	r.host = &host
	return r
}

func (r ApiGetCurrentUserInfo_2Request) Execute() (*MeProfile, *http.Response, error) {
	return r.ApiService.GetCurrentUserInfo_10Execute(r)
}

/*
GetCurrentUserInfo_2 Информация о текущем пользователе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentUserInfo_2Request
*/
func (a *DefaultApiService) GetCurrentUserInfo_10(ctx context.Context) ApiGetCurrentUserInfo_2Request {
	return ApiGetCurrentUserInfo_2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MeProfile
func (a *DefaultApiService) GetCurrentUserInfo_10Execute(r ApiGetCurrentUserInfo_2Request) (*MeProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCurrentUserInfo_10")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentUserInfo_3Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetCurrentUserInfo_3Request) HHUserAgent(hHUserAgent string) ApiGetCurrentUserInfo_3Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetCurrentUserInfo_3Request) Locale(locale string) ApiGetCurrentUserInfo_3Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetCurrentUserInfo_3Request) Host(host string) ApiGetCurrentUserInfo_3Request {
	r.host = &host
	return r
}

func (r ApiGetCurrentUserInfo_3Request) Execute() (*MeProfile, *http.Response, error) {
	return r.ApiService.GetCurrentUserInfo_11Execute(r)
}

/*
GetCurrentUserInfo_3 Информация о текущем пользователе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCurrentUserInfo_3Request
*/
func (a *DefaultApiService) GetCurrentUserInfo_11(ctx context.Context) ApiGetCurrentUserInfo_3Request {
	return ApiGetCurrentUserInfo_3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MeProfile
func (a *DefaultApiService) GetCurrentUserInfo_11Execute(r ApiGetCurrentUserInfo_3Request) (*MeProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MeProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetCurrentUserInfo_11")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDictionariesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetDictionariesRequest) HHUserAgent(hHUserAgent string) ApiGetDictionariesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetDictionariesRequest) Locale(locale string) ApiGetDictionariesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetDictionariesRequest) Host(host string) ApiGetDictionariesRequest {
	r.host = &host
	return r
}

func (r ApiGetDictionariesRequest) Execute() (*DictionariesDictResponse, *http.Response, error) {
	return r.ApiService.GetDictionariesExecute(r)
}

/*
GetDictionaries Справочники полей

Справочники полей и сущностей, используемых в API. Значения в справочниках могут поменяться в любой момент

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDictionariesRequest
*/
func (a *DefaultApiService) GetDictionaries(ctx context.Context) ApiGetDictionariesRequest {
	return ApiGetDictionariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DictionariesDictResponse
func (a *DefaultApiService) GetDictionariesExecute(r ApiGetDictionariesRequest) (*DictionariesDictResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DictionariesDictResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDictionaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dictionaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEducationalInstitutionsDictionaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id *string
	hHUserAgent *string
	locale *string
	host *string
}

// Идентификаторы учебных заведений. Идентификатор конкретного заведения можно узнать в [подсказке](#tag/Podskazki/operation/get-educational-institutions-suggests). Передать можно не более 50 значений. Например: &#x60;?id&#x3D;39196&amp;id&#x3D;45470&amp;id&#x3D;0&#x60;. Если был передан идентификатор несуществующего заведения, для него не вернется никакой информации
func (r ApiGetEducationalInstitutionsDictionaryRequest) Id(id string) ApiGetEducationalInstitutionsDictionaryRequest {
	r.id = &id
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEducationalInstitutionsDictionaryRequest) HHUserAgent(hHUserAgent string) ApiGetEducationalInstitutionsDictionaryRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEducationalInstitutionsDictionaryRequest) Locale(locale string) ApiGetEducationalInstitutionsDictionaryRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEducationalInstitutionsDictionaryRequest) Host(host string) ApiGetEducationalInstitutionsDictionaryRequest {
	r.host = &host
	return r
}

func (r ApiGetEducationalInstitutionsDictionaryRequest) Execute() (*SuggestsEducationalInstitutions, *http.Response, error) {
	return r.ApiService.GetEducationalInstitutionsDictionaryExecute(r)
}

/*
GetEducationalInstitutionsDictionary Основная информация об учебных заведениях

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEducationalInstitutionsDictionaryRequest
*/
func (a *DefaultApiService) GetEducationalInstitutionsDictionary(ctx context.Context) ApiGetEducationalInstitutionsDictionaryRequest {
	return ApiGetEducationalInstitutionsDictionaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsEducationalInstitutions
func (a *DefaultApiService) GetEducationalInstitutionsDictionaryExecute(r ApiGetEducationalInstitutionsDictionaryRequest) (*SuggestsEducationalInstitutions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsEducationalInstitutions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEducationalInstitutionsDictionary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/educational_institutions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEducationalInstitutionsSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска учебного заведения. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetEducationalInstitutionsSuggestsRequest) Text(text string) ApiGetEducationalInstitutionsSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEducationalInstitutionsSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetEducationalInstitutionsSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEducationalInstitutionsSuggestsRequest) Locale(locale string) ApiGetEducationalInstitutionsSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEducationalInstitutionsSuggestsRequest) Host(host string) ApiGetEducationalInstitutionsSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetEducationalInstitutionsSuggestsRequest) Execute() (*SuggestsEducationalInstitutions, *http.Response, error) {
	return r.ApiService.GetEducationalInstitutionsSuggestsExecute(r)
}

/*
GetEducationalInstitutionsSuggests Подсказки по названиям учебных заведений

Чтобы узнать список факультетов, обратитесь к [соответствующему методу](#tag/Obshie-spravochniki/operation/get-educational-institutions-dictionary)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEducationalInstitutionsSuggestsRequest
*/
func (a *DefaultApiService) GetEducationalInstitutionsSuggests(ctx context.Context) ApiGetEducationalInstitutionsSuggestsRequest {
	return ApiGetEducationalInstitutionsSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsEducationalInstitutions
func (a *DefaultApiService) GetEducationalInstitutionsSuggestsExecute(r ApiGetEducationalInstitutionsSuggestsRequest) (*SuggestsEducationalInstitutions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsEducationalInstitutions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEducationalInstitutionsSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/educational_institutions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerAddressesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	changedAfter *string
	managerId *string
	withManager *bool
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerAddressesRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerAddressesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Позволяет загрузить все адреса, изменённые после этой даты (добавление, удаление или изменение адреса). Изменения возвращаются без пагинации. Значение указывается в формате [ISO 8601](#date-format) - &#x60;YYYY-MM-DDThh:mm:ss&#x60; или c указанием отступа для часового пояса &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Максимальное значение отступа от текущей даты - 7 дней. При передаче этого параметра, для каждого адреса в теле ответа возвращается поле &#x60;deleted&#x60;, указывающее на то, удалён ли адрес. Также, в случае передачи этого параметра, игнорируются все остальные
func (r ApiGetEmployerAddressesRequest) ChangedAfter(changedAfter string) ApiGetEmployerAddressesRequest {
	r.changedAfter = &changedAfter
	return r
}

// Идентификатор менеджера создавшего адрес
func (r ApiGetEmployerAddressesRequest) ManagerId(managerId string) ApiGetEmployerAddressesRequest {
	r.managerId = &managerId
	return r
}

// Если true, ответ будет содержать информацию о менеджере создавшем адрес
func (r ApiGetEmployerAddressesRequest) WithManager(withManager bool) ApiGetEmployerAddressesRequest {
	r.withManager = &withManager
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение per_page составляет 10000 
func (r ApiGetEmployerAddressesRequest) PerPage(perPage int32) ApiGetEmployerAddressesRequest {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetEmployerAddressesRequest) Page(page int32) ApiGetEmployerAddressesRequest {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerAddressesRequest) Locale(locale string) ApiGetEmployerAddressesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerAddressesRequest) Host(host string) ApiGetEmployerAddressesRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerAddressesRequest) Execute() (*EmployerAddressesEmployerAddressesResponse, *http.Response, error) {
	return r.ApiService.GetEmployerAddressesExecute(r)
}

/*
GetEmployerAddresses Список адресов работодателя

Возвращает список адресов работодателя. Для компаний с большим количеством адресов, возможна ситуация, когда между созданием адреса и его чтением будет задержка. То есть, только что созданный адрес не будет содержаться в теле ответа

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetEmployerAddressesRequest
*/
func (a *DefaultApiService) GetEmployerAddresses(ctx context.Context, employerId string) ApiGetEmployerAddressesRequest {
	return ApiGetEmployerAddressesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerAddressesEmployerAddressesResponse
func (a *DefaultApiService) GetEmployerAddressesExecute(r ApiGetEmployerAddressesRequest) (*EmployerAddressesEmployerAddressesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerAddressesEmployerAddressesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/addresses"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.changedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changed_after", r.changedAfter, "")
	}
	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.withManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_manager", r.withManager, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerAddressErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerAddresses_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	changedAfter *string
	managerId *string
	withManager *bool
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerAddresses_0Request) HHUserAgent(hHUserAgent string) ApiGetEmployerAddresses_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Позволяет загрузить все адреса, изменённые после этой даты (добавление, удаление или изменение адреса). Изменения возвращаются без пагинации. Значение указывается в формате [ISO 8601](#date-format) - &#x60;YYYY-MM-DDThh:mm:ss&#x60; или c указанием отступа для часового пояса &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Максимальное значение отступа от текущей даты - 7 дней. При передаче этого параметра, для каждого адреса в теле ответа возвращается поле &#x60;deleted&#x60;, указывающее на то, удалён ли адрес. Также, в случае передачи этого параметра, игнорируются все остальные
func (r ApiGetEmployerAddresses_0Request) ChangedAfter(changedAfter string) ApiGetEmployerAddresses_0Request {
	r.changedAfter = &changedAfter
	return r
}

// Идентификатор менеджера создавшего адрес
func (r ApiGetEmployerAddresses_0Request) ManagerId(managerId string) ApiGetEmployerAddresses_0Request {
	r.managerId = &managerId
	return r
}

// Если true, ответ будет содержать информацию о менеджере создавшем адрес
func (r ApiGetEmployerAddresses_0Request) WithManager(withManager bool) ApiGetEmployerAddresses_0Request {
	r.withManager = &withManager
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение per_page составляет 10000 
func (r ApiGetEmployerAddresses_0Request) PerPage(perPage int32) ApiGetEmployerAddresses_0Request {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetEmployerAddresses_0Request) Page(page int32) ApiGetEmployerAddresses_0Request {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerAddresses_0Request) Locale(locale string) ApiGetEmployerAddresses_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerAddresses_0Request) Host(host string) ApiGetEmployerAddresses_0Request {
	r.host = &host
	return r
}

func (r ApiGetEmployerAddresses_0Request) Execute() (*EmployerAddressesEmployerAddressesResponse, *http.Response, error) {
	return r.ApiService.GetEmployerAddresses_12Execute(r)
}

/*
GetEmployerAddresses_0 Список адресов работодателя

Возвращает список адресов работодателя. Для компаний с большим количеством адресов, возможна ситуация, когда между созданием адреса и его чтением будет задержка. То есть, только что созданный адрес не будет содержаться в теле ответа

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetEmployerAddresses_0Request
*/
func (a *DefaultApiService) GetEmployerAddresses_12(ctx context.Context, employerId string) ApiGetEmployerAddresses_0Request {
	return ApiGetEmployerAddresses_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerAddressesEmployerAddressesResponse
func (a *DefaultApiService) GetEmployerAddresses_12Execute(r ApiGetEmployerAddresses_0Request) (*EmployerAddressesEmployerAddressesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerAddressesEmployerAddressesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerAddresses_12")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/addresses"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.changedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "changed_after", r.changedAfter, "")
	}
	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.withManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_manager", r.withManager, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsEmployerAddressErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerDepartmentsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerDepartmentsRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerDepartmentsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerDepartmentsRequest) Locale(locale string) ApiGetEmployerDepartmentsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerDepartmentsRequest) Host(host string) ApiGetEmployerDepartmentsRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerDepartmentsRequest) Execute() (*EmployersEmployerDepartmentsResponse, *http.Response, error) {
	return r.ApiService.GetEmployerDepartmentsExecute(r)
}

/*
GetEmployerDepartments Справочник департаментов работодателя

Возвращает список департаментов работодателя.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно получить в [списке работодателей](#tag/Rabotodatel/operation/search-employer)
 @return ApiGetEmployerDepartmentsRequest
*/
func (a *DefaultApiService) GetEmployerDepartments(ctx context.Context, employerId string) ApiGetEmployerDepartmentsRequest {
	return ApiGetEmployerDepartmentsRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersEmployerDepartmentsResponse
func (a *DefaultApiService) GetEmployerDepartmentsExecute(r ApiGetEmployerDepartmentsRequest) (*EmployersEmployerDepartmentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployerDepartmentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerDepartments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/departments"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerDepartments_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerDepartments_0Request) HHUserAgent(hHUserAgent string) ApiGetEmployerDepartments_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerDepartments_0Request) Locale(locale string) ApiGetEmployerDepartments_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerDepartments_0Request) Host(host string) ApiGetEmployerDepartments_0Request {
	r.host = &host
	return r
}

func (r ApiGetEmployerDepartments_0Request) Execute() (*EmployersEmployerDepartmentsResponse, *http.Response, error) {
	return r.ApiService.GetEmployerDepartments_13Execute(r)
}

/*
GetEmployerDepartments_0 Справочник департаментов работодателя

Возвращает список департаментов работодателя.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно получить в [списке работодателей](#tag/Rabotodatel/operation/search-employer)
 @return ApiGetEmployerDepartments_0Request
*/
func (a *DefaultApiService) GetEmployerDepartments_13(ctx context.Context, employerId string) ApiGetEmployerDepartments_0Request {
	return ApiGetEmployerDepartments_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersEmployerDepartmentsResponse
func (a *DefaultApiService) GetEmployerDepartments_13Execute(r ApiGetEmployerDepartments_0Request) (*EmployersEmployerDepartmentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployerDepartmentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerDepartments_13")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/departments"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerInfoRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerInfoRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerInfoRequest) Locale(locale string) ApiGetEmployerInfoRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerInfoRequest) Host(host string) ApiGetEmployerInfoRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerInfoRequest) Execute() (*EmployersEmployerInfo, *http.Response, error) {
	return r.ApiService.GetEmployerInfoExecute(r)
}

/*
GetEmployerInfo Информация о работодателе

Возвращает данные о работодателе со ссылкой на выдачу вакансий этого работодателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно получить в [списке работодателей](#tag/Rabotodatel/operation/search-employer)
 @return ApiGetEmployerInfoRequest
*/
func (a *DefaultApiService) GetEmployerInfo(ctx context.Context, employerId string) ApiGetEmployerInfoRequest {
	return ApiGetEmployerInfoRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersEmployerInfo
func (a *DefaultApiService) GetEmployerInfoExecute(r ApiGetEmployerInfoRequest) (*EmployersEmployerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagerRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerManagerRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagerRequest) Locale(locale string) ApiGetEmployerManagerRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagerRequest) Host(host string) ApiGetEmployerManagerRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagerRequest) Execute() (*EmployerManagersEmployerManagerInfo, *http.Response, error) {
	return r.ApiService.GetEmployerManagerExecute(r)
}

/*
GetEmployerManager Получение информации о менеджере

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера
 @return ApiGetEmployerManagerRequest
*/
func (a *DefaultApiService) GetEmployerManager(ctx context.Context, employerId string, managerId string) ApiGetEmployerManagerRequest {
	return ApiGetEmployerManagerRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return EmployerManagersEmployerManagerInfo
func (a *DefaultApiService) GetEmployerManagerExecute(r ApiGetEmployerManagerRequest) (*EmployerManagersEmployerManagerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersEmployerManagerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManager")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagerLimitsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagerLimitsRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerManagerLimitsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagerLimitsRequest) Locale(locale string) ApiGetEmployerManagerLimitsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagerLimitsRequest) Host(host string) ApiGetEmployerManagerLimitsRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagerLimitsRequest) Execute() (*EmployerManagersEmployerManagerLimits, *http.Response, error) {
	return r.ApiService.GetEmployerManagerLimitsExecute(r)
}

/*
GetEmployerManagerLimits Дневной лимит просмотра резюме для текущего менеджера

Метод доступен менеджеру только для просмотра своего дневного лимита

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера, который можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetEmployerManagerLimitsRequest
*/
func (a *DefaultApiService) GetEmployerManagerLimits(ctx context.Context, employerId string, managerId string) ApiGetEmployerManagerLimitsRequest {
	return ApiGetEmployerManagerLimitsRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return EmployerManagersEmployerManagerLimits
func (a *DefaultApiService) GetEmployerManagerLimitsExecute(r ApiGetEmployerManagerLimitsRequest) (*EmployerManagersEmployerManagerLimits, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersEmployerManagerLimits
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManagerLimits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}/limits/resume"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagerTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagerTypesRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerManagerTypesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagerTypesRequest) Locale(locale string) ApiGetEmployerManagerTypesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagerTypesRequest) Host(host string) ApiGetEmployerManagerTypesRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagerTypesRequest) Execute() (*EmployerManagerTypesResponse, *http.Response, error) {
	return r.ApiService.GetEmployerManagerTypesExecute(r)
}

/*
GetEmployerManagerTypes Справочник типов и прав менеджера

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetEmployerManagerTypesRequest
*/
func (a *DefaultApiService) GetEmployerManagerTypes(ctx context.Context, employerId string) ApiGetEmployerManagerTypesRequest {
	return ApiGetEmployerManagerTypesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerManagerTypesResponse
func (a *DefaultApiService) GetEmployerManagerTypesExecute(r ApiGetEmployerManagerTypesRequest) (*EmployerManagerTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagerTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManagerTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/manager_types"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagerTypes_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagerTypes_0Request) HHUserAgent(hHUserAgent string) ApiGetEmployerManagerTypes_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagerTypes_0Request) Locale(locale string) ApiGetEmployerManagerTypes_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagerTypes_0Request) Host(host string) ApiGetEmployerManagerTypes_0Request {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagerTypes_0Request) Execute() (*EmployerManagerTypesResponse, *http.Response, error) {
	return r.ApiService.GetEmployerManagerTypes_14Execute(r)
}

/*
GetEmployerManagerTypes_0 Справочник типов и прав менеджера

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetEmployerManagerTypes_0Request
*/
func (a *DefaultApiService) GetEmployerManagerTypes_14(ctx context.Context, employerId string) ApiGetEmployerManagerTypes_0Request {
	return ApiGetEmployerManagerTypes_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerManagerTypesResponse
func (a *DefaultApiService) GetEmployerManagerTypes_14Execute(r ApiGetEmployerManagerTypes_0Request) (*EmployerManagerTypesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagerTypesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManagerTypes_14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/manager_types"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManager_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManager_0Request) HHUserAgent(hHUserAgent string) ApiGetEmployerManager_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManager_0Request) Locale(locale string) ApiGetEmployerManager_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManager_0Request) Host(host string) ApiGetEmployerManager_0Request {
	r.host = &host
	return r
}

func (r ApiGetEmployerManager_0Request) Execute() (*EmployerManagersEmployerManagerInfo, *http.Response, error) {
	return r.ApiService.GetEmployerManager_15Execute(r)
}

/*
GetEmployerManager_0 Получение информации о менеджере

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера
 @return ApiGetEmployerManager_0Request
*/
func (a *DefaultApiService) GetEmployerManager_15(ctx context.Context, employerId string, managerId string) ApiGetEmployerManager_0Request {
	return ApiGetEmployerManager_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return EmployerManagersEmployerManagerInfo
func (a *DefaultApiService) GetEmployerManager_15Execute(r ApiGetEmployerManager_0Request) (*EmployerManagersEmployerManagerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersEmployerManagerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManager_15")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagersRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagersRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerManagersRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetEmployerManagersRequest) Page(page float32) ApiGetEmployerManagersRequest {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetEmployerManagersRequest) PerPage(perPage float32) ApiGetEmployerManagersRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagersRequest) Locale(locale string) ApiGetEmployerManagersRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagersRequest) Host(host string) ApiGetEmployerManagersRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagersRequest) Execute() (*EmployerManagersResponse, *http.Response, error) {
	return r.ApiService.GetEmployerManagersExecute(r)
}

/*
GetEmployerManagers Список менеджеров работодателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetEmployerManagersRequest
*/
func (a *DefaultApiService) GetEmployerManagers(ctx context.Context, employerId string) ApiGetEmployerManagersRequest {
	return ApiGetEmployerManagersRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerManagersResponse
func (a *DefaultApiService) GetEmployerManagersExecute(r ApiGetEmployerManagersRequest) (*EmployerManagersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 200
		r.perPage = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerManagers_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerManagers_0Request) HHUserAgent(hHUserAgent string) ApiGetEmployerManagers_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetEmployerManagers_0Request) Page(page float32) ApiGetEmployerManagers_0Request {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetEmployerManagers_0Request) PerPage(perPage float32) ApiGetEmployerManagers_0Request {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerManagers_0Request) Locale(locale string) ApiGetEmployerManagers_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerManagers_0Request) Host(host string) ApiGetEmployerManagers_0Request {
	r.host = &host
	return r
}

func (r ApiGetEmployerManagers_0Request) Execute() (*EmployerManagersResponse, *http.Response, error) {
	return r.ApiService.GetEmployerManagers_16Execute(r)
}

/*
GetEmployerManagers_0 Список менеджеров работодателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetEmployerManagers_0Request
*/
func (a *DefaultApiService) GetEmployerManagers_16(ctx context.Context, employerId string) ApiGetEmployerManagers_0Request {
	return ApiGetEmployerManagers_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerManagersResponse
func (a *DefaultApiService) GetEmployerManagers_16Execute(r ApiGetEmployerManagers_0Request) (*EmployerManagersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerManagersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerManagers_16")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 200
		r.perPage = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmployerVacancyAreasRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetEmployerVacancyAreasRequest) HHUserAgent(hHUserAgent string) ApiGetEmployerVacancyAreasRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetEmployerVacancyAreasRequest) Locale(locale string) ApiGetEmployerVacancyAreasRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetEmployerVacancyAreasRequest) Host(host string) ApiGetEmployerVacancyAreasRequest {
	r.host = &host
	return r
}

func (r ApiGetEmployerVacancyAreasRequest) Execute() (*EmployersEmployerVacancyAreasResponse, *http.Response, error) {
	return r.ApiService.GetEmployerVacancyAreasExecute(r)
}

/*
GetEmployerVacancyAreas Список регионов, в которых есть активные вакансии

Возвращает список регионов, в которых на данный момент есть активные вакансии от указанного работодателя.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetEmployerVacancyAreasRequest
*/
func (a *DefaultApiService) GetEmployerVacancyAreas(ctx context.Context, employerId string) ApiGetEmployerVacancyAreasRequest {
	return ApiGetEmployerVacancyAreasRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersEmployerVacancyAreasResponse
func (a *DefaultApiService) GetEmployerVacancyAreasExecute(r ApiGetEmployerVacancyAreasRequest) (*EmployersEmployerVacancyAreasResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployerVacancyAreasResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetEmployerVacancyAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancy_areas/active"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFacultiesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetFacultiesRequest) HHUserAgent(hHUserAgent string) ApiGetFacultiesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetFacultiesRequest) Locale(locale string) ApiGetFacultiesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetFacultiesRequest) Host(host string) ApiGetFacultiesRequest {
	r.host = &host
	return r
}

func (r ApiGetFacultiesRequest) Execute() ([]IncludesIdName, *http.Response, error) {
	return r.ApiService.GetFacultiesExecute(r)
}

/*
GetFaculties Список факультетов учебного заведения

Возвращает список факультетов указанного учебного заведения

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор учебного заведения, который можно узнать из [подсказки](#tag/Podskazki/operation/get-educational-institutions-suggests)
 @return ApiGetFacultiesRequest
*/
func (a *DefaultApiService) GetFaculties(ctx context.Context, id string) ApiGetFacultiesRequest {
	return ApiGetFacultiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []IncludesIdName
func (a *DefaultApiService) GetFacultiesExecute(r ApiGetFacultiesRequest) ([]IncludesIdName, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IncludesIdName
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFaculties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/educational_institutions/{id}/faculties"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFavoriteVacanciesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetFavoriteVacanciesRequest) HHUserAgent(hHUserAgent string) ApiGetFavoriteVacanciesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiGetFavoriteVacanciesRequest) Page(page float32) ApiGetFavoriteVacanciesRequest {
	r.page = &page
	return r
}

// Количество элементов на странице
func (r ApiGetFavoriteVacanciesRequest) PerPage(perPage float32) ApiGetFavoriteVacanciesRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetFavoriteVacanciesRequest) Locale(locale string) ApiGetFavoriteVacanciesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetFavoriteVacanciesRequest) Host(host string) ApiGetFavoriteVacanciesRequest {
	r.host = &host
	return r
}

func (r ApiGetFavoriteVacanciesRequest) Execute() (*VacanciesVacanciesFavoritedResponse, *http.Response, error) {
	return r.ApiService.GetFavoriteVacanciesExecute(r)
}

/*
GetFavoriteVacancies Список отобранных вакансий

Возвращает [подмножество вакансий](#tag/Vakansii/operation/get-vacancy), добавленных пользователем в отобранные, а также ряд дополнительных полей

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFavoriteVacanciesRequest
*/
func (a *DefaultApiService) GetFavoriteVacancies(ctx context.Context) ApiGetFavoriteVacanciesRequest {
	return ApiGetFavoriteVacanciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacanciesVacanciesFavoritedResponse
func (a *DefaultApiService) GetFavoriteVacanciesExecute(r ApiGetFavoriteVacanciesRequest) (*VacanciesVacanciesFavoritedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacanciesFavoritedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFavoriteVacancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/favorited"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFieldsOfStudySuggestionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска специализаций. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetFieldsOfStudySuggestionsRequest) Text(text string) ApiGetFieldsOfStudySuggestionsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetFieldsOfStudySuggestionsRequest) HHUserAgent(hHUserAgent string) ApiGetFieldsOfStudySuggestionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetFieldsOfStudySuggestionsRequest) Locale(locale string) ApiGetFieldsOfStudySuggestionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetFieldsOfStudySuggestionsRequest) Host(host string) ApiGetFieldsOfStudySuggestionsRequest {
	r.host = &host
	return r
}

func (r ApiGetFieldsOfStudySuggestionsRequest) Execute() (*SuggestsFieldsOfStudy, *http.Response, error) {
	return r.ApiService.GetFieldsOfStudySuggestionsExecute(r)
}

/*
GetFieldsOfStudySuggestions Подсказки по специализациям

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFieldsOfStudySuggestionsRequest
*/
func (a *DefaultApiService) GetFieldsOfStudySuggestions(ctx context.Context) ApiGetFieldsOfStudySuggestionsRequest {
	return ApiGetFieldsOfStudySuggestionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsFieldsOfStudy
func (a *DefaultApiService) GetFieldsOfStudySuggestionsExecute(r ApiGetFieldsOfStudySuggestionsRequest) (*SuggestsFieldsOfStudy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsFieldsOfStudy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFieldsOfStudySuggestions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/fields_of_study"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHiddenVacanciesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	managerId *string
	orderBy *string
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetHiddenVacanciesRequest) HHUserAgent(hHUserAgent string) ApiGetHiddenVacanciesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор менеджера. Передайте, если требуется получить удаленные вакансии другого менеджера.  Если передать несколько параметров &#x60;manager_id&#x60;, будет использоваться только последний. По умолчанию возвращаются вакансии текущего пользователя 
func (r ApiGetHiddenVacanciesRequest) ManagerId(managerId string) ApiGetHiddenVacanciesRequest {
	r.managerId = &managerId
	return r
}

// Сортировка списка вакансий в архиве. Справочник с возможными значениями: &#x60;employer_hidden_vacancies_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetHiddenVacanciesRequest) OrderBy(orderBy string) ApiGetHiddenVacanciesRequest {
	r.orderBy = &orderBy
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение &#x60;per_page&#x60; составляет 1000 
func (r ApiGetHiddenVacanciesRequest) PerPage(perPage int32) ApiGetHiddenVacanciesRequest {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetHiddenVacanciesRequest) Page(page int32) ApiGetHiddenVacanciesRequest {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetHiddenVacanciesRequest) Locale(locale string) ApiGetHiddenVacanciesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetHiddenVacanciesRequest) Host(host string) ApiGetHiddenVacanciesRequest {
	r.host = &host
	return r
}

func (r ApiGetHiddenVacanciesRequest) Execute() (*VacanciesDeletedVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetHiddenVacanciesExecute(r)
}

/*
GetHiddenVacancies Список удаленных вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetHiddenVacanciesRequest
*/
func (a *DefaultApiService) GetHiddenVacancies(ctx context.Context, employerId string) ApiGetHiddenVacanciesRequest {
	return ApiGetHiddenVacanciesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesDeletedVacancyListResponse
func (a *DefaultApiService) GetHiddenVacanciesExecute(r ApiGetHiddenVacanciesRequest) (*VacanciesDeletedVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesDeletedVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetHiddenVacancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/hidden"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHiddenVacancies_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	managerId *string
	orderBy *string
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetHiddenVacancies_0Request) HHUserAgent(hHUserAgent string) ApiGetHiddenVacancies_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор менеджера. Передайте, если требуется получить удаленные вакансии другого менеджера.  Если передать несколько параметров &#x60;manager_id&#x60;, будет использоваться только последний. По умолчанию возвращаются вакансии текущего пользователя 
func (r ApiGetHiddenVacancies_0Request) ManagerId(managerId string) ApiGetHiddenVacancies_0Request {
	r.managerId = &managerId
	return r
}

// Сортировка списка вакансий в архиве. Справочник с возможными значениями: &#x60;employer_hidden_vacancies_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetHiddenVacancies_0Request) OrderBy(orderBy string) ApiGetHiddenVacancies_0Request {
	r.orderBy = &orderBy
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение &#x60;per_page&#x60; составляет 1000 
func (r ApiGetHiddenVacancies_0Request) PerPage(perPage int32) ApiGetHiddenVacancies_0Request {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetHiddenVacancies_0Request) Page(page int32) ApiGetHiddenVacancies_0Request {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetHiddenVacancies_0Request) Locale(locale string) ApiGetHiddenVacancies_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetHiddenVacancies_0Request) Host(host string) ApiGetHiddenVacancies_0Request {
	r.host = &host
	return r
}

func (r ApiGetHiddenVacancies_0Request) Execute() (*VacanciesDeletedVacancyListResponse, *http.Response, error) {
	return r.ApiService.GetHiddenVacancies_17Execute(r)
}

/*
GetHiddenVacancies_0 Список удаленных вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetHiddenVacancies_0Request
*/
func (a *DefaultApiService) GetHiddenVacancies_17(ctx context.Context, employerId string) ApiGetHiddenVacancies_0Request {
	return ApiGetHiddenVacancies_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return VacanciesDeletedVacancyListResponse
func (a *DefaultApiService) GetHiddenVacancies_17Execute(r ApiGetHiddenVacancies_0Request) (*VacanciesDeletedVacancyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesDeletedVacancyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetHiddenVacancies_17")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/hidden"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.managerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "manager_id", r.managerId, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndustriesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetIndustriesRequest) HHUserAgent(hHUserAgent string) ApiGetIndustriesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetIndustriesRequest) Locale(locale string) ApiGetIndustriesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetIndustriesRequest) Host(host string) ApiGetIndustriesRequest {
	r.host = &host
	return r
}

func (r ApiGetIndustriesRequest) Execute() ([]DictionariesBranchItem, *http.Response, error) {
	return r.ApiService.GetIndustriesExecute(r)
}

/*
GetIndustries Отрасли компаний

Возвращает двухуровневый справочник всех отраслей

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIndustriesRequest
*/
func (a *DefaultApiService) GetIndustries(ctx context.Context) ApiGetIndustriesRequest {
	return ApiGetIndustriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesBranchItem
func (a *DefaultApiService) GetIndustriesExecute(r ApiGetIndustriesRequest) ([]DictionariesBranchItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesBranchItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetIndustries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/industries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLanguagesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetLanguagesRequest) HHUserAgent(hHUserAgent string) ApiGetLanguagesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetLanguagesRequest) Locale(locale string) ApiGetLanguagesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetLanguagesRequest) Host(host string) ApiGetLanguagesRequest {
	r.host = &host
	return r
}

func (r ApiGetLanguagesRequest) Execute() ([]DictionariesLangItem, *http.Response, error) {
	return r.ApiService.GetLanguagesExecute(r)
}

/*
GetLanguages Список всех языков

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLanguagesRequest
*/
func (a *DefaultApiService) GetLanguages(ctx context.Context) ApiGetLanguagesRequest {
	return ApiGetLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesLangItem
func (a *DefaultApiService) GetLanguagesExecute(r ApiGetLanguagesRequest) ([]DictionariesLangItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesLangItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetLocalesRequest) HHUserAgent(hHUserAgent string) ApiGetLocalesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetLocalesRequest) Locale(locale string) ApiGetLocalesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetLocalesRequest) Host(host string) ApiGetLocalesRequest {
	r.host = &host
	return r
}

func (r ApiGetLocalesRequest) Execute() ([]LocalesLocaleItem, *http.Response, error) {
	return r.ApiService.GetLocalesExecute(r)
}

/*
GetLocales Список доступных локалей

Возвращает список возможных значений (доступных локалей) в поле `id`. Список локалей будет зависеть от указанного сайта (параметр `host`). В любом запросе к API можно указывать параметр `?locale=` для передачи значения локали (языка)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalesRequest
*/
func (a *DefaultApiService) GetLocales(ctx context.Context) ApiGetLocalesRequest {
	return ApiGetLocalesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LocalesLocaleItem
func (a *DefaultApiService) GetLocalesExecute(r ApiGetLocalesRequest) ([]LocalesLocaleItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LocalesLocaleItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLocales")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLocalesForResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetLocalesForResumeRequest) HHUserAgent(hHUserAgent string) ApiGetLocalesForResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetLocalesForResumeRequest) Locale(locale string) ApiGetLocalesForResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetLocalesForResumeRequest) Host(host string) ApiGetLocalesForResumeRequest {
	r.host = &host
	return r
}

func (r ApiGetLocalesForResumeRequest) Execute() ([]LocalesResumeLocaleItem, *http.Response, error) {
	return r.ApiService.GetLocalesForResumeExecute(r)
}

/*
GetLocalesForResume Список доступных локалей для резюме

Возвращает справочник возможных локалей резюме. Подколлекция [справочника локалей](#tag/Obshie-spravochniki/operation/get-locales-for-resume).

Изменив локаль, можно, например, создать резюме на английском языке


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLocalesForResumeRequest
*/
func (a *DefaultApiService) GetLocalesForResume(ctx context.Context) ApiGetLocalesForResumeRequest {
	return ApiGetLocalesForResumeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LocalesResumeLocaleItem
func (a *DefaultApiService) GetLocalesForResumeExecute(r ApiGetLocalesForResumeRequest) ([]LocalesResumeLocaleItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LocalesResumeLocaleItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetLocalesForResume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/locales/resume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMailTemplatesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetMailTemplatesRequest) HHUserAgent(hHUserAgent string) ApiGetMailTemplatesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetMailTemplatesRequest) Locale(locale string) ApiGetMailTemplatesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetMailTemplatesRequest) Host(host string) ApiGetMailTemplatesRequest {
	r.host = &host
	return r
}

func (r ApiGetMailTemplatesRequest) Execute() ([]MailTemplatesMailTemplate, *http.Response, error) {
	return r.ApiService.GetMailTemplatesExecute(r)
}

/*
GetMailTemplates Список доступных шаблонов ответов соискателю

Возвращает список возможных значений шаблонов ответов для [переписки](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @return ApiGetMailTemplatesRequest
*/
func (a *DefaultApiService) GetMailTemplates(ctx context.Context, employerId string) ApiGetMailTemplatesRequest {
	return ApiGetMailTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return []MailTemplatesMailTemplate
func (a *DefaultApiService) GetMailTemplatesExecute(r ApiGetMailTemplatesRequest) ([]MailTemplatesMailTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MailTemplatesMailTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMailTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/mail_templates"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagerAccountsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetManagerAccountsRequest) HHUserAgent(hHUserAgent string) ApiGetManagerAccountsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetManagerAccountsRequest) Locale(locale string) ApiGetManagerAccountsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetManagerAccountsRequest) Host(host string) ApiGetManagerAccountsRequest {
	r.host = &host
	return r
}

func (r ApiGetManagerAccountsRequest) Execute() (*ManagerAccounts, *http.Response, error) {
	return r.ApiService.GetManagerAccountsExecute(r)
}

/*
GetManagerAccounts Рабочие аккаунты менеджера

Возвращает список рабочих аккаунтов менеджера и информацию об основном и текущем аккаунте.

Для работы под определенным аккаунтом необходимо передать значение account_id, полученное из списка, в заголовке:

`X-Manager-Account-Id: {account_id}`

Использовать данный заголовок можно во всех методах, доступных для работодателей.

В заголовке можно передавать account_id основного аккаунта, который также подразумевается по умолчанию, при отсутствии заголовка


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetManagerAccountsRequest
*/
func (a *DefaultApiService) GetManagerAccounts(ctx context.Context) ApiGetManagerAccountsRequest {
	return ApiGetManagerAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManagerAccounts
func (a *DefaultApiService) GetManagerAccountsExecute(r ApiGetManagerAccountsRequest) (*ManagerAccounts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagerAccounts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetManagerAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manager_accounts/mine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagerSettingsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetManagerSettingsRequest) HHUserAgent(hHUserAgent string) ApiGetManagerSettingsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetManagerSettingsRequest) Locale(locale string) ApiGetManagerSettingsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetManagerSettingsRequest) Host(host string) ApiGetManagerSettingsRequest {
	r.host = &host
	return r
}

func (r ApiGetManagerSettingsRequest) Execute() (*ManagerSettings, *http.Response, error) {
	return r.ApiService.GetManagerSettingsExecute(r)
}

/*
GetManagerSettings Предпочтения менеджера

Возвращает информацию о предпочтениях менеджера.

Проще всего получить URL из поля `manager_settings_url` объекта `manager`
в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info).

Предпочтения менеджера *не влияют* на действия в API по умолчанию. Например, брендированный шаблон оформления
(`default_vacancy_branded_template`) не будет применен автоматически при публикации вакансии, если шаблон не был передан.
Приложение может использовать эту информацию для того, чтобы реализовать логику предзаполнения полей


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param managerId Идентификатор менеджера. Можно узнать из списка [менеджеров](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers)
 @return ApiGetManagerSettingsRequest
*/
func (a *DefaultApiService) GetManagerSettings(ctx context.Context, employerId string, managerId string) ApiGetManagerSettingsRequest {
	return ApiGetManagerSettingsRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return ManagerSettings
func (a *DefaultApiService) GetManagerSettingsExecute(r ApiGetManagerSettingsRequest) (*ManagerSettings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManagerSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetManagerSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetroStationsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetMetroStationsRequest) HHUserAgent(hHUserAgent string) ApiGetMetroStationsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetMetroStationsRequest) Locale(locale string) ApiGetMetroStationsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetMetroStationsRequest) Host(host string) ApiGetMetroStationsRequest {
	r.host = &host
	return r
}

func (r ApiGetMetroStationsRequest) Execute() ([]MetroMetroItem, *http.Response, error) {
	return r.ApiService.GetMetroStationsExecute(r)
}

/*
GetMetroStations Список станций метро во всех городах

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMetroStationsRequest
*/
func (a *DefaultApiService) GetMetroStations(ctx context.Context) ApiGetMetroStationsRequest {
	return ApiGetMetroStationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MetroMetroItem
func (a *DefaultApiService) GetMetroStationsExecute(r ApiGetMetroStationsRequest) ([]MetroMetroItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MetroMetroItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMetroStations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metro"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetroStationsInCityRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	cityId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetMetroStationsInCityRequest) HHUserAgent(hHUserAgent string) ApiGetMetroStationsInCityRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetMetroStationsInCityRequest) Locale(locale string) ApiGetMetroStationsInCityRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetMetroStationsInCityRequest) Host(host string) ApiGetMetroStationsInCityRequest {
	r.host = &host
	return r
}

func (r ApiGetMetroStationsInCityRequest) Execute() (*MetroCityMetroItem, *http.Response, error) {
	return r.ApiService.GetMetroStationsInCityExecute(r)
}

/*
GetMetroStationsInCity Список станций метро в указанном городе

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityId Идентификатор города
 @return ApiGetMetroStationsInCityRequest
*/
func (a *DefaultApiService) GetMetroStationsInCity(ctx context.Context, cityId string) ApiGetMetroStationsInCityRequest {
	return ApiGetMetroStationsInCityRequest{
		ApiService: a,
		ctx: ctx,
		cityId: cityId,
	}
}

// Execute executes the request
//  @return MetroCityMetroItem
func (a *DefaultApiService) GetMetroStationsInCityExecute(r ApiGetMetroStationsInCityRequest) (*MetroCityMetroItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetroCityMetroItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMetroStationsInCity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metro/{city_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"city_id"+"}", url.PathEscape(parameterValueToString(r.cityId, "cityId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMineResumesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetMineResumesRequest) HHUserAgent(hHUserAgent string) ApiGetMineResumesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetMineResumesRequest) Locale(locale string) ApiGetMineResumesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetMineResumesRequest) Host(host string) ApiGetMineResumesRequest {
	r.host = &host
	return r
}

func (r ApiGetMineResumesRequest) Execute() (*ResumesMineResponse, *http.Response, error) {
	return r.ApiService.GetMineResumesExecute(r)
}

/*
GetMineResumes Список резюме авторизованного пользователя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMineResumesRequest
*/
func (a *DefaultApiService) GetMineResumes(ctx context.Context) ApiGetMineResumesRequest {
	return ApiGetMineResumesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumesMineResponse
func (a *DefaultApiService) GetMineResumesExecute(r ApiGetMineResumesRequest) (*ResumesMineResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesMineResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetMineResumes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/mine"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiationItemRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNegotiationItemRequest) HHUserAgent(hHUserAgent string) ApiGetNegotiationItemRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNegotiationItemRequest) Locale(locale string) ApiGetNegotiationItemRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNegotiationItemRequest) Host(host string) ApiGetNegotiationItemRequest {
	r.host = &host
	return r
}

func (r ApiGetNegotiationItemRequest) Execute() (*NegotiationsNegotiationGetResponse, *http.Response, error) {
	return r.ApiService.GetNegotiationItemExecute(r)
}

/*
GetNegotiationItem Просмотр отклика/приглашения

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор отклика
 @return ApiGetNegotiationItemRequest
*/
func (a *DefaultApiService) GetNegotiationItem(ctx context.Context, id string) ApiGetNegotiationItemRequest {
	return ApiGetNegotiationItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return NegotiationsNegotiationGetResponse
func (a *DefaultApiService) GetNegotiationItemExecute(r ApiGetNegotiationItemRequest) (*NegotiationsNegotiationGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsNegotiationGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNegotiationItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiationMessageTemplatesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	template string
	hHUserAgent *string
	topicId *string
	vacancyId *string
	resumeId *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNegotiationMessageTemplatesRequest) HHUserAgent(hHUserAgent string) ApiGetNegotiationMessageTemplatesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор существующего отклика/приглашения. Не может передаваться одновременно с другими параметрами
func (r ApiGetNegotiationMessageTemplatesRequest) TopicId(topicId string) ApiGetNegotiationMessageTemplatesRequest {
	r.topicId = &topicId
	return r
}

// Идентификатор вакансии для приглашения. Передается только вместе с параметром &#x60;resume_id&#x60;
func (r ApiGetNegotiationMessageTemplatesRequest) VacancyId(vacancyId string) ApiGetNegotiationMessageTemplatesRequest {
	r.vacancyId = &vacancyId
	return r
}

// Идентификатор резюме для приглашения на вакансию. Передается только вместе с параметром &#x60;vacancy_id&#x60;
func (r ApiGetNegotiationMessageTemplatesRequest) ResumeId(resumeId string) ApiGetNegotiationMessageTemplatesRequest {
	r.resumeId = &resumeId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNegotiationMessageTemplatesRequest) Locale(locale string) ApiGetNegotiationMessageTemplatesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNegotiationMessageTemplatesRequest) Host(host string) ApiGetNegotiationMessageTemplatesRequest {
	r.host = &host
	return r
}

func (r ApiGetNegotiationMessageTemplatesRequest) Execute() (*NegotiationsNegotiationMessageTemplates, *http.Response, error) {
	return r.ApiService.GetNegotiationMessageTemplatesExecute(r)
}

/*
GetNegotiationMessageTemplates Список шаблонов ответов для отклика/приглашения

Метод требует наличия [платного доступа для работодателя](https://github.com/hhru/api/blob/master/docs/payable/employer_methods.md).

Возвращает список шаблонов ответов для отклика/приглашения или резюме. Может использоваться в отправляемых соискателю приглашениях на вакансию или [действиях по откликам/приглашениям](#tag/Otklikipriglasheniya-rabotodatelya/operation/put-negotiations-collection-to-next-state).

> Количество доступных шаблонов будет зависеть от конкретного отклика/приглашения или вакансии и их статусов.

Рекомендуется использовать URL из поля `templates.url` в [списке откликов/приглашений](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#negotiations-list). Примеры:

```
GET /message_templates/{template}?topic_id={topic_id}
GET /message_templates/{template}?vacancy_id={vacancy_id}&resume_id={resume_id}
```


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param template Название шаблона. Возможные варианты:  * `invite` — текст при приглашении соискателя на вакансию; * `invite_after_response` — текст при [приглашении после отклика со стороны соискателя](#tag/Otklikipriglasheniya-rabotodatelya/operation/put-negotiations-collection-to-next-state); * `discard_after_response` — текст при [отказе после отклика](#tag/Otklikipriglasheniya-rabotodatelya/operation/put-negotiations-collection-to-next-state); * `discard_after_interview` — текст при [отказе после приглашения соискателя на интервью](#tag/Otklikipriglasheniya-rabotodatelya/operation/put-negotiations-collection-to-next-state).  Список шаблонов может быть расширен 
 @return ApiGetNegotiationMessageTemplatesRequest
*/
func (a *DefaultApiService) GetNegotiationMessageTemplates(ctx context.Context, template string) ApiGetNegotiationMessageTemplatesRequest {
	return ApiGetNegotiationMessageTemplatesRequest{
		ApiService: a,
		ctx: ctx,
		template: template,
	}
}

// Execute executes the request
//  @return NegotiationsNegotiationMessageTemplates
func (a *DefaultApiService) GetNegotiationMessageTemplatesExecute(r ApiGetNegotiationMessageTemplatesRequest) (*NegotiationsNegotiationMessageTemplates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsNegotiationMessageTemplates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNegotiationMessageTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/message_templates/{template}"
	localVarPath = strings.Replace(localVarPath, "{"+"template"+"}", url.PathEscape(parameterValueToString(r.template, "template")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.topicId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topic_id", r.topicId, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.resumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resume_id", r.resumeId, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiationMessagesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nid string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNegotiationMessagesRequest) HHUserAgent(hHUserAgent string) ApiGetNegotiationMessagesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNegotiationMessagesRequest) Locale(locale string) ApiGetNegotiationMessagesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNegotiationMessagesRequest) Host(host string) ApiGetNegotiationMessagesRequest {
	r.host = &host
	return r
}

func (r ApiGetNegotiationMessagesRequest) Execute() (*NegotiationsMessagesGetResponse, *http.Response, error) {
	return r.ApiService.GetNegotiationMessagesExecute(r)
}

/*
GetNegotiationMessages Просмотр списка сообщений в отклике

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nid Идентификатор отклика
 @return ApiGetNegotiationMessagesRequest
*/
func (a *DefaultApiService) GetNegotiationMessages(ctx context.Context, nid string) ApiGetNegotiationMessagesRequest {
	return ApiGetNegotiationMessagesRequest{
		ApiService: a,
		ctx: ctx,
		nid: nid,
	}
}

// Execute executes the request
//  @return NegotiationsMessagesGetResponse
func (a *DefaultApiService) GetNegotiationMessagesExecute(r ApiGetNegotiationMessagesRequest) (*NegotiationsMessagesGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsMessagesGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNegotiationMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{nid}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterValueToString(r.nid, "nid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiationsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	orderBy *string
	order *string
	vacancyId *string
	status *string
	hasUpdates *bool
	withJobSearchStatus *bool
	withGeneratedCollections *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNegotiationsRequest) HHUserAgent(hHUserAgent string) ApiGetNegotiationsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetNegotiationsRequest) Page(page float32) ApiGetNegotiationsRequest {
	r.page = &page
	return r
}

// Количество элементов на странице
func (r ApiGetNegotiationsRequest) PerPage(perPage float32) ApiGetNegotiationsRequest {
	r.perPage = &perPage
	return r
}

// Тип сортировки. Возможные значения указаны в поле &#x60;negotiations_order&#x60; [справочника полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiGetNegotiationsRequest) OrderBy(orderBy string) ApiGetNegotiationsRequest {
	r.orderBy = &orderBy
	return r
}

// Направление сортировки. Возможные значения: &#x60;asc&#x60; — по возрастанию, &#x60;desc&#x60; — по убыванию
func (r ApiGetNegotiationsRequest) Order(order string) ApiGetNegotiationsRequest {
	r.order = &order
	return r
}

// Фильтр по ID вакансии. Обязательный для работодателя
func (r ApiGetNegotiationsRequest) VacancyId(vacancyId string) ApiGetNegotiationsRequest {
	r.vacancyId = &vacancyId
	return r
}

// Запрос вернет только те отклики, которые находятся в определенном статусе.  Возможные значения указаны в поле &#x60;applicant_negotiation_status&#x60; [справочника полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetNegotiationsRequest) Status(status string) ApiGetNegotiationsRequest {
	r.status = &status
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет только те отклики, для которых есть непросмотренные сообщения. По умолчанию &#x60;false&#x60; 
func (r ApiGetNegotiationsRequest) HasUpdates(hasUpdates bool) ApiGetNegotiationsRequest {
	r.hasUpdates = &hasUpdates
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет статус поиска работы кандидатом 
func (r ApiGetNegotiationsRequest) WithJobSearchStatus(withJobSearchStatus bool) ApiGetNegotiationsRequest {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет информацию по [сгенерированным коллекциям](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#term-collection) откликов/приглашений для данной вакансии.  Чтобы получить выгрузку по нескольким коллекциям, запросите их последовательно. По умолчанию &#x60;false&#x60; 
func (r ApiGetNegotiationsRequest) WithGeneratedCollections(withGeneratedCollections bool) ApiGetNegotiationsRequest {
	r.withGeneratedCollections = &withGeneratedCollections
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNegotiationsRequest) Locale(locale string) ApiGetNegotiationsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNegotiationsRequest) Host(host string) ApiGetNegotiationsRequest {
	r.host = &host
	return r
}

func (r ApiGetNegotiationsRequest) Execute() (*NegotiationsListResponse, *http.Response, error) {
	return r.ApiService.GetNegotiationsExecute(r)
}

/*
GetNegotiations Список откликов/приглашений

Возвращает список откликов соискателя или одну коллекцию откликов/приглашений по [вакансии](#tag/Upravlenie-vakansiyami/operation/get-active-vacancy-list) работодателя.

По умолчанию отклики сортируются по дате последнего обновления — от новых к старым.

Чтобы получить список активных откликов, передайте в запросе параметр `?status=active`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNegotiationsRequest
*/
func (a *DefaultApiService) GetNegotiations(ctx context.Context) ApiGetNegotiationsRequest {
	return ApiGetNegotiationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NegotiationsListResponse
func (a *DefaultApiService) GetNegotiationsExecute(r ApiGetNegotiationsRequest) (*NegotiationsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNegotiations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 20
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.hasUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_updates", r.hasUpdates, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.withGeneratedCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_generated_collections", r.withGeneratedCollections, "")
	} else {
		var defaultValue bool = false
		r.withGeneratedCollections = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonOneOfErrorsBadRequestAndBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNegotiations_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	orderBy *string
	order *string
	vacancyId *string
	status *string
	hasUpdates *bool
	withJobSearchStatus *bool
	withGeneratedCollections *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNegotiations_0Request) HHUserAgent(hHUserAgent string) ApiGetNegotiations_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetNegotiations_0Request) Page(page float32) ApiGetNegotiations_0Request {
	r.page = &page
	return r
}

// Количество элементов на странице
func (r ApiGetNegotiations_0Request) PerPage(perPage float32) ApiGetNegotiations_0Request {
	r.perPage = &perPage
	return r
}

// Тип сортировки. Возможные значения указаны в поле &#x60;negotiations_order&#x60; [справочника полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiGetNegotiations_0Request) OrderBy(orderBy string) ApiGetNegotiations_0Request {
	r.orderBy = &orderBy
	return r
}

// Направление сортировки. Возможные значения: &#x60;asc&#x60; — по возрастанию, &#x60;desc&#x60; — по убыванию
func (r ApiGetNegotiations_0Request) Order(order string) ApiGetNegotiations_0Request {
	r.order = &order
	return r
}

// Фильтр по ID вакансии. Обязательный для работодателя
func (r ApiGetNegotiations_0Request) VacancyId(vacancyId string) ApiGetNegotiations_0Request {
	r.vacancyId = &vacancyId
	return r
}

// Запрос вернет только те отклики, которые находятся в определенном статусе.  Возможные значения указаны в поле &#x60;applicant_negotiation_status&#x60; [справочника полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiGetNegotiations_0Request) Status(status string) ApiGetNegotiations_0Request {
	r.status = &status
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет только те отклики, для которых есть непросмотренные сообщения. По умолчанию &#x60;false&#x60; 
func (r ApiGetNegotiations_0Request) HasUpdates(hasUpdates bool) ApiGetNegotiations_0Request {
	r.hasUpdates = &hasUpdates
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет статус поиска работы кандидатом 
func (r ApiGetNegotiations_0Request) WithJobSearchStatus(withJobSearchStatus bool) ApiGetNegotiations_0Request {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Если передан &#x60;true&#x60;, запрос вернет информацию по [сгенерированным коллекциям](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#term-collection) откликов/приглашений для данной вакансии.  Чтобы получить выгрузку по нескольким коллекциям, запросите их последовательно. По умолчанию &#x60;false&#x60; 
func (r ApiGetNegotiations_0Request) WithGeneratedCollections(withGeneratedCollections bool) ApiGetNegotiations_0Request {
	r.withGeneratedCollections = &withGeneratedCollections
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNegotiations_0Request) Locale(locale string) ApiGetNegotiations_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNegotiations_0Request) Host(host string) ApiGetNegotiations_0Request {
	r.host = &host
	return r
}

func (r ApiGetNegotiations_0Request) Execute() (*NegotiationsListResponse, *http.Response, error) {
	return r.ApiService.GetNegotiations_18Execute(r)
}

/*
GetNegotiations_0 Список откликов/приглашений

Возвращает список откликов соискателя или одну коллекцию откликов/приглашений по [вакансии](#tag/Upravlenie-vakansiyami/operation/get-active-vacancy-list) работодателя.

По умолчанию отклики сортируются по дате последнего обновления — от новых к старым.

Чтобы получить список активных откликов, передайте в запросе параметр `?status=active`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNegotiations_0Request
*/
func (a *DefaultApiService) GetNegotiations_18(ctx context.Context) ApiGetNegotiations_0Request {
	return ApiGetNegotiations_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NegotiationsListResponse
func (a *DefaultApiService) GetNegotiations_18Execute(r ApiGetNegotiations_0Request) (*NegotiationsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNegotiations_18")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 20
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.hasUpdates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_updates", r.hasUpdates, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.withGeneratedCollections != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_generated_collections", r.withGeneratedCollections, "")
	} else {
		var defaultValue bool = false
		r.withGeneratedCollections = &defaultValue
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonOneOfErrorsBadRequestAndBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNewResumeConditionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetNewResumeConditionsRequest) HHUserAgent(hHUserAgent string) ApiGetNewResumeConditionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetNewResumeConditionsRequest) Locale(locale string) ApiGetNewResumeConditionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetNewResumeConditionsRequest) Host(host string) ApiGetNewResumeConditionsRequest {
	r.host = &host
	return r
}

func (r ApiGetNewResumeConditionsRequest) Execute() (*ResumesResumeConditions, *http.Response, error) {
	return r.ApiService.GetNewResumeConditionsExecute(r)
}

/*
GetNewResumeConditions Условия заполнения полей нового резюме

Возвращает список требований для полей при заполнении нового резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNewResumeConditionsRequest
*/
func (a *DefaultApiService) GetNewResumeConditions(ctx context.Context) ApiGetNewResumeConditionsRequest {
	return ApiGetNewResumeConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumesResumeConditions
func (a *DefaultApiService) GetNewResumeConditionsExecute(r ApiGetNewResumeConditionsRequest) (*ResumesResumeConditions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesResumeConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNewResumeConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resume_conditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPayableApiActionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetPayableApiActionsRequest) HHUserAgent(hHUserAgent string) ApiGetPayableApiActionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetPayableApiActionsRequest) Locale(locale string) ApiGetPayableApiActionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetPayableApiActionsRequest) Host(host string) ApiGetPayableApiActionsRequest {
	r.host = &host
	return r
}

func (r ApiGetPayableApiActionsRequest) Execute() (*EmployerServicesEmployerServices, *http.Response, error) {
	return r.ApiService.GetPayableApiActionsExecute(r)
}

/*
GetPayableApiActions Информация по активным услугам API для платных методов

Каждая подключенная услуга отображается отдельным объектом в массиве `items`, даже при условии, что подключено несколько услуг одного типа.
Если у работодателя нет активных услуг, то в ответе придет пустой массив `items`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetPayableApiActionsRequest
*/
func (a *DefaultApiService) GetPayableApiActions(ctx context.Context, employerId string) ApiGetPayableApiActionsRequest {
	return ApiGetPayableApiActionsRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerServicesEmployerServices
func (a *DefaultApiService) GetPayableApiActionsExecute(r ApiGetPayableApiActionsRequest) (*EmployerServicesEmployerServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerServicesEmployerServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPayableApiActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/services/payable_api_actions/active"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPayableApiMethodAccessRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetPayableApiMethodAccessRequest) HHUserAgent(hHUserAgent string) ApiGetPayableApiMethodAccessRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetPayableApiMethodAccessRequest) Locale(locale string) ApiGetPayableApiMethodAccessRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetPayableApiMethodAccessRequest) Host(host string) ApiGetPayableApiMethodAccessRequest {
	r.host = &host
	return r
}

func (r ApiGetPayableApiMethodAccessRequest) Execute() (*EmployerServicesMethodAccess, *http.Response, error) {
	return r.ApiService.GetPayableApiMethodAccessExecute(r)
}

/*
GetPayableApiMethodAccess Проверка доступа к платным методам

Начиная с 16 июля 2018 года, некоторые методы API HH для работодателей стали платными.

Такие методы отмечены в [оглавлении GitHub](https://github.com/hhru/api/blob/master/README.md#content) лейблом <img src="http://hhru.github.io/api/badges/emp_paid.png" alt="employer with paid access" />

Чтобы приобрести доступ к платным методам, обратитесь к своему персональному менеджеру.

> Если вы работаете от имени нескольких учетных записей работодателя, проверьте [информацию о подключенных услугах](#tag/Uslugi-rabotodatelya/operation/get-payable-api-actions) — каждой учетной записи должен быть предоставлен доступ к платным методам API. При отсутствии доступа будет выдана ошибка `403 Forbidden`.

Метод возвращает информацию о доступе к группам платных методов. Существующие группы:

1. Наличие доступа к методам резюме:
  * [Просмотр резюме](#tag/Prosmotr-rezyume/operation/get-resume).
  * [Работа с откликами](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md).
  * [Переписка с соискателем](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#get-messages).
2. Наличие доступа к методам поиска вакансий:
  * [Поиск резюме](#tag/Poisk-rezyume/operation/search-for-resumes).
  * [Сохраненные поиски резюме](#tag/Sohranennye-poiski-rezyume/operation/get-saved-resume-searches).
3. Наличие доступа к [просмотру резюме](#tag/Prosmotr-rezyume/operation/get-resume), у которого есть отклик или приглашение.
4. Наличие доступа к [просмотру резюме](#tag/Prosmotr-rezyume/operation/get-resume), найденных через [поиск по базе](#tag/Poisk-rezyume/operation/search-for-resumes).

**Внимание!** Изменился доступ к контактной информации резюме, подробнее [о новой модели работы с базой резюме](https://github.com/hhru/api/blob/master/docs/payable/resume.md)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя. Можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info) 
 @param managerId Идентификатор менеджера. Можно узнать в [информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info) 
 @return ApiGetPayableApiMethodAccessRequest
*/
func (a *DefaultApiService) GetPayableApiMethodAccess(ctx context.Context, employerId string, managerId string) ApiGetPayableApiMethodAccessRequest {
	return ApiGetPayableApiMethodAccessRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		managerId: managerId,
	}
}

// Execute executes the request
//  @return EmployerServicesMethodAccess
func (a *DefaultApiService) GetPayableApiMethodAccessExecute(r ApiGetPayableApiMethodAccessRequest) (*EmployerServicesMethodAccess, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerServicesMethodAccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPayableApiMethodAccess")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/managers/{manager_id}/method_access"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPositionsSuggestionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска должности. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetPositionsSuggestionsRequest) Text(text string) ApiGetPositionsSuggestionsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetPositionsSuggestionsRequest) HHUserAgent(hHUserAgent string) ApiGetPositionsSuggestionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetPositionsSuggestionsRequest) Locale(locale string) ApiGetPositionsSuggestionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetPositionsSuggestionsRequest) Host(host string) ApiGetPositionsSuggestionsRequest {
	r.host = &host
	return r
}

func (r ApiGetPositionsSuggestionsRequest) Execute() (*SuggestsPositions, *http.Response, error) {
	return r.ApiService.GetPositionsSuggestionsExecute(r)
}

/*
GetPositionsSuggestions Подсказки по должностям резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPositionsSuggestionsRequest
*/
func (a *DefaultApiService) GetPositionsSuggestions(ctx context.Context) ApiGetPositionsSuggestionsRequest {
	return ApiGetPositionsSuggestionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsPositions
func (a *DefaultApiService) GetPositionsSuggestionsExecute(r ApiGetPositionsSuggestionsRequest) (*SuggestsPositions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsPositions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPositionsSuggestions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPrefNegotiationsOrderRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetPrefNegotiationsOrderRequest) HHUserAgent(hHUserAgent string) ApiGetPrefNegotiationsOrderRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetPrefNegotiationsOrderRequest) Locale(locale string) ApiGetPrefNegotiationsOrderRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetPrefNegotiationsOrderRequest) Host(host string) ApiGetPrefNegotiationsOrderRequest {
	r.host = &host
	return r
}

func (r ApiGetPrefNegotiationsOrderRequest) Execute() (*VacanciesPreferredNegotiationsOrder, *http.Response, error) {
	return r.ApiService.GetPrefNegotiationsOrderExecute(r)
}

/*
GetPrefNegotiationsOrder Просмотр предпочитаемой сортировки откликов

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор вакансии
 @return ApiGetPrefNegotiationsOrderRequest
*/
func (a *DefaultApiService) GetPrefNegotiationsOrder(ctx context.Context, id string) ApiGetPrefNegotiationsOrderRequest {
	return ApiGetPrefNegotiationsOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VacanciesPreferredNegotiationsOrder
func (a *DefaultApiService) GetPrefNegotiationsOrderExecute(r ApiGetPrefNegotiationsOrderRequest) (*VacanciesPreferredNegotiationsOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesPreferredNegotiationsOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPrefNegotiationsOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{id}/preferred_negotiations_order"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfessionalRolesDictionaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetProfessionalRolesDictionaryRequest) HHUserAgent(hHUserAgent string) ApiGetProfessionalRolesDictionaryRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetProfessionalRolesDictionaryRequest) Locale(locale string) ApiGetProfessionalRolesDictionaryRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetProfessionalRolesDictionaryRequest) Host(host string) ApiGetProfessionalRolesDictionaryRequest {
	r.host = &host
	return r
}

func (r ApiGetProfessionalRolesDictionaryRequest) Execute() (*ProfessionalRolesCatalog, *http.Response, error) {
	return r.ApiService.GetProfessionalRolesDictionaryExecute(r)
}

/*
GetProfessionalRolesDictionary Справочник профессиональных ролей

Возвращает профессиональные роли, их категории и другую информацию о профессиональных ролях


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProfessionalRolesDictionaryRequest
*/
func (a *DefaultApiService) GetProfessionalRolesDictionary(ctx context.Context) ApiGetProfessionalRolesDictionaryRequest {
	return ApiGetProfessionalRolesDictionaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProfessionalRolesCatalog
func (a *DefaultApiService) GetProfessionalRolesDictionaryExecute(r ApiGetProfessionalRolesDictionaryRequest) (*ProfessionalRolesCatalog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProfessionalRolesCatalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProfessionalRolesDictionary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/professional_roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfessionalRolesSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска профессиональной роли. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetProfessionalRolesSuggestsRequest) Text(text string) ApiGetProfessionalRolesSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetProfessionalRolesSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetProfessionalRolesSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetProfessionalRolesSuggestsRequest) Locale(locale string) ApiGetProfessionalRolesSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetProfessionalRolesSuggestsRequest) Host(host string) ApiGetProfessionalRolesSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetProfessionalRolesSuggestsRequest) Execute() (*SuggestsProfessionalRoles, *http.Response, error) {
	return r.ApiService.GetProfessionalRolesSuggestsExecute(r)
}

/*
GetProfessionalRolesSuggests Подсказки по профессиональным ролям

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProfessionalRolesSuggestsRequest
*/
func (a *DefaultApiService) GetProfessionalRolesSuggests(ctx context.Context) ApiGetProfessionalRolesSuggestsRequest {
	return ApiGetProfessionalRolesSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsProfessionalRoles
func (a *DefaultApiService) GetProfessionalRolesSuggestsExecute(r ApiGetProfessionalRolesSuggestsRequest) (*SuggestsProfessionalRoles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsProfessionalRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProfessionalRolesSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/professional_roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProlongationVacancyInfoRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetProlongationVacancyInfoRequest) HHUserAgent(hHUserAgent string) ApiGetProlongationVacancyInfoRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetProlongationVacancyInfoRequest) Locale(locale string) ApiGetProlongationVacancyInfoRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetProlongationVacancyInfoRequest) Host(host string) ApiGetProlongationVacancyInfoRequest {
	r.host = &host
	return r
}

func (r ApiGetProlongationVacancyInfoRequest) Execute() (*VacanciesVacancyProlongate, *http.Response, error) {
	return r.ApiService.GetProlongationVacancyInfoExecute(r)
}

/*
GetProlongationVacancyInfo Информация о возможности продления вакансии

Условия продления:

    * Стоимость продления вакансии равна стоимости новой публикации.
    * Стандартные вакансии можно продлевать, если с момента предыдущего продления прошло не менее 1 минуты.
    * Вакансии "стандарт-плюс" можно продлевать не ранее, чем за 7 дней до окончания срока публикации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetProlongationVacancyInfoRequest
*/
func (a *DefaultApiService) GetProlongationVacancyInfo(ctx context.Context, vacancyId string) ApiGetProlongationVacancyInfoRequest {
	return ApiGetProlongationVacancyInfoRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyProlongate
func (a *DefaultApiService) GetProlongationVacancyInfoExecute(r ApiGetProlongationVacancyInfoRequest) (*VacanciesVacancyProlongate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyProlongate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProlongationVacancyInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/prolongate"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProlongationVacancyInfo_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetProlongationVacancyInfo_0Request) HHUserAgent(hHUserAgent string) ApiGetProlongationVacancyInfo_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetProlongationVacancyInfo_0Request) Locale(locale string) ApiGetProlongationVacancyInfo_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetProlongationVacancyInfo_0Request) Host(host string) ApiGetProlongationVacancyInfo_0Request {
	r.host = &host
	return r
}

func (r ApiGetProlongationVacancyInfo_0Request) Execute() (*VacanciesVacancyProlongate, *http.Response, error) {
	return r.ApiService.GetProlongationVacancyInfo_19Execute(r)
}

/*
GetProlongationVacancyInfo_0 Информация о возможности продления вакансии

Условия продления:

    * Стоимость продления вакансии равна стоимости новой публикации.
    * Стандартные вакансии можно продлевать, если с момента предыдущего продления прошло не менее 1 минуты.
    * Вакансии "стандарт-плюс" можно продлевать не ранее, чем за 7 дней до окончания срока публикации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetProlongationVacancyInfo_0Request
*/
func (a *DefaultApiService) GetProlongationVacancyInfo_19(ctx context.Context, vacancyId string) ApiGetProlongationVacancyInfo_0Request {
	return ApiGetProlongationVacancyInfo_0Request{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyProlongate
func (a *DefaultApiService) GetProlongationVacancyInfo_19Execute(r ApiGetProlongationVacancyInfo_0Request) (*VacanciesVacancyProlongate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyProlongate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProlongationVacancyInfo_19")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/prolongate"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRegisteredCompaniesSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска организации. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetRegisteredCompaniesSuggestsRequest) Text(text string) ApiGetRegisteredCompaniesSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetRegisteredCompaniesSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetRegisteredCompaniesSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetRegisteredCompaniesSuggestsRequest) Locale(locale string) ApiGetRegisteredCompaniesSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetRegisteredCompaniesSuggestsRequest) Host(host string) ApiGetRegisteredCompaniesSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetRegisteredCompaniesSuggestsRequest) Execute() (*SuggestsCompanies, *http.Response, error) {
	return r.ApiService.GetRegisteredCompaniesSuggestsExecute(r)
}

/*
GetRegisteredCompaniesSuggests Подсказки по зарегистрированным организациям

Данные из этой подсказки можно использовать, например, для выбора компании при заполнении опыта работы [в резюме](#tag/Rezyume.-Sozdanie-i-obnovlenie). Чтобы найти организации, которые могут публиковать вакансии, используйте [поиск](#tag/Rabotodatel/operation/search-employer)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRegisteredCompaniesSuggestsRequest
*/
func (a *DefaultApiService) GetRegisteredCompaniesSuggests(ctx context.Context) ApiGetRegisteredCompaniesSuggestsRequest {
	return ApiGetRegisteredCompaniesSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsCompanies
func (a *DefaultApiService) GetRegisteredCompaniesSuggestsExecute(r ApiGetRegisteredCompaniesSuggestsRequest) (*SuggestsCompanies, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsCompanies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetRegisteredCompaniesSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/companies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	withNegotiationsHistory *bool
	withCreds *bool
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeRequest) HHUserAgent(hHUserAgent string) ApiGetResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле negotiations_history.vacancies.  Его формат подробно описан в методе [полной истории откликов/приглашений по резюме](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-resume-negotiations-history) и различается лишь тем,  что в данном случае список будет ограничен тремя вакансиями данного работодателя и последним изменением состояния отклика/приглашения по каждой из этих вакансий 
func (r ApiGetResumeRequest) WithNegotiationsHistory(withNegotiationsHistory bool) ApiGetResumeRequest {
	r.withNegotiationsHistory = &withNegotiationsHistory
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле creds
func (r ApiGetResumeRequest) WithCreds(withCreds bool) ApiGetResumeRequest {
	r.withCreds = &withCreds
	return r
}

// Параметр для просмотра в резюме статуса поиска кандидата 
func (r ApiGetResumeRequest) WithJobSearchStatus(withJobSearchStatus bool) ApiGetResumeRequest {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeRequest) Locale(locale string) ApiGetResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeRequest) Host(host string) ApiGetResumeRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeRequest) Execute() (*ResumeResumeViewResponse, *http.Response, error) {
	return r.ApiService.GetResumeExecute(r)
}

/*
GetResume Просмотр резюме

Возвращает информацию об указанном резюме.

Особенности работы метода при запросе от работодателя:

* Требуется наличие [платного доступа](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).
* При просмотре резюме с контактами действуют [специальные правила](https://github.com/hhru/api/blob/master/docs/payable/resume.md#просмотр-резюме-с-контактами).
* Если просмотр полных данных по резюме недоступен при текущей авторизации, в некоторых полях вернется `null`, а поле `can_view_full_info` будет иметь значение `false`.
* Если у работодателя есть отклик/приглашение на это резюме, отклик будет считаться просмотренным


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeRequest
*/
func (a *DefaultApiService) GetResume(ctx context.Context, resumeId string) ApiGetResumeRequest {
	return ApiGetResumeRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumeResumeViewResponse
func (a *DefaultApiService) GetResumeExecute(r ApiGetResumeRequest) (*ResumeResumeViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeResumeViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withNegotiationsHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_negotiations_history", r.withNegotiationsHistory, "")
	}
	if r.withCreds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_creds", r.withCreds, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsResumeTooManyRequestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeAccessTypesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeAccessTypesRequest) HHUserAgent(hHUserAgent string) ApiGetResumeAccessTypesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeAccessTypesRequest) Locale(locale string) ApiGetResumeAccessTypesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeAccessTypesRequest) Host(host string) ApiGetResumeAccessTypesRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeAccessTypesRequest) Execute() (*ResumesAccessTypes, *http.Response, error) {
	return r.ApiService.GetResumeAccessTypesExecute(r)
}

/*
GetResumeAccessTypes Получение списка типов видимости резюме

Некоторые типы видимости, например `whitelist` и `blacklist`, подразумевают наличие списка работодателей, для которых резюме должно быть видимо или скрыто. См. [управление списками видимости резюме](#tag/Rezyume.-Spiski-vidimosti)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeAccessTypesRequest
*/
func (a *DefaultApiService) GetResumeAccessTypes(ctx context.Context, resumeId string) ApiGetResumeAccessTypesRequest {
	return ApiGetResumeAccessTypesRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumesAccessTypes
func (a *DefaultApiService) GetResumeAccessTypesExecute(r ApiGetResumeAccessTypesRequest) (*ResumesAccessTypes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesAccessTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeAccessTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/access_types"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeConditionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeConditionsRequest) HHUserAgent(hHUserAgent string) ApiGetResumeConditionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeConditionsRequest) Locale(locale string) ApiGetResumeConditionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeConditionsRequest) Host(host string) ApiGetResumeConditionsRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeConditionsRequest) Execute() (*ResumesResumeConditions, *http.Response, error) {
	return r.ApiService.GetResumeConditionsExecute(r)
}

/*
GetResumeConditions Условия заполнения полей существующего резюме

Возвращает список требований для полей при заполнении указанного резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeConditionsRequest
*/
func (a *DefaultApiService) GetResumeConditions(ctx context.Context, resumeId string) ApiGetResumeConditionsRequest {
	return ApiGetResumeConditionsRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumesResumeConditions
func (a *DefaultApiService) GetResumeConditionsExecute(r ApiGetResumeConditionsRequest) (*ResumesResumeConditions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesResumeConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/conditions"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeCreationAvailabilityRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeCreationAvailabilityRequest) HHUserAgent(hHUserAgent string) ApiGetResumeCreationAvailabilityRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeCreationAvailabilityRequest) Locale(locale string) ApiGetResumeCreationAvailabilityRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeCreationAvailabilityRequest) Host(host string) ApiGetResumeCreationAvailabilityRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeCreationAvailabilityRequest) Execute() (*ResumesCreationAvailability, *http.Response, error) {
	return r.ApiService.GetResumeCreationAvailabilityExecute(r)
}

/*
GetResumeCreationAvailability Проверка возможности создания резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetResumeCreationAvailabilityRequest
*/
func (a *DefaultApiService) GetResumeCreationAvailability(ctx context.Context) ApiGetResumeCreationAvailabilityRequest {
	return ApiGetResumeCreationAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumesCreationAvailability
func (a *DefaultApiService) GetResumeCreationAvailabilityExecute(r ApiGetResumeCreationAvailabilityRequest) (*ResumesCreationAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesCreationAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeCreationAvailability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/creation_availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeNegotiationsHistoryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeNegotiationsHistoryRequest) HHUserAgent(hHUserAgent string) ApiGetResumeNegotiationsHistoryRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeNegotiationsHistoryRequest) Locale(locale string) ApiGetResumeNegotiationsHistoryRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeNegotiationsHistoryRequest) Host(host string) ApiGetResumeNegotiationsHistoryRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeNegotiationsHistoryRequest) Execute() (*ResumesResumeNegotiationsHistoryResponse, *http.Response, error) {
	return r.ApiService.GetResumeNegotiationsHistoryExecute(r)
}

/*
GetResumeNegotiationsHistory История откликов/приглашений по резюме

Возвращает последние действия с указанным резюме, ограниченные 30-ю вакансиями данного работодателя, и 10-ю изменениями состояний откликов/приглашений по каждой из этих вакансий.

Метод требует наличия [платного доступа для работодателя](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeNegotiationsHistoryRequest
*/
func (a *DefaultApiService) GetResumeNegotiationsHistory(ctx context.Context, resumeId string) ApiGetResumeNegotiationsHistoryRequest {
	return ApiGetResumeNegotiationsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumesResumeNegotiationsHistoryResponse
func (a *DefaultApiService) GetResumeNegotiationsHistoryExecute(r ApiGetResumeNegotiationsHistoryRequest) (*ResumesResumeNegotiationsHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesResumeNegotiationsHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeNegotiationsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/negotiations_history"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeSearchKeywordsSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска ключевого слова. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetResumeSearchKeywordsSuggestsRequest) Text(text string) ApiGetResumeSearchKeywordsSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeSearchKeywordsSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetResumeSearchKeywordsSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeSearchKeywordsSuggestsRequest) Locale(locale string) ApiGetResumeSearchKeywordsSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeSearchKeywordsSuggestsRequest) Host(host string) ApiGetResumeSearchKeywordsSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeSearchKeywordsSuggestsRequest) Execute() (*SuggestsSearchKeyword, *http.Response, error) {
	return r.ApiService.GetResumeSearchKeywordsSuggestsExecute(r)
}

/*
GetResumeSearchKeywordsSuggests Подсказки по ключевым словам поиска резюме

Предназначены для использования в поле `text` при [поиске резюме](#tag/Poisk-rezyume/operation/search-for-resumes). Содержит названия должностей, компаний и другие фразы, часто используемые при поиске резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetResumeSearchKeywordsSuggestsRequest
*/
func (a *DefaultApiService) GetResumeSearchKeywordsSuggests(ctx context.Context) ApiGetResumeSearchKeywordsSuggestsRequest {
	return ApiGetResumeSearchKeywordsSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsSearchKeyword
func (a *DefaultApiService) GetResumeSearchKeywordsSuggestsExecute(r ApiGetResumeSearchKeywordsSuggestsRequest) (*SuggestsSearchKeyword, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsSearchKeyword
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeSearchKeywordsSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/resume_search_keyword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeStatusRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeStatusRequest) HHUserAgent(hHUserAgent string) ApiGetResumeStatusRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeStatusRequest) Locale(locale string) ApiGetResumeStatusRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeStatusRequest) Host(host string) ApiGetResumeStatusRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeStatusRequest) Execute() (*ResumeStatusReadiness, *http.Response, error) {
	return r.ApiService.GetResumeStatusExecute(r)
}

/*
GetResumeStatus Статус резюме и готовность к публикации

Возвращает информацию о статусе резюме, готовности резюме к публикации, а также замечания модератора по выбранному резюме


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeStatusRequest
*/
func (a *DefaultApiService) GetResumeStatus(ctx context.Context, resumeId string) ApiGetResumeStatusRequest {
	return ApiGetResumeStatusRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumeStatusReadiness
func (a *DefaultApiService) GetResumeStatusExecute(r ApiGetResumeStatusRequest) (*ResumeStatusReadiness, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeStatusReadiness
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeViewHistoryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeViewHistoryRequest) HHUserAgent(hHUserAgent string) ApiGetResumeViewHistoryRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeViewHistoryRequest) Locale(locale string) ApiGetResumeViewHistoryRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeViewHistoryRequest) Host(host string) ApiGetResumeViewHistoryRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeViewHistoryRequest) Execute() (*ResumesResumeViewHistoryResponse, *http.Response, error) {
	return r.ApiService.GetResumeViewHistoryExecute(r)
}

/*
GetResumeViewHistory История просмотра резюме

Возвращает историю просмотров резюме.

Этот запрос обнуляет счетчик новых просмотров (поле `new_views`), который возвращается в запросах на просмотр [конкретного резюме](#tag/Prosmotr-rezyume/operation/get-resume) и [списка резюме](#tag/Rezyume.-Prosmotr-informacii/operation/get-mine-resumes)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResumeViewHistoryRequest
*/
func (a *DefaultApiService) GetResumeViewHistory(ctx context.Context, resumeId string) ApiGetResumeViewHistoryRequest {
	return ApiGetResumeViewHistoryRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumesResumeViewHistoryResponse
func (a *DefaultApiService) GetResumeViewHistoryExecute(r ApiGetResumeViewHistoryRequest) (*ResumesResumeViewHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesResumeViewHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeViewHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/views"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeVisibilityEmployersListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	listType string
	text *string
	hHUserAgent *string
	perPage *int32
	page *int32
	locale *string
	host *string
}

// Строка для поиска. Переданное значение ищется в начале названия работодателя и в начале названия департаментов работодателя
func (r ApiGetResumeVisibilityEmployersListRequest) Text(text string) ApiGetResumeVisibilityEmployersListRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeVisibilityEmployersListRequest) HHUserAgent(hHUserAgent string) ApiGetResumeVisibilityEmployersListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Количество элементов на странице выдачи. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). Значение по умолчанию и максимальное значение per_page составляет 100 
func (r ApiGetResumeVisibilityEmployersListRequest) PerPage(perPage int32) ApiGetResumeVisibilityEmployersListRequest {
	r.perPage = &perPage
	return r
}

// Порядковый номер страницы в выдаче. Поддерживаются [стандартные параметры пагинации](#section/Obshaya-informaciya/Paginaciya). По умолчанию нумерация начинается с 0 страницы 
func (r ApiGetResumeVisibilityEmployersListRequest) Page(page int32) ApiGetResumeVisibilityEmployersListRequest {
	r.page = &page
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeVisibilityEmployersListRequest) Locale(locale string) ApiGetResumeVisibilityEmployersListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeVisibilityEmployersListRequest) Host(host string) ApiGetResumeVisibilityEmployersListRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeVisibilityEmployersListRequest) Execute() (*ResumesResumeVisibilityListSearchResponse, *http.Response, error) {
	return r.ApiService.GetResumeVisibilityEmployersListExecute(r)
}

/*
GetResumeVisibilityEmployersList Поиск работодателей для добавления в список видимости

Возвращает результаты поиска работодателей

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @param listType Тип списка. Допустимые значения — `whitelist` или `blacklist`
 @return ApiGetResumeVisibilityEmployersListRequest
*/
func (a *DefaultApiService) GetResumeVisibilityEmployersList(ctx context.Context, resumeId string, listType string) ApiGetResumeVisibilityEmployersListRequest {
	return ApiGetResumeVisibilityEmployersListRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
		listType: listType,
	}
}

// Execute executes the request
//  @return ResumesResumeVisibilityListSearchResponse
func (a *DefaultApiService) GetResumeVisibilityEmployersListExecute(r ApiGetResumeVisibilityEmployersListRequest) (*ResumesResumeVisibilityListSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesResumeVisibilityListSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeVisibilityEmployersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/{list_type}/search"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list_type"+"}", url.PathEscape(parameterValueToString(r.listType, "listType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeVisibilityListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	listType string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumeVisibilityListRequest) HHUserAgent(hHUserAgent string) ApiGetResumeVisibilityListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumeVisibilityListRequest) Locale(locale string) ApiGetResumeVisibilityListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumeVisibilityListRequest) Host(host string) ApiGetResumeVisibilityListRequest {
	r.host = &host
	return r
}

func (r ApiGetResumeVisibilityListRequest) Execute() (*ResumesGetResumeVisibilityListResponse, *http.Response, error) {
	return r.ApiService.GetResumeVisibilityListExecute(r)
}

/*
GetResumeVisibilityList Получение списка видимости резюме

Возвращает список работодателей, для которых резюме должно быть видимо или скрыто


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @param listType Тип списка. Допустимые значения — `whitelist` или `blacklist`
 @return ApiGetResumeVisibilityListRequest
*/
func (a *DefaultApiService) GetResumeVisibilityList(ctx context.Context, resumeId string, listType string) ApiGetResumeVisibilityListRequest {
	return ApiGetResumeVisibilityListRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
		listType: listType,
	}
}

// Execute executes the request
//  @return ResumesGetResumeVisibilityListResponse
func (a *DefaultApiService) GetResumeVisibilityListExecute(r ApiGetResumeVisibilityListRequest) (*ResumesGetResumeVisibilityListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesGetResumeVisibilityListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumeVisibilityList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/{list_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list_type"+"}", url.PathEscape(parameterValueToString(r.listType, "listType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsResumeVisibilityErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResume_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	withNegotiationsHistory *bool
	withCreds *bool
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResume_0Request) HHUserAgent(hHUserAgent string) ApiGetResume_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле negotiations_history.vacancies.  Его формат подробно описан в методе [полной истории откликов/приглашений по резюме](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-resume-negotiations-history) и различается лишь тем,  что в данном случае список будет ограничен тремя вакансиями данного работодателя и последним изменением состояния отклика/приглашения по каждой из этих вакансий 
func (r ApiGetResume_0Request) WithNegotiationsHistory(withNegotiationsHistory bool) ApiGetResume_0Request {
	r.withNegotiationsHistory = &withNegotiationsHistory
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле creds
func (r ApiGetResume_0Request) WithCreds(withCreds bool) ApiGetResume_0Request {
	r.withCreds = &withCreds
	return r
}

// Параметр для просмотра в резюме статуса поиска кандидата 
func (r ApiGetResume_0Request) WithJobSearchStatus(withJobSearchStatus bool) ApiGetResume_0Request {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResume_0Request) Locale(locale string) ApiGetResume_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResume_0Request) Host(host string) ApiGetResume_0Request {
	r.host = &host
	return r
}

func (r ApiGetResume_0Request) Execute() (*ResumeResumeViewResponse, *http.Response, error) {
	return r.ApiService.GetResume_20Execute(r)
}

/*
GetResume_0 Просмотр резюме

Возвращает информацию об указанном резюме.

Особенности работы метода при запросе от работодателя:

* Требуется наличие [платного доступа](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).
* При просмотре резюме с контактами действуют [специальные правила](https://github.com/hhru/api/blob/master/docs/payable/resume.md#просмотр-резюме-с-контактами).
* Если просмотр полных данных по резюме недоступен при текущей авторизации, в некоторых полях вернется `null`, а поле `can_view_full_info` будет иметь значение `false`.
* Если у работодателя есть отклик/приглашение на это резюме, отклик будет считаться просмотренным


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResume_0Request
*/
func (a *DefaultApiService) GetResume_20(ctx context.Context, resumeId string) ApiGetResume_0Request {
	return ApiGetResume_0Request{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumeResumeViewResponse
func (a *DefaultApiService) GetResume_20Execute(r ApiGetResume_0Request) (*ResumeResumeViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeResumeViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResume_20")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withNegotiationsHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_negotiations_history", r.withNegotiationsHistory, "")
	}
	if r.withCreds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_creds", r.withCreds, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsResumeTooManyRequestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResume_1Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	withNegotiationsHistory *bool
	withCreds *bool
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResume_1Request) HHUserAgent(hHUserAgent string) ApiGetResume_1Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле negotiations_history.vacancies.  Его формат подробно описан в методе [полной истории откликов/приглашений по резюме](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-resume-negotiations-history) и различается лишь тем,  что в данном случае список будет ограничен тремя вакансиями данного работодателя и последним изменением состояния отклика/приглашения по каждой из этих вакансий 
func (r ApiGetResume_1Request) WithNegotiationsHistory(withNegotiationsHistory bool) ApiGetResume_1Request {
	r.withNegotiationsHistory = &withNegotiationsHistory
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле creds
func (r ApiGetResume_1Request) WithCreds(withCreds bool) ApiGetResume_1Request {
	r.withCreds = &withCreds
	return r
}

// Параметр для просмотра в резюме статуса поиска кандидата 
func (r ApiGetResume_1Request) WithJobSearchStatus(withJobSearchStatus bool) ApiGetResume_1Request {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResume_1Request) Locale(locale string) ApiGetResume_1Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResume_1Request) Host(host string) ApiGetResume_1Request {
	r.host = &host
	return r
}

func (r ApiGetResume_1Request) Execute() (*ResumeResumeViewResponse, *http.Response, error) {
	return r.ApiService.GetResume_21Execute(r)
}

/*
GetResume_1 Просмотр резюме

Возвращает информацию об указанном резюме.

Особенности работы метода при запросе от работодателя:

* Требуется наличие [платного доступа](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).
* При просмотре резюме с контактами действуют [специальные правила](https://github.com/hhru/api/blob/master/docs/payable/resume.md#просмотр-резюме-с-контактами).
* Если просмотр полных данных по резюме недоступен при текущей авторизации, в некоторых полях вернется `null`, а поле `can_view_full_info` будет иметь значение `false`.
* Если у работодателя есть отклик/приглашение на это резюме, отклик будет считаться просмотренным


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResume_1Request
*/
func (a *DefaultApiService) GetResume_21(ctx context.Context, resumeId string) ApiGetResume_1Request {
	return ApiGetResume_1Request{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumeResumeViewResponse
func (a *DefaultApiService) GetResume_21Execute(r ApiGetResume_1Request) (*ResumeResumeViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeResumeViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResume_21")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withNegotiationsHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_negotiations_history", r.withNegotiationsHistory, "")
	}
	if r.withCreds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_creds", r.withCreds, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsResumeTooManyRequestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResume_2Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	withNegotiationsHistory *bool
	withCreds *bool
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResume_2Request) HHUserAgent(hHUserAgent string) ApiGetResume_2Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле negotiations_history.vacancies.  Его формат подробно описан в методе [полной истории откликов/приглашений по резюме](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-resume-negotiations-history) и различается лишь тем,  что в данном случае список будет ограничен тремя вакансиями данного работодателя и последним изменением состояния отклика/приглашения по каждой из этих вакансий 
func (r ApiGetResume_2Request) WithNegotiationsHistory(withNegotiationsHistory bool) ApiGetResume_2Request {
	r.withNegotiationsHistory = &withNegotiationsHistory
	return r
}

// В случае, если передан данный параметр, в ответе добавится поле creds
func (r ApiGetResume_2Request) WithCreds(withCreds bool) ApiGetResume_2Request {
	r.withCreds = &withCreds
	return r
}

// Параметр для просмотра в резюме статуса поиска кандидата 
func (r ApiGetResume_2Request) WithJobSearchStatus(withJobSearchStatus bool) ApiGetResume_2Request {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResume_2Request) Locale(locale string) ApiGetResume_2Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResume_2Request) Host(host string) ApiGetResume_2Request {
	r.host = &host
	return r
}

func (r ApiGetResume_2Request) Execute() (*ResumeResumeViewResponse, *http.Response, error) {
	return r.ApiService.GetResume_22Execute(r)
}

/*
GetResume_2 Просмотр резюме

Возвращает информацию об указанном резюме.

Особенности работы метода при запросе от работодателя:

* Требуется наличие [платного доступа](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).
* При просмотре резюме с контактами действуют [специальные правила](https://github.com/hhru/api/blob/master/docs/payable/resume.md#просмотр-резюме-с-контактами).
* Если просмотр полных данных по резюме недоступен при текущей авторизации, в некоторых полях вернется `null`, а поле `can_view_full_info` будет иметь значение `false`.
* Если у работодателя есть отклик/приглашение на это резюме, отклик будет считаться просмотренным


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetResume_2Request
*/
func (a *DefaultApiService) GetResume_22(ctx context.Context, resumeId string) ApiGetResume_2Request {
	return ApiGetResume_2Request{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return ResumeResumeViewResponse
func (a *DefaultApiService) GetResume_22Execute(r ApiGetResume_2Request) (*ResumeResumeViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumeResumeViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResume_22")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withNegotiationsHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_negotiations_history", r.withNegotiationsHistory, "")
	}
	if r.withCreds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_creds", r.withCreds, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsResumeTooManyRequestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumesByStatusRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetResumesByStatusRequest) HHUserAgent(hHUserAgent string) ApiGetResumesByStatusRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetResumesByStatusRequest) Locale(locale string) ApiGetResumesByStatusRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetResumesByStatusRequest) Host(host string) ApiGetResumesByStatusRequest {
	r.host = &host
	return r
}

func (r ApiGetResumesByStatusRequest) Execute() (*ResumesByStatusResponse, *http.Response, error) {
	return r.ApiService.GetResumesByStatusExecute(r)
}

/*
GetResumesByStatus Резюме, сгруппированные по возможности отклика на данную вакансию

Возвращает резюме пользователя, сгруппированные в четыре списка в зависимости от возможности отклика на указанную вакансию

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetResumesByStatusRequest
*/
func (a *DefaultApiService) GetResumesByStatus(ctx context.Context, vacancyId string) ApiGetResumesByStatusRequest {
	return ApiGetResumesByStatusRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return ResumesByStatusResponse
func (a *DefaultApiService) GetResumesByStatusExecute(r ApiGetResumesByStatusRequest) (*ResumesByStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesByStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetResumesByStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/resumes_by_status"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalaryEmployeeLevelsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalaryEmployeeLevelsRequest) HHUserAgent(hHUserAgent string) ApiGetSalaryEmployeeLevelsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalaryEmployeeLevelsRequest) Locale(locale string) ApiGetSalaryEmployeeLevelsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalaryEmployeeLevelsRequest) Host(host string) ApiGetSalaryEmployeeLevelsRequest {
	r.host = &host
	return r
}

func (r ApiGetSalaryEmployeeLevelsRequest) Execute() ([]IncludesIdNameDesc, *http.Response, error) {
	return r.ApiService.GetSalaryEmployeeLevelsExecute(r)
}

/*
GetSalaryEmployeeLevels Уровни компетенций

Возвращает список уровней компетенций

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSalaryEmployeeLevelsRequest
*/
func (a *DefaultApiService) GetSalaryEmployeeLevels(ctx context.Context) ApiGetSalaryEmployeeLevelsRequest {
	return ApiGetSalaryEmployeeLevelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []IncludesIdNameDesc
func (a *DefaultApiService) GetSalaryEmployeeLevelsExecute(r ApiGetSalaryEmployeeLevelsRequest) ([]IncludesIdNameDesc, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []IncludesIdNameDesc
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalaryEmployeeLevels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/dictionaries/employee_levels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalaryEvaluationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	areaId string
	hHUserAgent *string
	excludeArea *string
	employeeLevel *string
	industry *string
	speciality *string
	extendSources *bool
	positionName *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalaryEvaluationRequest) HHUserAgent(hHUserAgent string) ApiGetSalaryEvaluationRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Коды [регионов](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-salary-areas), которые будут исключены из выборки для формирования отчета. Параметр позволяет получить оценку на региональном рынке за исключением определенных городов или областей 
func (r ApiGetSalaryEvaluationRequest) ExcludeArea(excludeArea string) ApiGetSalaryEvaluationRequest {
	r.excludeArea = &excludeArea
	return r
}

// Справочник [уровни компетенций](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-employee-levels), которые будут включены в выборку для формирования отчета 
func (r ApiGetSalaryEvaluationRequest) EmployeeLevel(employeeLevel string) ApiGetSalaryEvaluationRequest {
	r.employeeLevel = &employeeLevel
	return r
}

// Справочник [Коды отраслей](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-industries), по которым будет построена выборка для формирования отчета 
func (r ApiGetSalaryEvaluationRequest) Industry(industry string) ApiGetSalaryEvaluationRequest {
	r.industry = &industry
	return r
}

// Справочник [Коды профобластей и специализаций](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-professional-areas), которые будут включены в выборку для формирования отчета 
func (r ApiGetSalaryEvaluationRequest) Speciality(speciality string) ApiGetSalaryEvaluationRequest {
	r.speciality = &speciality
	return r
}

// Использовать ли данные из резюме и вакансий, если по указанным параметрам не нашлось данных в банке зарплат. По умолчанию — &#x60;false&#x60; 
func (r ApiGetSalaryEvaluationRequest) ExtendSources(extendSources bool) ApiGetSalaryEvaluationRequest {
	r.extendSources = &extendSources
	return r
}

// Наименование должности. Если не переданы параметры &#x60;speciality&#x60; или &#x60;employee_level&#x60;, сервис самостоятельно определит возможные специализации и уровень специалиста по указанной должности и отрасли, и построит отчет по ним 
func (r ApiGetSalaryEvaluationRequest) PositionName(positionName string) ApiGetSalaryEvaluationRequest {
	r.positionName = &positionName
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalaryEvaluationRequest) Locale(locale string) ApiGetSalaryEvaluationRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalaryEvaluationRequest) Host(host string) ApiGetSalaryEvaluationRequest {
	r.host = &host
	return r
}

func (r ApiGetSalaryEvaluationRequest) Execute() (*SalaryStatisticsEvaluationResponse, *http.Response, error) {
	return r.ApiService.GetSalaryEvaluationExecute(r)
}

/*
GetSalaryEvaluation Оценка заработной платы без прогноза

Возвращает статистику зарплат в соответствии с указанными параметрами запроса. Пользователь должен иметь доступ к платным отчетам [банка зарплат](https://salary.hh.ru/).

Как это работает:

* Основным источником данных для статистики служит информация о зарплатах, предоставляемая участниками проекта [Банк данных заработных плат](https://salary.hh.ru/promo).
* Все анкеты участников проходят проверку модераторами. Если заявленная участником зарплата сильно отличается от средней по рынку, она не будет включена в банк данных.
* Если в банке недостаточно данных для построения статистики по запросу, сервис использует следующие приемы:

    * Объединяет сведения из нескольких отраслей, если недостаточно данных по запрошенной отрасли.
    * Объединяет сведения из нескольких близких специализаций, если недостаточно данных по запрошенной специализации.
    * Объединяет сведения из нескольких городов, если недостаточно данных по запрошенному городу.
    * Использует сведения по запрошенным специализациям из другого региона, если недостаточно данных по запрошенному региону. При этом вычисляется поправочный коэффициент, который отражает разницу в зарплатах между регионами.

    Если эти приемы не позволяют получить достаточную выборку, сервис может использовать информацию о зарплатах из вакансий и резюме. Такая информация не проходит предварительную модерацию и считается менее надежной, поэтому используется только в крайнем случае. Чтобы использовать эту функцию, передайте в запросе параметр `extend_sources=true`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param areaId Код [региона](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-salary-areas), по которому будет построена выборка для формирования отчета 
 @return ApiGetSalaryEvaluationRequest
*/
func (a *DefaultApiService) GetSalaryEvaluation(ctx context.Context, areaId string) ApiGetSalaryEvaluationRequest {
	return ApiGetSalaryEvaluationRequest{
		ApiService: a,
		ctx: ctx,
		areaId: areaId,
	}
}

// Execute executes the request
//  @return SalaryStatisticsEvaluationResponse
func (a *DefaultApiService) GetSalaryEvaluationExecute(r ApiGetSalaryEvaluationRequest) (*SalaryStatisticsEvaluationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalaryStatisticsEvaluationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalaryEvaluation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/paid/salary_evaluation/{area_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"area_id"+"}", url.PathEscape(parameterValueToString(r.areaId, "areaId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.excludeArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_area", r.excludeArea, "")
	}
	if r.employeeLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employee_level", r.employeeLevel, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.speciality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speciality", r.speciality, "")
	}
	if r.extendSources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extend_sources", r.extendSources, "")
	}
	if r.positionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position_name", r.positionName, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadAuthorizationBadParameters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalaryEvaluation_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	areaId string
	hHUserAgent *string
	excludeArea *string
	employeeLevel *string
	industry *string
	speciality *string
	extendSources *bool
	positionName *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalaryEvaluation_0Request) HHUserAgent(hHUserAgent string) ApiGetSalaryEvaluation_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Коды [регионов](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-salary-areas), которые будут исключены из выборки для формирования отчета. Параметр позволяет получить оценку на региональном рынке за исключением определенных городов или областей 
func (r ApiGetSalaryEvaluation_0Request) ExcludeArea(excludeArea string) ApiGetSalaryEvaluation_0Request {
	r.excludeArea = &excludeArea
	return r
}

// Справочник [уровни компетенций](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-employee-levels), которые будут включены в выборку для формирования отчета 
func (r ApiGetSalaryEvaluation_0Request) EmployeeLevel(employeeLevel string) ApiGetSalaryEvaluation_0Request {
	r.employeeLevel = &employeeLevel
	return r
}

// Справочник [Коды отраслей](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-industries), по которым будет построена выборка для формирования отчета 
func (r ApiGetSalaryEvaluation_0Request) Industry(industry string) ApiGetSalaryEvaluation_0Request {
	r.industry = &industry
	return r
}

// Справочник [Коды профобластей и специализаций](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-professional-areas), которые будут включены в выборку для формирования отчета 
func (r ApiGetSalaryEvaluation_0Request) Speciality(speciality string) ApiGetSalaryEvaluation_0Request {
	r.speciality = &speciality
	return r
}

// Использовать ли данные из резюме и вакансий, если по указанным параметрам не нашлось данных в банке зарплат. По умолчанию — &#x60;false&#x60; 
func (r ApiGetSalaryEvaluation_0Request) ExtendSources(extendSources bool) ApiGetSalaryEvaluation_0Request {
	r.extendSources = &extendSources
	return r
}

// Наименование должности. Если не переданы параметры &#x60;speciality&#x60; или &#x60;employee_level&#x60;, сервис самостоятельно определит возможные специализации и уровень специалиста по указанной должности и отрасли, и построит отчет по ним 
func (r ApiGetSalaryEvaluation_0Request) PositionName(positionName string) ApiGetSalaryEvaluation_0Request {
	r.positionName = &positionName
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalaryEvaluation_0Request) Locale(locale string) ApiGetSalaryEvaluation_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalaryEvaluation_0Request) Host(host string) ApiGetSalaryEvaluation_0Request {
	r.host = &host
	return r
}

func (r ApiGetSalaryEvaluation_0Request) Execute() (*SalaryStatisticsEvaluationResponse, *http.Response, error) {
	return r.ApiService.GetSalaryEvaluation_23Execute(r)
}

/*
GetSalaryEvaluation_0 Оценка заработной платы без прогноза

Возвращает статистику зарплат в соответствии с указанными параметрами запроса. Пользователь должен иметь доступ к платным отчетам [банка зарплат](https://salary.hh.ru/).

Как это работает:

* Основным источником данных для статистики служит информация о зарплатах, предоставляемая участниками проекта [Банк данных заработных плат](https://salary.hh.ru/promo).
* Все анкеты участников проходят проверку модераторами. Если заявленная участником зарплата сильно отличается от средней по рынку, она не будет включена в банк данных.
* Если в банке недостаточно данных для построения статистики по запросу, сервис использует следующие приемы:

    * Объединяет сведения из нескольких отраслей, если недостаточно данных по запрошенной отрасли.
    * Объединяет сведения из нескольких близких специализаций, если недостаточно данных по запрошенной специализации.
    * Объединяет сведения из нескольких городов, если недостаточно данных по запрошенному городу.
    * Использует сведения по запрошенным специализациям из другого региона, если недостаточно данных по запрошенному региону. При этом вычисляется поправочный коэффициент, который отражает разницу в зарплатах между регионами.

    Если эти приемы не позволяют получить достаточную выборку, сервис может использовать информацию о зарплатах из вакансий и резюме. Такая информация не проходит предварительную модерацию и считается менее надежной, поэтому используется только в крайнем случае. Чтобы использовать эту функцию, передайте в запросе параметр `extend_sources=true`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param areaId Код [региона](#tag/Spravochniki-Banka-dannyh-zarabotnyh-plat/operation/get-salary-salary-areas), по которому будет построена выборка для формирования отчета 
 @return ApiGetSalaryEvaluation_0Request
*/
func (a *DefaultApiService) GetSalaryEvaluation_23(ctx context.Context, areaId string) ApiGetSalaryEvaluation_0Request {
	return ApiGetSalaryEvaluation_0Request{
		ApiService: a,
		ctx: ctx,
		areaId: areaId,
	}
}

// Execute executes the request
//  @return SalaryStatisticsEvaluationResponse
func (a *DefaultApiService) GetSalaryEvaluation_23Execute(r ApiGetSalaryEvaluation_0Request) (*SalaryStatisticsEvaluationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SalaryStatisticsEvaluationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalaryEvaluation_23")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/paid/salary_evaluation/{area_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"area_id"+"}", url.PathEscape(parameterValueToString(r.areaId, "areaId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.excludeArea != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_area", r.excludeArea, "")
	}
	if r.employeeLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employee_level", r.employeeLevel, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.speciality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speciality", r.speciality, "")
	}
	if r.extendSources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extend_sources", r.extendSources, "")
	}
	if r.positionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position_name", r.positionName, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadAuthorizationBadParameters
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalaryIndustriesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalaryIndustriesRequest) HHUserAgent(hHUserAgent string) ApiGetSalaryIndustriesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalaryIndustriesRequest) Locale(locale string) ApiGetSalaryIndustriesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalaryIndustriesRequest) Host(host string) ApiGetSalaryIndustriesRequest {
	r.host = &host
	return r
}

func (r ApiGetSalaryIndustriesRequest) Execute() ([]DictionariesBranchItem, *http.Response, error) {
	return r.ApiService.GetSalaryIndustriesExecute(r)
}

/*
GetSalaryIndustries Отрасли и сферы деятельности

Возвращает двухуровневый список отраслей и сфер деятельности

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSalaryIndustriesRequest
*/
func (a *DefaultApiService) GetSalaryIndustries(ctx context.Context) ApiGetSalaryIndustriesRequest {
	return ApiGetSalaryIndustriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesBranchItem
func (a *DefaultApiService) GetSalaryIndustriesExecute(r ApiGetSalaryIndustriesRequest) ([]DictionariesBranchItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesBranchItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalaryIndustries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/dictionaries/salary_industries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalaryProfessionalAreasRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalaryProfessionalAreasRequest) HHUserAgent(hHUserAgent string) ApiGetSalaryProfessionalAreasRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalaryProfessionalAreasRequest) Locale(locale string) ApiGetSalaryProfessionalAreasRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalaryProfessionalAreasRequest) Host(host string) ApiGetSalaryProfessionalAreasRequest {
	r.host = &host
	return r
}

func (r ApiGetSalaryProfessionalAreasRequest) Execute() ([]DictionariesSalaryStatisticsProfessionalAreasResponseInner, *http.Response, error) {
	return r.ApiService.GetSalaryProfessionalAreasExecute(r)
}

/*
GetSalaryProfessionalAreas Профобласти и специализации

Возвращает список профобластей и специализаций

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSalaryProfessionalAreasRequest
*/
func (a *DefaultApiService) GetSalaryProfessionalAreas(ctx context.Context) ApiGetSalaryProfessionalAreasRequest {
	return ApiGetSalaryProfessionalAreasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesSalaryStatisticsProfessionalAreasResponseInner
func (a *DefaultApiService) GetSalaryProfessionalAreasExecute(r ApiGetSalaryProfessionalAreasRequest) ([]DictionariesSalaryStatisticsProfessionalAreasResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesSalaryStatisticsProfessionalAreasResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalaryProfessionalAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/dictionaries/professional_areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSalarySalaryAreasRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSalarySalaryAreasRequest) HHUserAgent(hHUserAgent string) ApiGetSalarySalaryAreasRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSalarySalaryAreasRequest) Locale(locale string) ApiGetSalarySalaryAreasRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSalarySalaryAreasRequest) Host(host string) ApiGetSalarySalaryAreasRequest {
	r.host = &host
	return r
}

func (r ApiGetSalarySalaryAreasRequest) Execute() ([]DictionariesSalaryStatisticsAreaItem, *http.Response, error) {
	return r.ApiService.GetSalarySalaryAreasExecute(r)
}

/*
GetSalarySalaryAreas Регионы и города

Возвращает список регионов, областей и городов

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSalarySalaryAreasRequest
*/
func (a *DefaultApiService) GetSalarySalaryAreas(ctx context.Context) ApiGetSalarySalaryAreasRequest {
	return ApiGetSalarySalaryAreasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DictionariesSalaryStatisticsAreaItem
func (a *DefaultApiService) GetSalarySalaryAreasExecute(r ApiGetSalarySalaryAreasRequest) ([]DictionariesSalaryStatisticsAreaItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DictionariesSalaryStatisticsAreaItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSalarySalaryAreas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/salary_statistics/dictionaries/salary_areas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSavedResumeSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSavedResumeSearchRequest) HHUserAgent(hHUserAgent string) ApiGetSavedResumeSearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSavedResumeSearchRequest) Locale(locale string) ApiGetSavedResumeSearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSavedResumeSearchRequest) Host(host string) ApiGetSavedResumeSearchRequest {
	r.host = &host
	return r
}

func (r ApiGetSavedResumeSearchRequest) Execute() (*SavedSearchesSavedSearchItem, *http.Response, error) {
	return r.ApiService.GetSavedResumeSearchExecute(r)
}

/*
GetSavedResumeSearch Получение единичного сохраненного поиска резюме

Внимание: счетчик `new_items.count` обновляется раз в час. Из-за этого реальное количество новых найденных резюме 
может расходиться со значением этого счетчика


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска из [списка](#tag/Sohranennye-poiski-rezyume/operation/get-saved-resume-searches)
 @return ApiGetSavedResumeSearchRequest
*/
func (a *DefaultApiService) GetSavedResumeSearch(ctx context.Context, id string) ApiGetSavedResumeSearchRequest {
	return ApiGetSavedResumeSearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SavedSearchesSavedSearchItem
func (a *DefaultApiService) GetSavedResumeSearchExecute(r ApiGetSavedResumeSearchRequest) (*SavedSearchesSavedSearchItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavedSearchesSavedSearchItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSavedResumeSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSavedResumeSearchesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSavedResumeSearchesRequest) HHUserAgent(hHUserAgent string) ApiGetSavedResumeSearchesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiGetSavedResumeSearchesRequest) Page(page float32) ApiGetSavedResumeSearchesRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию - 5, максимальное значение - 10)
func (r ApiGetSavedResumeSearchesRequest) PerPage(perPage float32) ApiGetSavedResumeSearchesRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSavedResumeSearchesRequest) Locale(locale string) ApiGetSavedResumeSearchesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSavedResumeSearchesRequest) Host(host string) ApiGetSavedResumeSearchesRequest {
	r.host = &host
	return r
}

func (r ApiGetSavedResumeSearchesRequest) Execute() (*SavedSearchesSavedSearchResponse, *http.Response, error) {
	return r.ApiService.GetSavedResumeSearchesExecute(r)
}

/*
GetSavedResumeSearches Список сохраненных поисков резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSavedResumeSearchesRequest
*/
func (a *DefaultApiService) GetSavedResumeSearches(ctx context.Context) ApiGetSavedResumeSearchesRequest {
	return ApiGetSavedResumeSearchesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SavedSearchesSavedSearchResponse
func (a *DefaultApiService) GetSavedResumeSearchesExecute(r ApiGetSavedResumeSearchesRequest) (*SavedSearchesSavedSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavedSearchesSavedSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSavedResumeSearches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSavedVacancySearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSavedVacancySearchRequest) HHUserAgent(hHUserAgent string) ApiGetSavedVacancySearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSavedVacancySearchRequest) Locale(locale string) ApiGetSavedVacancySearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSavedVacancySearchRequest) Host(host string) ApiGetSavedVacancySearchRequest {
	r.host = &host
	return r
}

func (r ApiGetSavedVacancySearchRequest) Execute() (*SavedSearchesSavedSearchItem, *http.Response, error) {
	return r.ApiService.GetSavedVacancySearchExecute(r)
}

/*
GetSavedVacancySearch Получение единичного сохраненного поиска вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска
 @return ApiGetSavedVacancySearchRequest
*/
func (a *DefaultApiService) GetSavedVacancySearch(ctx context.Context, id string) ApiGetSavedVacancySearchRequest {
	return ApiGetSavedVacancySearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SavedSearchesSavedSearchItem
func (a *DefaultApiService) GetSavedVacancySearchExecute(r ApiGetSavedVacancySearchRequest) (*SavedSearchesSavedSearchItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavedSearchesSavedSearchItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSavedVacancySearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/vacancies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSavedVacancySearchesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSavedVacancySearchesRequest) HHUserAgent(hHUserAgent string) ApiGetSavedVacancySearchesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiGetSavedVacancySearchesRequest) Page(page float32) ApiGetSavedVacancySearchesRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию - 10, максимальное значение - 10)
func (r ApiGetSavedVacancySearchesRequest) PerPage(perPage float32) ApiGetSavedVacancySearchesRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSavedVacancySearchesRequest) Locale(locale string) ApiGetSavedVacancySearchesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSavedVacancySearchesRequest) Host(host string) ApiGetSavedVacancySearchesRequest {
	r.host = &host
	return r
}

func (r ApiGetSavedVacancySearchesRequest) Execute() (*SavedSearchesSavedSearchResponse, *http.Response, error) {
	return r.ApiService.GetSavedVacancySearchesExecute(r)
}

/*
GetSavedVacancySearches Список сохраненных поисков вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSavedVacancySearchesRequest
*/
func (a *DefaultApiService) GetSavedVacancySearches(ctx context.Context) ApiGetSavedVacancySearchesRequest {
	return ApiGetSavedVacancySearchesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SavedSearchesSavedSearchResponse
func (a *DefaultApiService) GetSavedVacancySearchesExecute(r ApiGetSavedVacancySearchesRequest) (*SavedSearchesSavedSearchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SavedSearchesSavedSearchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSavedVacancySearches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/vacancies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSkillSetSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска ключевых навыков. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetSkillSetSuggestsRequest) Text(text string) ApiGetSkillSetSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSkillSetSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetSkillSetSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSkillSetSuggestsRequest) Locale(locale string) ApiGetSkillSetSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSkillSetSuggestsRequest) Host(host string) ApiGetSkillSetSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetSkillSetSuggestsRequest) Execute() (*SuggestsSkillSet, *http.Response, error) {
	return r.ApiService.GetSkillSetSuggestsExecute(r)
}

/*
GetSkillSetSuggests Подсказки по ключевым навыкам

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSkillSetSuggestsRequest
*/
func (a *DefaultApiService) GetSkillSetSuggests(ctx context.Context) ApiGetSkillSetSuggestsRequest {
	return ApiGetSkillSetSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsSkillSet
func (a *DefaultApiService) GetSkillSetSuggestsExecute(r ApiGetSkillSetSuggestsRequest) (*SuggestsSkillSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsSkillSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSkillSetSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/skill_set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSkillsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id *string
	hHUserAgent *string
	locale *string
	host *string
}

// Идентификаторы ключевых навыков. Идентификатор конкретного навыка можно узнать по [подсказке](#tag/Podskazki/operation/get-skill-set-suggests). Передать можно не более 50 значений. Например: &#x60;?id&#x3D;2716&amp;id&#x3D;3019&amp;id&#x3D;0&#x60;. Если был передан идентификатор несуществующего ключевого навыка, для него не вернется никакой информации
func (r ApiGetSkillsRequest) Id(id string) ApiGetSkillsRequest {
	r.id = &id
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSkillsRequest) HHUserAgent(hHUserAgent string) ApiGetSkillsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSkillsRequest) Locale(locale string) ApiGetSkillsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSkillsRequest) Host(host string) ApiGetSkillsRequest {
	r.host = &host
	return r
}

func (r ApiGetSkillsRequest) Execute() (*DictionariesSkillsResponse, *http.Response, error) {
	return r.ApiService.GetSkillsExecute(r)
}

/*
GetSkills Справочник ключевых навыков

Метод возвращает информацию по запрашиваемым ключевым навыкам.

Значения в справочнике могут поменяться в любой момент


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSkillsRequest
*/
func (a *DefaultApiService) GetSkills(ctx context.Context) ApiGetSkillsRequest {
	return ApiGetSkillsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DictionariesSkillsResponse
func (a *DefaultApiService) GetSkillsExecute(r ApiGetSkillsRequest) (*DictionariesSkillsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DictionariesSkillsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSkills")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/skills"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSuitableResumesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetSuitableResumesRequest) HHUserAgent(hHUserAgent string) ApiGetSuitableResumesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetSuitableResumesRequest) Locale(locale string) ApiGetSuitableResumesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetSuitableResumesRequest) Host(host string) ApiGetSuitableResumesRequest {
	r.host = &host
	return r
}

func (r ApiGetSuitableResumesRequest) Execute() (*ResumesSuitableResumesResponse, *http.Response, error) {
	return r.ApiService.GetSuitableResumesExecute(r)
}

/*
GetSuitableResumes Список подходящих для отклика резюме

Возвращает список сокращенных представлений резюме соискателя, которыми он может откликнуться на указанную вакансию.

В качестве альтернативы данному методу можно использовать метод [resumes_by_status](#tag/Rezyume.-Prosmotr-informacii/operation/get-resumes-by-status)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetSuitableResumesRequest
*/
func (a *DefaultApiService) GetSuitableResumes(ctx context.Context, vacancyId string) ApiGetSuitableResumesRequest {
	return ApiGetSuitableResumesRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return ResumesSuitableResumesResponse
func (a *DefaultApiService) GetSuitableResumesExecute(r ApiGetSuitableResumesRequest) (*ResumesSuitableResumesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesSuitableResumesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSuitableResumes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/suitable_resumes"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestsDictionaryRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetTestsDictionaryRequest) HHUserAgent(hHUserAgent string) ApiGetTestsDictionaryRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetTestsDictionaryRequest) Locale(locale string) ApiGetTestsDictionaryRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetTestsDictionaryRequest) Host(host string) ApiGetTestsDictionaryRequest {
	r.host = &host
	return r
}

func (r ApiGetTestsDictionaryRequest) Execute() (*EmployerDictionariesTestsResponse, *http.Response, error) {
	return r.ApiService.GetTestsDictionaryExecute(r)
}

/*
GetTestsDictionary Справочник тестов работодателя

Возвращает список сохраненных тестов работодателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetTestsDictionaryRequest
*/
func (a *DefaultApiService) GetTestsDictionary(ctx context.Context, employerId string) ApiGetTestsDictionaryRequest {
	return ApiGetTestsDictionaryRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerDictionariesTestsResponse
func (a *DefaultApiService) GetTestsDictionaryExecute(r ApiGetTestsDictionaryRequest) (*EmployerDictionariesTestsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerDictionariesTestsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTestsDictionary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/tests"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTestsDictionary_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetTestsDictionary_0Request) HHUserAgent(hHUserAgent string) ApiGetTestsDictionary_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetTestsDictionary_0Request) Locale(locale string) ApiGetTestsDictionary_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetTestsDictionary_0Request) Host(host string) ApiGetTestsDictionary_0Request {
	r.host = &host
	return r
}

func (r ApiGetTestsDictionary_0Request) Execute() (*EmployerDictionariesTestsResponse, *http.Response, error) {
	return r.ApiService.GetTestsDictionary_24Execute(r)
}

/*
GetTestsDictionary_0 Справочник тестов работодателя

Возвращает список сохраненных тестов работодателя

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetTestsDictionary_0Request
*/
func (a *DefaultApiService) GetTestsDictionary_24(ctx context.Context, employerId string) ApiGetTestsDictionary_0Request {
	return ApiGetTestsDictionary_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployerDictionariesTestsResponse
func (a *DefaultApiService) GetTestsDictionary_24Execute(r ApiGetTestsDictionary_0Request) (*EmployerDictionariesTestsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployerDictionariesTestsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTestsDictionary_24")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/tests"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacanciesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	text *string
	searchField *string
	experience *string
	employment *string
	schedule *string
	area *string
	metro *string
	professionalRole *string
	industry *string
	employerId *string
	currency *string
	salary *float32
	label *string
	onlyWithSalary *bool
	period *float32
	dateFrom *string
	dateTo *string
	topLat *float32
	bottomLat *float32
	leftLng *float32
	rightLng *float32
	orderBy *string
	sortPointLat *float32
	sortPointLng *float32
	clusters *bool
	describeArguments *bool
	noMagic *bool
	premium *bool
	responsesCountEnabled *bool
	partTime *string
	acceptTemporary *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacanciesRequest) HHUserAgent(hHUserAgent string) ApiGetVacanciesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetVacanciesRequest) Page(page float32) ApiGetVacanciesRequest {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetVacanciesRequest) PerPage(perPage float32) ApiGetVacanciesRequest {
	r.perPage = &perPage
	return r
}

// Переданное значение ищется в полях вакансии, указанных в параметре &#x60;search_field&#x60;. Доступен [язык запросов](https://hh.ru/article/1175). Специально для этого поля есть [автодополнение](#tag/Podskazki/operation/get-vacancy-search-keywords)
func (r ApiGetVacanciesRequest) Text(text string) ApiGetVacanciesRequest {
	r.text = &text
	return r
}

// Область поиска. Справочник с возможными значениями: &#x60;vacancy_search_fields&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). По умолчанию, используются все поля. Можно указать несколько значений 
func (r ApiGetVacanciesRequest) SearchField(searchField string) ApiGetVacanciesRequest {
	r.searchField = &searchField
	return r
}

// Опыт работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;experience&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Experience(experience string) ApiGetVacanciesRequest {
	r.experience = &experience
	return r
}

// Тип занятости. Необходимо передавать &#x60;id&#x60; из справочника &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Employment(employment string) ApiGetVacanciesRequest {
	r.employment = &employment
	return r
}

// График работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;schedule&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Schedule(schedule string) ApiGetVacanciesRequest {
	r.schedule = &schedule
	return r
}

// Регион. Необходимо передавать &#x60;id&#x60; из справочника [/areas](#tag/Obshie-spravochniki/operation/get-areas). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Area(area string) ApiGetVacanciesRequest {
	r.area = &area
	return r
}

// Ветка или станция метро. Необходимо передавать &#x60;id&#x60; из справочника [/metro](#tag/Obshie-spravochniki/operation/get-metro-stations). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Metro(metro string) ApiGetVacanciesRequest {
	r.metro = &metro
	return r
}

// Профессиональная область. Необходимо передавать &#x60;id&#x60; из справочника [/professional_roles](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary) 
func (r ApiGetVacanciesRequest) ProfessionalRole(professionalRole string) ApiGetVacanciesRequest {
	r.professionalRole = &professionalRole
	return r
}

// Индустрия компании, разместившей вакансию. Необходимо передавать &#x60;id&#x60; из справочника [/industries](#tag/Obshie-spravochniki/operation/get-industries). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Industry(industry string) ApiGetVacanciesRequest {
	r.industry = &industry
	return r
}

// Идентификатор [работодателя](#tag/Rabotodatel). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) EmployerId(employerId string) ApiGetVacanciesRequest {
	r.employerId = &employerId
	return r
}

// Код валюты. Справочник с возможными значениями: &#x60;currency&#x60; (ключ &#x60;code&#x60;) в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Имеет смысл указывать только совместно с параметром &#x60;salary&#x60; 
func (r ApiGetVacanciesRequest) Currency(currency string) ApiGetVacanciesRequest {
	r.currency = &currency
	return r
}

// Размер заработной платы. Если указано это поле, но не указано &#x60;currency&#x60;, то для &#x60;currency&#x60; используется значение RUR. При указании значения будут найдены вакансии, в которых вилка зарплаты близка к указанной в запросе. При этом значения пересчитываются по текущим курсам ЦБ РФ. Например, при указании &#x60;salary&#x3D;100&amp;currency&#x3D;EUR&#x60; будут найдены вакансии, где вилка зарплаты указана в рублях и после пересчёта в Евро близка к 100 EUR. По умолчанию будут также найдены вакансии, в которых вилка зарплаты не указана, чтобы такие вакансии отфильтровать, используйте &#x60;only_with_salary&#x3D;true&#x60; 
func (r ApiGetVacanciesRequest) Salary(salary float32) ApiGetVacanciesRequest {
	r.salary = &salary
	return r
}

// Фильтр по меткам вакансий. Необходимо передавать &#x60;id&#x60; из справочника &#x60;vacancy_label&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesRequest) Label(label string) ApiGetVacanciesRequest {
	r.label = &label
	return r
}

// Показывать вакансии только с указанием зарплаты. По умолчанию &#x60;false&#x60; 
func (r ApiGetVacanciesRequest) OnlyWithSalary(onlyWithSalary bool) ApiGetVacanciesRequest {
	r.onlyWithSalary = &onlyWithSalary
	return r
}

// Количество дней, в пределах которых производится поиск по вакансиям 
func (r ApiGetVacanciesRequest) Period(period float32) ApiGetVacanciesRequest {
	r.period = &period
	return r
}

// Дата, которая ограничивает снизу диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesRequest) DateFrom(dateFrom string) ApiGetVacanciesRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, которая ограничивает сверху диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesRequest) DateTo(dateTo string) ApiGetVacanciesRequest {
	r.dateTo = &dateTo
	return r
}

// Верхняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesRequest) TopLat(topLat float32) ApiGetVacanciesRequest {
	r.topLat = &topLat
	return r
}

// Нижняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesRequest) BottomLat(bottomLat float32) ApiGetVacanciesRequest {
	r.bottomLat = &bottomLat
	return r
}

// Левая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesRequest) LeftLng(leftLng float32) ApiGetVacanciesRequest {
	r.leftLng = &leftLng
	return r
}

// Правая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesRequest) RightLng(rightLng float32) ApiGetVacanciesRequest {
	r.rightLng = &rightLng
	return r
}

// Сортировка списка вакансий. Справочник с возможными значениями: &#x60;vacancy_search_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Если выбрана сортировка по удалённости от гео-точки &#x60;distance&#x60;, необходимо также задать её координаты: &#x60;sort_point_lat&#x60;, &#x60;sort_point_lng&#x60; 
func (r ApiGetVacanciesRequest) OrderBy(orderBy string) ApiGetVacanciesRequest {
	r.orderBy = &orderBy
	return r
}

// Значение географической широты точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesRequest) SortPointLat(sortPointLat float32) ApiGetVacanciesRequest {
	r.sortPointLat = &sortPointLat
	return r
}

// Значение географической долготы точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesRequest) SortPointLng(sortPointLng float32) ApiGetVacanciesRequest {
	r.sortPointLng = &sortPointLng
	return r
}

// Возвращать ли [кластеры для данного поиска](#tag/Poisk-vakansij/Klastery-v-poiske-vakansij). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesRequest) Clusters(clusters bool) ApiGetVacanciesRequest {
	r.clusters = &clusters
	return r
}

// Возвращать ли описание использованных параметров поиска (массив &#x60;arguments&#x60;). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesRequest) DescribeArguments(describeArguments bool) ApiGetVacanciesRequest {
	r.describeArguments = &describeArguments
	return r
}

// Если значение &#x60;true&#x60; — автоматическое преобразование вакансий отключено. По умолчанию – false. При включённом автоматическом преобразовании, будет предпринята попытка изменить текстовый запрос пользователя на набор параметров. Например, запрос &#x60;text&#x3D;москва бухгалтер 100500&#x60; будет преобразован в &#x60;text&#x3D;бухгалтер&amp;only_with_salary&#x3D;true&amp;area&#x3D;1&amp;salary&#x3D;100500&#x60; 
func (r ApiGetVacanciesRequest) NoMagic(noMagic bool) ApiGetVacanciesRequest {
	r.noMagic = &noMagic
	return r
}

// Если значение &#x60;true&#x60; — в сортировке вакансий будет учтены премиум вакансии. Такая сортировка используется на сайте. По умолчанию — false 
func (r ApiGetVacanciesRequest) Premium(premium bool) ApiGetVacanciesRequest {
	r.premium = &premium
	return r
}

// Если значение &#x60;true&#x60; — дополнительное поле &#x60;counters&#x60; с количеством откликов для вакансии включено. По-умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesRequest) ResponsesCountEnabled(responsesCountEnabled bool) ApiGetVacanciesRequest {
	r.responsesCountEnabled = &responsesCountEnabled
	return r
}

// Вакансии для подработки. Возможные значения: * Все элементы из &#x60;working_days&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_intervals&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_modes&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элементы &#x60;part&#x60; или &#x60;project&#x60; из &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элемент &#x60;accept_temporary&#x60;, показывает вакансии только с временным трудоустройством. Можно указать несколько значений 
func (r ApiGetVacanciesRequest) PartTime(partTime string) ApiGetVacanciesRequest {
	r.partTime = &partTime
	return r
}

// Если значение &#x60;true&#x60; — то поиск происходит только по вакансиям временной работы. По-умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesRequest) AcceptTemporary(acceptTemporary bool) ApiGetVacanciesRequest {
	r.acceptTemporary = &acceptTemporary
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacanciesRequest) Locale(locale string) ApiGetVacanciesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacanciesRequest) Host(host string) ApiGetVacanciesRequest {
	r.host = &host
	return r
}

func (r ApiGetVacanciesRequest) Execute() (*VacanciesVacanciesResponse, *http.Response, error) {
	return r.ApiService.GetVacanciesExecute(r)
}

/*
GetVacancies Поиск по вакансиям

Возвращает список вакансий, размещенных в сервисе. Список вакансий фильтруется согласно переданным параметрам запроса.

Особенности работы метода:

* Неизвестные параметры и параметры с ошибкой в названии игнорируются.
* Если не передан токен авторизации, то после первого запроса будет предложено пройти капчу.
* Список вакансий зависит от типа авторизации пользователя. Например, для соискателей вакансии фильтруются по [списку скрытых вакансий](#tag/Skrytye-vakansii) и [списку скрытых компаний](#tag/Skrytye-rabotodateli).
* Список вакансий также зависит от [выбранного сайта](#section/Obshaya-informaciya/Vybor-sajta) (параметр `host`). Однако выбор регионального сайта, например hh.kz, не ограничивает список вакансиями данного региона. Чтобы ограничить список по региону, используйте параметр `area`.
* При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше `2000`. Например, возможен запрос `per_page=10&page=199` (выдача с `1991` по `2000` вакансию), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с `2001` по `2010` вакансию)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVacanciesRequest
*/
func (a *DefaultApiService) GetVacancies(ctx context.Context) ApiGetVacanciesRequest {
	return ApiGetVacanciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacanciesVacanciesResponse
func (a *DefaultApiService) GetVacanciesExecute(r ApiGetVacanciesRequest) (*VacanciesVacanciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacanciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 10
		r.perPage = &defaultValue
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_field", r.searchField, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.employerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employer_id", r.employerId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary", r.salary, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.onlyWithSalary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_with_salary", r.onlyWithSalary, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.topLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_lat", r.topLat, "")
	}
	if r.bottomLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bottom_lat", r.bottomLat, "")
	}
	if r.leftLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "left_lng", r.leftLng, "")
	}
	if r.rightLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right_lng", r.rightLng, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.sortPointLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lat", r.sortPointLat, "")
	}
	if r.sortPointLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lng", r.sortPointLng, "")
	}
	if r.clusters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", r.clusters, "")
	}
	if r.describeArguments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe_arguments", r.describeArguments, "")
	}
	if r.noMagic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_magic", r.noMagic, "")
	}
	if r.premium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "premium", r.premium, "")
	}
	if r.responsesCountEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responses_count_enabled", r.responsesCountEnabled, "")
	}
	if r.partTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part_time", r.partTime, "")
	}
	if r.acceptTemporary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accept_temporary", r.acceptTemporary, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonCaptchaErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacanciesSimilarToResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	page *float32
	perPage *float32
	text *string
	searchField *string
	experience *string
	employment *string
	schedule *string
	area *string
	metro *string
	professionalRole *string
	industry *string
	employerId *string
	currency *string
	salary *float32
	label *string
	onlyWithSalary *bool
	period *float32
	dateFrom *string
	dateTo *string
	topLat *float32
	bottomLat *float32
	leftLng *float32
	rightLng *float32
	orderBy *string
	sortPointLat *float32
	sortPointLng *float32
	clusters *bool
	describeArguments *bool
	noMagic *bool
	premium *bool
	responsesCountEnabled *bool
	partTime *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacanciesSimilarToResumeRequest) HHUserAgent(hHUserAgent string) ApiGetVacanciesSimilarToResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiGetVacanciesSimilarToResumeRequest) Page(page float32) ApiGetVacanciesSimilarToResumeRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию - 10, максимальное значение - 100)
func (r ApiGetVacanciesSimilarToResumeRequest) PerPage(perPage float32) ApiGetVacanciesSimilarToResumeRequest {
	r.perPage = &perPage
	return r
}

// Переданное значение ищется в полях вакансии, указанных в параметре &#x60;search_field&#x60;. Доступен [язык запросов](https://hh.ru/article/1175). Специально для этого поля есть [автодополнение](#tag/Podskazki/operation/get-vacancy-search-keywords)
func (r ApiGetVacanciesSimilarToResumeRequest) Text(text string) ApiGetVacanciesSimilarToResumeRequest {
	r.text = &text
	return r
}

// Область поиска. Справочник с возможными значениями: &#x60;vacancy_search_fields&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). По умолчанию, используются все поля. Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) SearchField(searchField string) ApiGetVacanciesSimilarToResumeRequest {
	r.searchField = &searchField
	return r
}

// Опыт работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;experience&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Experience(experience string) ApiGetVacanciesSimilarToResumeRequest {
	r.experience = &experience
	return r
}

// Тип занятости. Необходимо передавать &#x60;id&#x60; из справочника &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Employment(employment string) ApiGetVacanciesSimilarToResumeRequest {
	r.employment = &employment
	return r
}

// График работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;schedule&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Schedule(schedule string) ApiGetVacanciesSimilarToResumeRequest {
	r.schedule = &schedule
	return r
}

// Регион. Необходимо передавать &#x60;id&#x60; из справочника [/areas](#tag/Obshie-spravochniki/operation/get-areas). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Area(area string) ApiGetVacanciesSimilarToResumeRequest {
	r.area = &area
	return r
}

// Ветка или станция метро. Необходимо передавать &#x60;id&#x60; из справочника [/metro](#tag/Obshie-spravochniki/operation/get-metro-stations). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Metro(metro string) ApiGetVacanciesSimilarToResumeRequest {
	r.metro = &metro
	return r
}

// Профессиональная область. Необходимо передавать &#x60;id&#x60; из справочника [/professional_roles](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary) 
func (r ApiGetVacanciesSimilarToResumeRequest) ProfessionalRole(professionalRole string) ApiGetVacanciesSimilarToResumeRequest {
	r.professionalRole = &professionalRole
	return r
}

// Индустрия компании, разместившей вакансию. Необходимо передавать &#x60;id&#x60; из справочника [/industries](#tag/Obshie-spravochniki/operation/get-industries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Industry(industry string) ApiGetVacanciesSimilarToResumeRequest {
	r.industry = &industry
	return r
}

// Идентификатор [работодателя](#tag/Rabotodatel). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) EmployerId(employerId string) ApiGetVacanciesSimilarToResumeRequest {
	r.employerId = &employerId
	return r
}

// Код валюты. Справочник с возможными значениями: &#x60;currency&#x60; (ключ &#x60;code&#x60;) в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Имеет смысл указывать только совместно с параметром &#x60;salary&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) Currency(currency string) ApiGetVacanciesSimilarToResumeRequest {
	r.currency = &currency
	return r
}

// Размер заработной платы. Если указано это поле, но не указано &#x60;currency&#x60;, то для &#x60;currency&#x60; используется значение RUR. При указании значения будут найдены вакансии, в которых вилка зарплаты близка к указанной в запросе. При этом значения пересчитываются по текущим курсам ЦБ РФ. Например, при указании &#x60;salary&#x3D;100&amp;currency&#x3D;EUR&#x60; будут найдены вакансии, где вилка зарплаты указана в рублях и после пересчёта в Евро близка к 100 EUR. По умолчанию будут также найдены вакансии, в которых вилка зарплаты не указана, чтобы такие вакансии отфильтровать, используйте &#x60;only_with_salary&#x3D;true&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) Salary(salary float32) ApiGetVacanciesSimilarToResumeRequest {
	r.salary = &salary
	return r
}

// Фильтр по меткам вакансий. Необходимо передавать &#x60;id&#x60; из справочника &#x60;vacancy_label&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) Label(label string) ApiGetVacanciesSimilarToResumeRequest {
	r.label = &label
	return r
}

// Показывать вакансии только с указанием зарплаты. По умолчанию &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) OnlyWithSalary(onlyWithSalary bool) ApiGetVacanciesSimilarToResumeRequest {
	r.onlyWithSalary = &onlyWithSalary
	return r
}

// Количество дней, в пределах которых производится поиск по вакансиям 
func (r ApiGetVacanciesSimilarToResumeRequest) Period(period float32) ApiGetVacanciesSimilarToResumeRequest {
	r.period = &period
	return r
}

// Дата, которая ограничивает снизу диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesSimilarToResumeRequest) DateFrom(dateFrom string) ApiGetVacanciesSimilarToResumeRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, которая ограничивает сверху диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesSimilarToResumeRequest) DateTo(dateTo string) ApiGetVacanciesSimilarToResumeRequest {
	r.dateTo = &dateTo
	return r
}

// Верхняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToResumeRequest) TopLat(topLat float32) ApiGetVacanciesSimilarToResumeRequest {
	r.topLat = &topLat
	return r
}

// Нижняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToResumeRequest) BottomLat(bottomLat float32) ApiGetVacanciesSimilarToResumeRequest {
	r.bottomLat = &bottomLat
	return r
}

// Левая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToResumeRequest) LeftLng(leftLng float32) ApiGetVacanciesSimilarToResumeRequest {
	r.leftLng = &leftLng
	return r
}

// Правая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToResumeRequest) RightLng(rightLng float32) ApiGetVacanciesSimilarToResumeRequest {
	r.rightLng = &rightLng
	return r
}

// Сортировка списка вакансий. Справочник с возможными значениями: &#x60;vacancy_search_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Если выбрана сортировка по удалённости от гео-точки &#x60;distance&#x60;, необходимо также задать её координаты: &#x60;sort_point_lat&#x60;, &#x60;sort_point_lng&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) OrderBy(orderBy string) ApiGetVacanciesSimilarToResumeRequest {
	r.orderBy = &orderBy
	return r
}

// Значение географической широты точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) SortPointLat(sortPointLat float32) ApiGetVacanciesSimilarToResumeRequest {
	r.sortPointLat = &sortPointLat
	return r
}

// Значение географической долготы точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) SortPointLng(sortPointLng float32) ApiGetVacanciesSimilarToResumeRequest {
	r.sortPointLng = &sortPointLng
	return r
}

// Возвращать ли [кластеры для данного поиска](#tag/Poisk-vakansij/Klastery-v-poiske-vakansij). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) Clusters(clusters bool) ApiGetVacanciesSimilarToResumeRequest {
	r.clusters = &clusters
	return r
}

// Возвращать ли описание использованных параметров поиска. Успешный ответ будет содержать поле [&#x60;arguments&#x60;]((#tag/Poisk-vakansij/operation/get-vacancies))). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) DescribeArguments(describeArguments bool) ApiGetVacanciesSimilarToResumeRequest {
	r.describeArguments = &describeArguments
	return r
}

// Если значение &#x60;true&#x60; — автоматическое преобразование вакансий отключено. По умолчанию – false. При включённом автоматическом преобразовании, будет предпринята попытка изменить текстовый запрос пользователя на набор параметров. Например, запрос &#x60;text&#x3D;москва бухгалтер 100500&#x60; будет преобразован в &#x60;text&#x3D;бухгалтер&amp;only_with_salary&#x3D;true&amp;area&#x3D;1&amp;salary&#x3D;100500&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) NoMagic(noMagic bool) ApiGetVacanciesSimilarToResumeRequest {
	r.noMagic = &noMagic
	return r
}

// Если значение &#x60;true&#x60; — в сортировке вакансий будет учтены премиум вакансии. Такая сортировка используется на сайте. По умолчанию — false 
func (r ApiGetVacanciesSimilarToResumeRequest) Premium(premium bool) ApiGetVacanciesSimilarToResumeRequest {
	r.premium = &premium
	return r
}

// Если значение &#x60;true&#x60; — дополнительное поле &#x60;counters&#x60; с количеством откликов для вакансии включено. По-умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToResumeRequest) ResponsesCountEnabled(responsesCountEnabled bool) ApiGetVacanciesSimilarToResumeRequest {
	r.responsesCountEnabled = &responsesCountEnabled
	return r
}

// Вакансии для подработки. Возможные значения: * Все элементы из &#x60;working_days&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_intervals&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_modes&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элементы &#x60;part&#x60; или &#x60;project&#x60; из &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элемент &#x60;accept_temporary&#x60;, показывает вакансии только с временным трудоустройством. Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToResumeRequest) PartTime(partTime string) ApiGetVacanciesSimilarToResumeRequest {
	r.partTime = &partTime
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacanciesSimilarToResumeRequest) Locale(locale string) ApiGetVacanciesSimilarToResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacanciesSimilarToResumeRequest) Host(host string) ApiGetVacanciesSimilarToResumeRequest {
	r.host = &host
	return r
}

func (r ApiGetVacanciesSimilarToResumeRequest) Execute() (*VacanciesVacanciesResponse, *http.Response, error) {
	return r.ApiService.GetVacanciesSimilarToResumeExecute(r)
}

/*
GetVacanciesSimilarToResume Поиск по вакансиям, похожим на резюме

Данные доступны только автору резюме.

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше `2000`. Например, возможен запрос `per_page=10&page=199` (выдача с `1991` по `2000` вакансию), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с `2001` по `2010` вакансию)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiGetVacanciesSimilarToResumeRequest
*/
func (a *DefaultApiService) GetVacanciesSimilarToResume(ctx context.Context, resumeId string) ApiGetVacanciesSimilarToResumeRequest {
	return ApiGetVacanciesSimilarToResumeRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
//  @return VacanciesVacanciesResponse
func (a *DefaultApiService) GetVacanciesSimilarToResumeExecute(r ApiGetVacanciesSimilarToResumeRequest) (*VacanciesVacanciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacanciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacanciesSimilarToResume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/similar_vacancies"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_field", r.searchField, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.employerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employer_id", r.employerId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary", r.salary, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.onlyWithSalary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_with_salary", r.onlyWithSalary, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.topLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_lat", r.topLat, "")
	}
	if r.bottomLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bottom_lat", r.bottomLat, "")
	}
	if r.leftLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "left_lng", r.leftLng, "")
	}
	if r.rightLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right_lng", r.rightLng, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.sortPointLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lat", r.sortPointLat, "")
	}
	if r.sortPointLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lng", r.sortPointLng, "")
	}
	if r.clusters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", r.clusters, "")
	}
	if r.describeArguments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe_arguments", r.describeArguments, "")
	}
	if r.noMagic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_magic", r.noMagic, "")
	}
	if r.premium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "premium", r.premium, "")
	}
	if r.responsesCountEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responses_count_enabled", r.responsesCountEnabled, "")
	}
	if r.partTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part_time", r.partTime, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacanciesSimilarToVacancyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	page *float32
	perPage *float32
	text *string
	searchField *string
	experience *string
	employment *string
	schedule *string
	area *string
	metro *string
	professionalRole *string
	industry *string
	employerId *string
	currency *string
	salary *float32
	label *string
	onlyWithSalary *bool
	period *float32
	dateFrom *string
	dateTo *string
	topLat *float32
	bottomLat *float32
	leftLng *float32
	rightLng *float32
	orderBy *string
	sortPointLat *float32
	sortPointLng *float32
	clusters *bool
	describeArguments *bool
	noMagic *bool
	premium *bool
	responsesCountEnabled *bool
	partTime *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacanciesSimilarToVacancyRequest) HHUserAgent(hHUserAgent string) ApiGetVacanciesSimilarToVacancyRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы
func (r ApiGetVacanciesSimilarToVacancyRequest) Page(page float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.page = &page
	return r
}

// Количество элементов
func (r ApiGetVacanciesSimilarToVacancyRequest) PerPage(perPage float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.perPage = &perPage
	return r
}

// Переданное значение ищется в полях вакансии, указанных в параметре &#x60;search_field&#x60;. Доступен [язык запросов](https://hh.ru/article/1175). Специально для этого поля есть [автодополнение](#tag/Podskazki/operation/get-vacancy-search-keywords)
func (r ApiGetVacanciesSimilarToVacancyRequest) Text(text string) ApiGetVacanciesSimilarToVacancyRequest {
	r.text = &text
	return r
}

// Область поиска. Справочник с возможными значениями: &#x60;vacancy_search_fields&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). По умолчанию, используются все поля. Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) SearchField(searchField string) ApiGetVacanciesSimilarToVacancyRequest {
	r.searchField = &searchField
	return r
}

// Опыт работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;experience&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Experience(experience string) ApiGetVacanciesSimilarToVacancyRequest {
	r.experience = &experience
	return r
}

// Тип занятости. Необходимо передавать &#x60;id&#x60; из справочника &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Employment(employment string) ApiGetVacanciesSimilarToVacancyRequest {
	r.employment = &employment
	return r
}

// График работы. Необходимо передавать &#x60;id&#x60; из справочника &#x60;schedule&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Schedule(schedule string) ApiGetVacanciesSimilarToVacancyRequest {
	r.schedule = &schedule
	return r
}

// Регион. Необходимо передавать &#x60;id&#x60; из справочника [/areas](#tag/Obshie-spravochniki/operation/get-areas). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Area(area string) ApiGetVacanciesSimilarToVacancyRequest {
	r.area = &area
	return r
}

// Ветка или станция метро. Необходимо передавать &#x60;id&#x60; из справочника [/metro](#tag/Obshie-spravochniki/operation/get-metro-stations). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Metro(metro string) ApiGetVacanciesSimilarToVacancyRequest {
	r.metro = &metro
	return r
}

// Профессиональная область. Необходимо передавать &#x60;id&#x60; из справочника [/professional_roles](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary) 
func (r ApiGetVacanciesSimilarToVacancyRequest) ProfessionalRole(professionalRole string) ApiGetVacanciesSimilarToVacancyRequest {
	r.professionalRole = &professionalRole
	return r
}

// Индустрия компании, разместившей вакансию. Необходимо передавать &#x60;id&#x60; из справочника [/industries](#tag/Obshie-spravochniki/operation/get-industries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Industry(industry string) ApiGetVacanciesSimilarToVacancyRequest {
	r.industry = &industry
	return r
}

// Идентификатор [работодателя](#tag/Rabotodatel). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) EmployerId(employerId string) ApiGetVacanciesSimilarToVacancyRequest {
	r.employerId = &employerId
	return r
}

// Код валюты. Справочник с возможными значениями: &#x60;currency&#x60; (ключ &#x60;code&#x60;) в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Имеет смысл указывать только совместно с параметром &#x60;salary&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) Currency(currency string) ApiGetVacanciesSimilarToVacancyRequest {
	r.currency = &currency
	return r
}

// Размер заработной платы. Если указано это поле, но не указано &#x60;currency&#x60;, то для &#x60;currency&#x60; используется значение RUR. При указании значения будут найдены вакансии, в которых вилка зарплаты близка к указанной в запросе. При этом значения пересчитываются по текущим курсам ЦБ РФ. Например, при указании &#x60;salary&#x3D;100&amp;currency&#x3D;EUR&#x60; будут найдены вакансии, где вилка зарплаты указана в рублях и после пересчёта в Евро близка к 100 EUR. По умолчанию будут также найдены вакансии, в которых вилка зарплаты не указана, чтобы такие вакансии отфильтровать, используйте &#x60;only_with_salary&#x3D;true&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) Salary(salary float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.salary = &salary
	return r
}

// Фильтр по меткам вакансий. Необходимо передавать &#x60;id&#x60; из справочника &#x60;vacancy_label&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) Label(label string) ApiGetVacanciesSimilarToVacancyRequest {
	r.label = &label
	return r
}

// Показывать вакансии только с указанием зарплаты. По умолчанию &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) OnlyWithSalary(onlyWithSalary bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.onlyWithSalary = &onlyWithSalary
	return r
}

// Количество дней, в пределах которых производится поиск по вакансиям 
func (r ApiGetVacanciesSimilarToVacancyRequest) Period(period float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.period = &period
	return r
}

// Дата, которая ограничивает снизу диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesSimilarToVacancyRequest) DateFrom(dateFrom string) ApiGetVacanciesSimilarToVacancyRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, которая ограничивает сверху диапазон дат публикации вакансий. Нельзя передавать вместе с параметром &#x60;period&#x60;. Значение указывается в формате &#x60;ISO 8601 - YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Указанное значение будет округлено до ближайших пяти минут 
func (r ApiGetVacanciesSimilarToVacancyRequest) DateTo(dateTo string) ApiGetVacanciesSimilarToVacancyRequest {
	r.dateTo = &dateTo
	return r
}

// Верхняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToVacancyRequest) TopLat(topLat float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.topLat = &topLat
	return r
}

// Нижняя граница широты. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToVacancyRequest) BottomLat(bottomLat float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.bottomLat = &bottomLat
	return r
}

// Левая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToVacancyRequest) LeftLng(leftLng float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.leftLng = &leftLng
	return r
}

// Правая граница долготы. При поиске используется значение указанного в вакансии адреса. Принимаемое значение — градусы в виде десятичной дроби. Необходимо передавать одновременно все четыре параметра гео-координат, иначе вернется ошибка 
func (r ApiGetVacanciesSimilarToVacancyRequest) RightLng(rightLng float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.rightLng = &rightLng
	return r
}

// Сортировка списка вакансий. Справочник с возможными значениями: &#x60;vacancy_search_order&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). Если выбрана сортировка по удалённости от гео-точки &#x60;distance&#x60;, необходимо также задать её координаты: &#x60;sort_point_lat&#x60;, &#x60;sort_point_lng&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) OrderBy(orderBy string) ApiGetVacanciesSimilarToVacancyRequest {
	r.orderBy = &orderBy
	return r
}

// Значение географической широты точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) SortPointLat(sortPointLat float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.sortPointLat = &sortPointLat
	return r
}

// Значение географической долготы точки, по расстоянию от которой будут отсортированы вакансии. Необходимо указывать только, если &#x60;order_by&#x60; установлено в &#x60;distance&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) SortPointLng(sortPointLng float32) ApiGetVacanciesSimilarToVacancyRequest {
	r.sortPointLng = &sortPointLng
	return r
}

// Возвращать ли [кластеры для данного поиска](#tag/Poisk-vakansij/Klastery-v-poiske-vakansij). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) Clusters(clusters bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.clusters = &clusters
	return r
}

// Возвращать ли описание использованных параметров поиска. Успешный ответ будет содержать поле [&#x60;arguments&#x60;]((#tag/Poisk-vakansij/operation/get-vacancies))). По умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) DescribeArguments(describeArguments bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.describeArguments = &describeArguments
	return r
}

// Если значение &#x60;true&#x60; — автоматическое преобразование вакансий отключено. По умолчанию – false. При включённом автоматическом преобразовании, будет предпринята попытка изменить текстовый запрос пользователя на набор параметров. Например, запрос &#x60;text&#x3D;москва бухгалтер 100500&#x60; будет преобразован в &#x60;text&#x3D;бухгалтер&amp;only_with_salary&#x3D;true&amp;area&#x3D;1&amp;salary&#x3D;100500&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) NoMagic(noMagic bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.noMagic = &noMagic
	return r
}

// Если значение &#x60;true&#x60; — в сортировке вакансий будет учтены премиум вакансии. Такая сортировка используется на сайте. По умолчанию — false 
func (r ApiGetVacanciesSimilarToVacancyRequest) Premium(premium bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.premium = &premium
	return r
}

// Если значение &#x60;true&#x60; — дополнительное поле &#x60;counters&#x60; с количеством откликов для вакансии включено. По-умолчанию — &#x60;false&#x60; 
func (r ApiGetVacanciesSimilarToVacancyRequest) ResponsesCountEnabled(responsesCountEnabled bool) ApiGetVacanciesSimilarToVacancyRequest {
	r.responsesCountEnabled = &responsesCountEnabled
	return r
}

// Вакансии для подработки. Возможные значения: * Все элементы из &#x60;working_days&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_intervals&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Все элементы из &#x60;working_time_modes&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элементы &#x60;part&#x60; или &#x60;project&#x60; из &#x60;employment&#x60; в [/dictionaries](#tag/Obshie-spravochniki/operation/get-dictionaries). * Элемент &#x60;accept_temporary&#x60;, показывает вакансии только с временным трудоустройством. Можно указать несколько значений 
func (r ApiGetVacanciesSimilarToVacancyRequest) PartTime(partTime string) ApiGetVacanciesSimilarToVacancyRequest {
	r.partTime = &partTime
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacanciesSimilarToVacancyRequest) Locale(locale string) ApiGetVacanciesSimilarToVacancyRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacanciesSimilarToVacancyRequest) Host(host string) ApiGetVacanciesSimilarToVacancyRequest {
	r.host = &host
	return r
}

func (r ApiGetVacanciesSimilarToVacancyRequest) Execute() (*VacanciesVacanciesResponse, *http.Response, error) {
	return r.ApiService.GetVacanciesSimilarToVacancyExecute(r)
}

/*
GetVacanciesSimilarToVacancy Поиск по вакансиям, похожим на вакансию

Если не передан токен авторизации, то после первого запроса будет предложено пройти капчу.

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше `2000`. Например, возможен запрос `per_page=10&page=199` (выдача с `1991` по `2000` вакансию), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с `2001` по `2010` вакансию)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacanciesSimilarToVacancyRequest
*/
func (a *DefaultApiService) GetVacanciesSimilarToVacancy(ctx context.Context, vacancyId string) ApiGetVacanciesSimilarToVacancyRequest {
	return ApiGetVacanciesSimilarToVacancyRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacanciesResponse
func (a *DefaultApiService) GetVacanciesSimilarToVacancyExecute(r ApiGetVacanciesSimilarToVacancyRequest) (*VacanciesVacanciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacanciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacanciesSimilarToVacancy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/similar_vacancies"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue float32 = 0
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue float32 = 10
		r.perPage = &defaultValue
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.searchField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_field", r.searchField, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.industry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "industry", r.industry, "")
	}
	if r.employerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employer_id", r.employerId, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary", r.salary, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.onlyWithSalary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_with_salary", r.onlyWithSalary, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.topLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "top_lat", r.topLat, "")
	}
	if r.bottomLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bottom_lat", r.bottomLat, "")
	}
	if r.leftLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "left_lng", r.leftLng, "")
	}
	if r.rightLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "right_lng", r.rightLng, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.sortPointLat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lat", r.sortPointLat, "")
	}
	if r.sortPointLng != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_point_lng", r.sortPointLng, "")
	}
	if r.clusters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clusters", r.clusters, "")
	}
	if r.describeArguments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "describe_arguments", r.describeArguments, "")
	}
	if r.noMagic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "no_magic", r.noMagic, "")
	}
	if r.premium != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "premium", r.premium, "")
	}
	if r.responsesCountEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "responses_count_enabled", r.responsesCountEnabled, "")
	}
	if r.partTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "part_time", r.partTime, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonCaptchaErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyRequest) Locale(locale string) ApiGetVacancyRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyRequest) Host(host string) ApiGetVacancyRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyRequest) Execute() (*VacanciesVacancy, *http.Response, error) {
	return r.ApiService.GetVacancyExecute(r)
}

/*
GetVacancy Просмотр вакансии

Возвращает подробную информацию по указанной вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacancyRequest
*/
func (a *DefaultApiService) GetVacancy(ctx context.Context, vacancyId string) ApiGetVacancyRequest {
	return ApiGetVacancyRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancy
func (a *DefaultApiService) GetVacancyExecute(r ApiGetVacancyRequest) (*VacanciesVacancy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonCaptchaErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyBrandedTemplatesListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyBrandedTemplatesListRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyBrandedTemplatesListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyBrandedTemplatesListRequest) Locale(locale string) ApiGetVacancyBrandedTemplatesListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyBrandedTemplatesListRequest) Host(host string) ApiGetVacancyBrandedTemplatesListRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyBrandedTemplatesListRequest) Execute() (*EmployersVacancyBrandedTemplatesList, *http.Response, error) {
	return r.ApiService.GetVacancyBrandedTemplatesListExecute(r)
}

/*
GetVacancyBrandedTemplatesList Список доступных бренд шаблонов вакансий работодателя

Внимание! Значения в справочниках могут поменяться в любой момент. Не нужно завязываться на них.

Использование брендированных шаблонов вакансии доступно работодателям, оплатившим и активировавшим соответствующую 
услугу. Подробнее на сайте [hh.ru](https://hh.ru/article/brand)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetVacancyBrandedTemplatesListRequest
*/
func (a *DefaultApiService) GetVacancyBrandedTemplatesList(ctx context.Context, employerId string) ApiGetVacancyBrandedTemplatesListRequest {
	return ApiGetVacancyBrandedTemplatesListRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersVacancyBrandedTemplatesList
func (a *DefaultApiService) GetVacancyBrandedTemplatesListExecute(r ApiGetVacancyBrandedTemplatesListRequest) (*EmployersVacancyBrandedTemplatesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersVacancyBrandedTemplatesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyBrandedTemplatesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancy_branded_templates"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyBrandedTemplatesList_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyBrandedTemplatesList_0Request) HHUserAgent(hHUserAgent string) ApiGetVacancyBrandedTemplatesList_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyBrandedTemplatesList_0Request) Locale(locale string) ApiGetVacancyBrandedTemplatesList_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyBrandedTemplatesList_0Request) Host(host string) ApiGetVacancyBrandedTemplatesList_0Request {
	r.host = &host
	return r
}

func (r ApiGetVacancyBrandedTemplatesList_0Request) Execute() (*EmployersVacancyBrandedTemplatesList, *http.Response, error) {
	return r.ApiService.GetVacancyBrandedTemplatesList_25Execute(r)
}

/*
GetVacancyBrandedTemplatesList_0 Список доступных бренд шаблонов вакансий работодателя

Внимание! Значения в справочниках могут поменяться в любой момент. Не нужно завязываться на них.

Использование брендированных шаблонов вакансии доступно работодателям, оплатившим и активировавшим соответствующую 
услугу. Подробнее на сайте [hh.ru](https://hh.ru/article/brand)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @return ApiGetVacancyBrandedTemplatesList_0Request
*/
func (a *DefaultApiService) GetVacancyBrandedTemplatesList_25(ctx context.Context, employerId string) ApiGetVacancyBrandedTemplatesList_0Request {
	return ApiGetVacancyBrandedTemplatesList_0Request{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
	}
}

// Execute executes the request
//  @return EmployersVacancyBrandedTemplatesList
func (a *DefaultApiService) GetVacancyBrandedTemplatesList_25Execute(r ApiGetVacancyBrandedTemplatesList_0Request) (*EmployersVacancyBrandedTemplatesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersVacancyBrandedTemplatesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyBrandedTemplatesList_25")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancy_branded_templates"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyConditionsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyConditionsRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyConditionsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyConditionsRequest) Locale(locale string) ApiGetVacancyConditionsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyConditionsRequest) Host(host string) ApiGetVacancyConditionsRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyConditionsRequest) Execute() (*VacanciesVacancyConditions, *http.Response, error) {
	return r.ApiService.GetVacancyConditionsExecute(r)
}

/*
GetVacancyConditions Условия заполнения полей при добавлении и редактировании вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVacancyConditionsRequest
*/
func (a *DefaultApiService) GetVacancyConditions(ctx context.Context) ApiGetVacancyConditionsRequest {
	return ApiGetVacancyConditionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacanciesVacancyConditions
func (a *DefaultApiService) GetVacancyConditionsExecute(r ApiGetVacancyConditionsRequest) (*VacanciesVacancyConditions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyConditions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyConditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancy_conditions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyDraftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyDraftRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyDraftRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyDraftRequest) Locale(locale string) ApiGetVacancyDraftRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyDraftRequest) Host(host string) ApiGetVacancyDraftRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyDraftRequest) Execute() (*VacancyDraftVacancyDraftFull, *http.Response, error) {
	return r.ApiService.GetVacancyDraftExecute(r)
}

/*
GetVacancyDraft Получение черновика вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param draftId Идентификатор черновика
 @return ApiGetVacancyDraftRequest
*/
func (a *DefaultApiService) GetVacancyDraft(ctx context.Context, draftId string) ApiGetVacancyDraftRequest {
	return ApiGetVacancyDraftRequest{
		ApiService: a,
		ctx: ctx,
		draftId: draftId,
	}
}

// Execute executes the request
//  @return VacancyDraftVacancyDraftFull
func (a *DefaultApiService) GetVacancyDraftExecute(r ApiGetVacancyDraftRequest) (*VacancyDraftVacancyDraftFull, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDraftVacancyDraftFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts/{draft_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"draft_id"+"}", url.PathEscape(parameterValueToString(r.draftId, "draftId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyDraftListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyDraftListRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyDraftListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию - 0)
func (r ApiGetVacancyDraftListRequest) Page(page float32) ApiGetVacancyDraftListRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию - 20, максимальное значение - 50)
func (r ApiGetVacancyDraftListRequest) PerPage(perPage float32) ApiGetVacancyDraftListRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyDraftListRequest) Locale(locale string) ApiGetVacancyDraftListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyDraftListRequest) Host(host string) ApiGetVacancyDraftListRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyDraftListRequest) Execute() (*VacancyDraftVacancyDraftItems, *http.Response, error) {
	return r.ApiService.GetVacancyDraftListExecute(r)
}

/*
GetVacancyDraftList Получение списка черновиков вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVacancyDraftListRequest
*/
func (a *DefaultApiService) GetVacancyDraftList(ctx context.Context) ApiGetVacancyDraftListRequest {
	return ApiGetVacancyDraftListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VacancyDraftVacancyDraftItems
func (a *DefaultApiService) GetVacancyDraftListExecute(r ApiGetVacancyDraftListRequest) (*VacancyDraftVacancyDraftItems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDraftVacancyDraftItems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyDraftList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyPositionsSuggestsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска должности в вакансии. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetVacancyPositionsSuggestsRequest) Text(text string) ApiGetVacancyPositionsSuggestsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyPositionsSuggestsRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyPositionsSuggestsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyPositionsSuggestsRequest) Locale(locale string) ApiGetVacancyPositionsSuggestsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyPositionsSuggestsRequest) Host(host string) ApiGetVacancyPositionsSuggestsRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyPositionsSuggestsRequest) Execute() (*SuggestsVacancyPositions, *http.Response, error) {
	return r.ApiService.GetVacancyPositionsSuggestsExecute(r)
}

/*
GetVacancyPositionsSuggests Подсказки по должностям вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVacancyPositionsSuggestsRequest
*/
func (a *DefaultApiService) GetVacancyPositionsSuggests(ctx context.Context) ApiGetVacancyPositionsSuggestsRequest {
	return ApiGetVacancyPositionsSuggestsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsVacancyPositions
func (a *DefaultApiService) GetVacancyPositionsSuggestsExecute(r ApiGetVacancyPositionsSuggestsRequest) (*SuggestsVacancyPositions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsVacancyPositions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyPositionsSuggests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/vacancy_positions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancySearchKeywordsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	text *string
	hHUserAgent *string
	locale *string
	host *string
}

// Текст для поиска ключевого слова. Искомый текст должен быть длиной два или более символа и не более 3 000 символов
func (r ApiGetVacancySearchKeywordsRequest) Text(text string) ApiGetVacancySearchKeywordsRequest {
	r.text = &text
	return r
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancySearchKeywordsRequest) HHUserAgent(hHUserAgent string) ApiGetVacancySearchKeywordsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancySearchKeywordsRequest) Locale(locale string) ApiGetVacancySearchKeywordsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancySearchKeywordsRequest) Host(host string) ApiGetVacancySearchKeywordsRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancySearchKeywordsRequest) Execute() (*SuggestsSearchKeyword, *http.Response, error) {
	return r.ApiService.GetVacancySearchKeywordsExecute(r)
}

/*
GetVacancySearchKeywords Подсказки по ключевым словам поиска вакансий

Предназначены для использования в поле `text` при [поиске вакансий](#tag/Poisk-vakansij/operation/get-vacancies). Содержит названия должностей, компаний и другие фразы, часто используемые при поиске вакансий

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVacancySearchKeywordsRequest
*/
func (a *DefaultApiService) GetVacancySearchKeywords(ctx context.Context) ApiGetVacancySearchKeywordsRequest {
	return ApiGetVacancySearchKeywordsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SuggestsSearchKeyword
func (a *DefaultApiService) GetVacancySearchKeywordsExecute(r ApiGetVacancySearchKeywordsRequest) (*SuggestsSearchKeyword, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuggestsSearchKeyword
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancySearchKeywords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/suggests/vacancy_search_keyword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SuggestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyStatsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyStatsRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyStatsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyStatsRequest) Locale(locale string) ApiGetVacancyStatsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyStatsRequest) Host(host string) ApiGetVacancyStatsRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyStatsRequest) Execute() (*VacanciesVacancyStatsResponse, *http.Response, error) {
	return r.ApiService.GetVacancyStatsExecute(r)
}

/*
GetVacancyStats Статистика по вакансии

Возвращает статистику за последние пять дней существования вакансии.

При этом:

* Если вакансия создана менее пяти дней назад, то первой датой в ответе будет дата создания вакансии. Для будущих дат в полях `responses` и `views` вернется `null`.
* Если вакансия находится в архиве или удалена, то последней датой будет дата архивации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacancyStatsRequest
*/
func (a *DefaultApiService) GetVacancyStats(ctx context.Context, vacancyId string) ApiGetVacancyStatsRequest {
	return ApiGetVacancyStatsRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyStatsResponse
func (a *DefaultApiService) GetVacancyStatsExecute(r ApiGetVacancyStatsRequest) (*VacanciesVacancyStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyUpgradeListRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyUpgradeListRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyUpgradeListRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyUpgradeListRequest) Locale(locale string) ApiGetVacancyUpgradeListRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyUpgradeListRequest) Host(host string) ApiGetVacancyUpgradeListRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyUpgradeListRequest) Execute() (*VacanciesVacancyUpgradeListResponse, *http.Response, error) {
	return r.ApiService.GetVacancyUpgradeListExecute(r)
}

/*
GetVacancyUpgradeList Список улучшений для вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacancyUpgradeListRequest
*/
func (a *DefaultApiService) GetVacancyUpgradeList(ctx context.Context, vacancyId string) ApiGetVacancyUpgradeListRequest {
	return ApiGetVacancyUpgradeListRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancyUpgradeListResponse
func (a *DefaultApiService) GetVacancyUpgradeListExecute(r ApiGetVacancyUpgradeListRequest) (*VacanciesVacancyUpgradeListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancyUpgradeListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyUpgradeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/upgrades"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancyVisitorsRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancyVisitorsRequest) HHUserAgent(hHUserAgent string) ApiGetVacancyVisitorsRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Номер страницы (считается от 0, по умолчанию — 0)
func (r ApiGetVacancyVisitorsRequest) Page(page float32) ApiGetVacancyVisitorsRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию — 20, максимальное значение — 50)
func (r ApiGetVacancyVisitorsRequest) PerPage(perPage float32) ApiGetVacancyVisitorsRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancyVisitorsRequest) Locale(locale string) ApiGetVacancyVisitorsRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancyVisitorsRequest) Host(host string) ApiGetVacancyVisitorsRequest {
	r.host = &host
	return r
}

func (r ApiGetVacancyVisitorsRequest) Execute() (*VacanciesVisitorsResponse, *http.Response, error) {
	return r.ApiService.GetVacancyVisitorsExecute(r)
}

/*
GetVacancyVisitors Посмотревшие вакансию

Возвращает список сокращенных резюме соискателей, просмотревших вакансию за последнюю неделю. Список отсортирован по убыванию по дате просмотра. Если у пользователя несколько резюме, то вернется резюме с наиболее поздней датой обновления.

В списке `items` не отображаются резюме, которые соискатель удалил или скрыл от работодателя. Но они учитываются при пагинации (`per_page`) и при подсчете найденных резюме (`found`), а в поле `hidden_on_page` показано количество таких пропущенных резюме на странице


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacancyVisitorsRequest
*/
func (a *DefaultApiService) GetVacancyVisitors(ctx context.Context, vacancyId string) ApiGetVacancyVisitorsRequest {
	return ApiGetVacancyVisitorsRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVisitorsResponse
func (a *DefaultApiService) GetVacancyVisitorsExecute(r ApiGetVacancyVisitorsRequest) (*VacanciesVisitorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVisitorsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancyVisitors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/visitors"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVacancy_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiGetVacancy_0Request) HHUserAgent(hHUserAgent string) ApiGetVacancy_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiGetVacancy_0Request) Locale(locale string) ApiGetVacancy_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiGetVacancy_0Request) Host(host string) ApiGetVacancy_0Request {
	r.host = &host
	return r
}

func (r ApiGetVacancy_0Request) Execute() (*VacanciesVacancy, *http.Response, error) {
	return r.ApiService.GetVacancy_26Execute(r)
}

/*
GetVacancy_0 Просмотр вакансии

Возвращает подробную информацию по указанной вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiGetVacancy_0Request
*/
func (a *DefaultApiService) GetVacancy_26(ctx context.Context, vacancyId string) ApiGetVacancy_0Request {
	return ApiGetVacancy_0Request{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
//  @return VacanciesVacancy
func (a *DefaultApiService) GetVacancy_26Execute(r ApiGetVacancy_0Request) (*VacanciesVacancy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacanciesVacancy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetVacancy_26")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonCaptchaErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHideActiveResponseRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nid string
	hHUserAgent *string
	withDeclineMessage *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiHideActiveResponseRequest) HHUserAgent(hHUserAgent string) ApiHideActiveResponseRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Должно ли быть отправлено работодателю сообщение об отказе, по умолчанию &#x60;false&#x60;. Возможность отправить сообщение об отказе определяется полем &#x60;decline_allowed&#x60; получаемым при запросе [списка откликов или одного отклика](https://github.com/hhru/api/blob/e2a0ac4e174a6b56272f78348c05958f5db1b392/docs/negotiations.md#get_negotiation) 
func (r ApiHideActiveResponseRequest) WithDeclineMessage(withDeclineMessage bool) ApiHideActiveResponseRequest {
	r.withDeclineMessage = &withDeclineMessage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiHideActiveResponseRequest) Locale(locale string) ApiHideActiveResponseRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiHideActiveResponseRequest) Host(host string) ApiHideActiveResponseRequest {
	r.host = &host
	return r
}

func (r ApiHideActiveResponseRequest) Execute() (*http.Response, error) {
	return r.ApiService.HideActiveResponseExecute(r)
}

/*
HideActiveResponse Скрыть отклик

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nid Идентификатор отклика
 @return ApiHideActiveResponseRequest
*/
func (a *DefaultApiService) HideActiveResponse(ctx context.Context, nid string) ApiHideActiveResponseRequest {
	return ApiHideActiveResponseRequest{
		ApiService: a,
		ctx: ctx,
		nid: nid,
	}
}

// Execute executes the request
func (a *DefaultApiService) HideActiveResponseExecute(r ApiHideActiveResponseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.HideActiveResponse")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/active/{nid}"
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterValueToString(r.nid, "nid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.withDeclineMessage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_decline_message", r.withDeclineMessage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsNegotiationHideResponseForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 425 {
			var v ErrorsNegotiationHideResponseErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInvalidateTokenRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiInvalidateTokenRequest) Execute() (*http.Response, error) {
	return r.ApiService.InvalidateTokenExecute(r)
}

/*
InvalidateToken Инвалидация токена

Инвалидация работает только на действующем access-токене.
После инвалидации токен нельзя будет запросить с помощью refresh-токена - для работы необходимо будет заново авторизоваться в API 
Таким образом нельзя инвалидировать токен приложения <a name="invalidate_token"></a>.
В случае компрометации токена необходимо инвалидировать скомпрометированный токен и запросить токен заново!


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInvalidateTokenRequest
*/
func (a *DefaultApiService) InvalidateToken(ctx context.Context) ApiInvalidateTokenRequest {
	return ApiInvalidateTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) InvalidateTokenExecute(r ApiInvalidateTokenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InvalidateToken")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInvalidateToken_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiInvalidateToken_0Request) Execute() (*http.Response, error) {
	return r.ApiService.InvalidateToken_27Execute(r)
}

/*
InvalidateToken_0 Инвалидация токена

Инвалидация работает только на действующем access-токене.
После инвалидации токен нельзя будет запросить с помощью refresh-токена - для работы необходимо будет заново авторизоваться в API 
Таким образом нельзя инвалидировать токен приложения <a name="invalidate_token"></a>.
В случае компрометации токена необходимо инвалидировать скомпрометированный токен и запросить токен заново!


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInvalidateToken_0Request
*/
func (a *DefaultApiService) InvalidateToken_27(ctx context.Context) ApiInvalidateToken_0Request {
	return ApiInvalidateToken_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) InvalidateToken_27Execute(r ApiInvalidateToken_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InvalidateToken_27")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInvalidateToken_1Request struct {
	ctx context.Context
	ApiService *DefaultApiService
}

func (r ApiInvalidateToken_1Request) Execute() (*http.Response, error) {
	return r.ApiService.InvalidateToken_28Execute(r)
}

/*
InvalidateToken_1 Инвалидация токена

Инвалидация работает только на действующем access-токене.
После инвалидации токен нельзя будет запросить с помощью refresh-токена - для работы необходимо будет заново авторизоваться в API 
Таким образом нельзя инвалидировать токен приложения <a name="invalidate_token"></a>.
В случае компрометации токена необходимо инвалидировать скомпрометированный токен и запросить токен заново!


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInvalidateToken_1Request
*/
func (a *DefaultApiService) InvalidateToken_28(ctx context.Context) ApiInvalidateToken_1Request {
	return ApiInvalidateToken_1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) InvalidateToken_28Execute(r ApiInvalidateToken_1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.InvalidateToken_28")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/oauth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLoadArtifactRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	file *os.File
	type_ *string
	locale *string
	host *string
	description *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiLoadArtifactRequest) HHUserAgent(hHUserAgent string) ApiLoadArtifactRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Файл изображения
func (r ApiLoadArtifactRequest) File(file *os.File) ApiLoadArtifactRequest {
	r.file = file
	return r
}

// Тип артефакта: &#x60;photo&#x60; или &#x60;portfolio&#x60;
func (r ApiLoadArtifactRequest) Type_(type_ string) ApiLoadArtifactRequest {
	r.type_ = &type_
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiLoadArtifactRequest) Locale(locale string) ApiLoadArtifactRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiLoadArtifactRequest) Host(host string) ApiLoadArtifactRequest {
	r.host = &host
	return r
}

// Текстовое описание. Имеет смысл для &#x60;portfolio&#x60;
func (r ApiLoadArtifactRequest) Description(description string) ApiLoadArtifactRequest {
	r.description = &description
	return r
}

func (r ApiLoadArtifactRequest) Execute() (*ArtifactsArtifactItem, *http.Response, error) {
	return r.ApiService.LoadArtifactExecute(r)
}

/*
LoadArtifact Загрузка артефакта

Запрос загружает файл с локальной машины в сервис. 

Ограничения на типы файлов и их размер доступны в [условиях загрузки артефактов](#tag/Rabota-s-artefaktami).

Для прикрепления загруженных изображений в резюме, необходимо передать `id` артефакта в [соответствующее поле резюме](https://github.com/hhru/api/blob/master/docs/employer_resumes.md#resume-fields). Для удаления артефакта из резюме укажите `null`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLoadArtifactRequest
*/
func (a *DefaultApiService) LoadArtifact(ctx context.Context) ApiLoadArtifactRequest {
	return ApiLoadArtifactRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ArtifactsArtifactItem
func (a *DefaultApiService) LoadArtifactExecute(r ApiLoadArtifactRequest) (*ArtifactsArtifactItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ArtifactsArtifactItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.LoadArtifact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artifacts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "")
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsArtifactUploadBadJsonData
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v ErrorsRequestEntityTooLargeErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveSavedResumeSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	savedSearchId string
	managerId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiMoveSavedResumeSearchRequest) HHUserAgent(hHUserAgent string) ApiMoveSavedResumeSearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiMoveSavedResumeSearchRequest) Locale(locale string) ApiMoveSavedResumeSearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiMoveSavedResumeSearchRequest) Host(host string) ApiMoveSavedResumeSearchRequest {
	r.host = &host
	return r
}

func (r ApiMoveSavedResumeSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveSavedResumeSearchExecute(r)
}

/*
MoveSavedResumeSearch Передача сохраненного поиска резюме другому менеджеру

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param savedSearchId Идентификатор из [списка сохраненных поисков](#tag/Sohranennye-poiski-rezyume/operation/get-saved-resume-searches)
 @param managerId Идентификатор менеджера, которому надо передать автопоиск ([список менеджеров компании](#tag/Menedzhery-rabotodatelya/operation/get-employer-managers))
 @return ApiMoveSavedResumeSearchRequest
*/
func (a *DefaultApiService) MoveSavedResumeSearch(ctx context.Context, savedSearchId string, managerId string) ApiMoveSavedResumeSearchRequest {
	return ApiMoveSavedResumeSearchRequest{
		ApiService: a,
		ctx: ctx,
		savedSearchId: savedSearchId,
		managerId: managerId,
	}
}

// Execute executes the request
func (a *DefaultApiService) MoveSavedResumeSearchExecute(r ApiMoveSavedResumeSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.MoveSavedResumeSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes/{saved_search_id}/managers/{manager_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_search_id"+"}", url.PathEscape(parameterValueToString(r.savedSearchId, "savedSearchId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"manager_id"+"}", url.PathEscape(parameterValueToString(r.managerId, "managerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsSavedSearchForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsSavedSearchNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostNegotiationsTopicsReadRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	topicId *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPostNegotiationsTopicsReadRequest) HHUserAgent(hHUserAgent string) ApiPostNegotiationsTopicsReadRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификаторы откликов
func (r ApiPostNegotiationsTopicsReadRequest) TopicId(topicId string) ApiPostNegotiationsTopicsReadRequest {
	r.topicId = &topicId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPostNegotiationsTopicsReadRequest) Locale(locale string) ApiPostNegotiationsTopicsReadRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPostNegotiationsTopicsReadRequest) Host(host string) ApiPostNegotiationsTopicsReadRequest {
	r.host = &host
	return r
}

func (r ApiPostNegotiationsTopicsReadRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostNegotiationsTopicsReadExecute(r)
}

/*
PostNegotiationsTopicsRead Отметить отклики прочитанными

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostNegotiationsTopicsReadRequest
*/
func (a *DefaultApiService) PostNegotiationsTopicsRead(ctx context.Context) ApiPostNegotiationsTopicsReadRequest {
	return ApiPostNegotiationsTopicsReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) PostNegotiationsTopicsReadExecute(r ApiPostNegotiationsTopicsReadRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PostNegotiationsTopicsRead")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.topicId == nil {
		return nil, reportError("topicId is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "topic_id", r.topicId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublishResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	resumeId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPublishResumeRequest) HHUserAgent(hHUserAgent string) ApiPublishResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPublishResumeRequest) Locale(locale string) ApiPublishResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPublishResumeRequest) Host(host string) ApiPublishResumeRequest {
	r.host = &host
	return r
}

func (r ApiPublishResumeRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishResumeExecute(r)
}

/*
PublishResume Публикация резюме

При первой публикации резюме оно становится доступно для использования. При повторной публикации происходит обновление даты резюме.

Повторная публикация означает обновление даты резюме. Ключ `next_publish_at` у [резюме](#tag/Rezyume.-Prosmotr-informacii/operation/get-mine-resumes) указывает время, когда можно обновить резюме


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resumeId Идентификатор резюме
 @return ApiPublishResumeRequest
*/
func (a *DefaultApiService) PublishResume(ctx context.Context, resumeId string) ApiPublishResumeRequest {
	return ApiPublishResumeRequest{
		ApiService: a,
		ctx: ctx,
		resumeId: resumeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) PublishResumeExecute(r ApiPublishResumeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PublishResume")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes/{resume_id}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"resume_id"+"}", url.PathEscape(parameterValueToString(r.resumeId, "resumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsBadRequestPublishResumeErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ErrorsResumeTooManyRequestsErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPublishVacancyRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	vacancyCreate *VacancyCreate
	ignoreDuplicates *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPublishVacancyRequest) HHUserAgent(hHUserAgent string) ApiPublishVacancyRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiPublishVacancyRequest) VacancyCreate(vacancyCreate VacancyCreate) ApiPublishVacancyRequest {
	r.vacancyCreate = &vacancyCreate
	return r
}

// Форсирование добавления дубликатов
func (r ApiPublishVacancyRequest) IgnoreDuplicates(ignoreDuplicates bool) ApiPublishVacancyRequest {
	r.ignoreDuplicates = &ignoreDuplicates
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPublishVacancyRequest) Locale(locale string) ApiPublishVacancyRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPublishVacancyRequest) Host(host string) ApiPublishVacancyRequest {
	r.host = &host
	return r
}

func (r ApiPublishVacancyRequest) Execute() (*IncludesId, *http.Response, error) {
	return r.ApiService.PublishVacancyExecute(r)
}

/*
PublishVacancy Публикация вакансии

Создает новую вакансию с полями, передаваемыми в теле запроса. 

В соответствии с [законом РФ № 1032-1 от 19.04.1991 в ред. от 02.07.2013 г.](https://hh.ru/article/13967) запрещено размещать информацию, ограничивающую права или устанавливающую преимущества для соискателей по полу, возрасту, семейному положению и другим обстоятельствам, не связанным с деловыми качествами работников.

Примечания:

* При успешной публикации будут списаны соответствующие услуги.
* Все вакансии проходят ручную модерацию.
* В течение нескольких минут после публикации вакансия станет доступна в поиске.

Полезные ссылки:

* [Правила размещения вакансий](https://hh.ru/article/341)
* [Как составить хорошее описание вакансии](https://hh.ru/article/16239)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishVacancyRequest
*/
func (a *DefaultApiService) PublishVacancy(ctx context.Context) ApiPublishVacancyRequest {
	return ApiPublishVacancyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IncludesId
func (a *DefaultApiService) PublishVacancyExecute(r ApiPublishVacancyRequest) (*IncludesId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IncludesId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PublishVacancy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyCreate == nil {
		return localVarReturnValue, nil, reportError("vacancyCreate is required and must be specified")
	}

	if r.ignoreDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_duplicates", r.ignoreDuplicates, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyAddEditCombinedBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyAddEditBadAuthForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishVacancyFromDraftRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPublishVacancyFromDraftRequest) HHUserAgent(hHUserAgent string) ApiPublishVacancyFromDraftRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPublishVacancyFromDraftRequest) Locale(locale string) ApiPublishVacancyFromDraftRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPublishVacancyFromDraftRequest) Host(host string) ApiPublishVacancyFromDraftRequest {
	r.host = &host
	return r
}

func (r ApiPublishVacancyFromDraftRequest) Execute() (*VacancyDraftVacanciesDraftResponse, *http.Response, error) {
	return r.ApiService.PublishVacancyFromDraftExecute(r)
}

/*
PublishVacancyFromDraft Публикация вакансии на основе черновика

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param draftId Идентификатор черновика вакансии
 @return ApiPublishVacancyFromDraftRequest
*/
func (a *DefaultApiService) PublishVacancyFromDraft(ctx context.Context, draftId string) ApiPublishVacancyFromDraftRequest {
	return ApiPublishVacancyFromDraftRequest{
		ApiService: a,
		ctx: ctx,
		draftId: draftId,
	}
}

// Execute executes the request
//  @return VacancyDraftVacanciesDraftResponse
func (a *DefaultApiService) PublishVacancyFromDraftExecute(r ApiPublishVacancyFromDraftRequest) (*VacancyDraftVacanciesDraftResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDraftVacanciesDraftResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PublishVacancyFromDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts/{draft_id}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"draft_id"+"}", url.PathEscape(parameterValueToString(r.draftId, "draftId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishVacancy_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	vacancyCreate *VacancyCreate
	ignoreDuplicates *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPublishVacancy_0Request) HHUserAgent(hHUserAgent string) ApiPublishVacancy_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiPublishVacancy_0Request) VacancyCreate(vacancyCreate VacancyCreate) ApiPublishVacancy_0Request {
	r.vacancyCreate = &vacancyCreate
	return r
}

// Форсирование добавления дубликатов
func (r ApiPublishVacancy_0Request) IgnoreDuplicates(ignoreDuplicates bool) ApiPublishVacancy_0Request {
	r.ignoreDuplicates = &ignoreDuplicates
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPublishVacancy_0Request) Locale(locale string) ApiPublishVacancy_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPublishVacancy_0Request) Host(host string) ApiPublishVacancy_0Request {
	r.host = &host
	return r
}

func (r ApiPublishVacancy_0Request) Execute() (*IncludesId, *http.Response, error) {
	return r.ApiService.PublishVacancy_29Execute(r)
}

/*
PublishVacancy_0 Публикация вакансии

Создает новую вакансию с полями, передаваемыми в теле запроса. 

В соответствии с [законом РФ № 1032-1 от 19.04.1991 в ред. от 02.07.2013 г.](https://hh.ru/article/13967) запрещено размещать информацию, ограничивающую права или устанавливающую преимущества для соискателей по полу, возрасту, семейному положению и другим обстоятельствам, не связанным с деловыми качествами работников.

Примечания:

* При успешной публикации будут списаны соответствующие услуги.
* Все вакансии проходят ручную модерацию.
* В течение нескольких минут после публикации вакансия станет доступна в поиске.

Полезные ссылки:

* [Правила размещения вакансий](https://hh.ru/article/341)
* [Как составить хорошее описание вакансии](https://hh.ru/article/16239)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishVacancy_0Request
*/
func (a *DefaultApiService) PublishVacancy_29(ctx context.Context) ApiPublishVacancy_0Request {
	return ApiPublishVacancy_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IncludesId
func (a *DefaultApiService) PublishVacancy_29Execute(r ApiPublishVacancy_0Request) (*IncludesId, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IncludesId
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PublishVacancy_29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.vacancyCreate == nil {
		return localVarReturnValue, nil, reportError("vacancyCreate is required and must be specified")
	}

	if r.ignoreDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignore_duplicates", r.ignoreDuplicates, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.vacancyCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsVacancyAddEditCombinedBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyAddEditBadAuthForbiddenErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutMailTemplatesItemRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	templateId string
	hHUserAgent *string
	mailTemplatesMailTemplateInput *MailTemplatesMailTemplateInput
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPutMailTemplatesItemRequest) HHUserAgent(hHUserAgent string) ApiPutMailTemplatesItemRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

func (r ApiPutMailTemplatesItemRequest) MailTemplatesMailTemplateInput(mailTemplatesMailTemplateInput MailTemplatesMailTemplateInput) ApiPutMailTemplatesItemRequest {
	r.mailTemplatesMailTemplateInput = &mailTemplatesMailTemplateInput
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPutMailTemplatesItemRequest) Locale(locale string) ApiPutMailTemplatesItemRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPutMailTemplatesItemRequest) Host(host string) ApiPutMailTemplatesItemRequest {
	r.host = &host
	return r
}

func (r ApiPutMailTemplatesItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutMailTemplatesItemExecute(r)
}

/*
PutMailTemplatesItem Изменение шаблона ответа соискателю

Изменение шаблона ответа для [переписки](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя, который можно узнать [в информации о текущем пользователе](#tag/Informaciya-o-menedzhere/operation/get-current-user-info)
 @param templateId Идентификатор шаблона для изменения из [списка доступных шаблонов ответов соискателю](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-mail-templates)
 @return ApiPutMailTemplatesItemRequest
*/
func (a *DefaultApiService) PutMailTemplatesItem(ctx context.Context, employerId string, templateId string) ApiPutMailTemplatesItemRequest {
	return ApiPutMailTemplatesItemRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		templateId: templateId,
	}
}

// Execute executes the request
func (a *DefaultApiService) PutMailTemplatesItemExecute(r ApiPutMailTemplatesItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutMailTemplatesItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/mail_templates/{template_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"template_id"+"}", url.PathEscape(parameterValueToString(r.templateId, "templateId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.mailTemplatesMailTemplateInput == nil {
		return nil, reportError("mailTemplatesMailTemplateInput is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	// body params
	localVarPostBody = r.mailTemplatesMailTemplateInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadJsonDataErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutNegotiationsCollectionToNextStateRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	topicId *string
	locale *string
	host *string
	addressId *string
	message *string
	sendSms *bool
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPutNegotiationsCollectionToNextStateRequest) HHUserAgent(hHUserAgent string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификаторы откликов
func (r ApiPutNegotiationsCollectionToNextStateRequest) TopicId(topicId string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.topicId = &topicId
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPutNegotiationsCollectionToNextStateRequest) Locale(locale string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPutNegotiationsCollectionToNextStateRequest) Host(host string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.host = &host
	return r
}

// Идентификатор [адреса](https://api.hh.ru/openapi/redoc#tag/Adresa-rabotodatelya), который будет указан в приглашении
func (r ApiPutNegotiationsCollectionToNextStateRequest) AddressId(addressId string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.addressId = &addressId
	return r
}

// Сообщение, которое будет отправлено соискателю на электронную почту. Используйте [шаблоны](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-mail-templates) для получения текстов
func (r ApiPutNegotiationsCollectionToNextStateRequest) Message(message string) ApiPutNegotiationsCollectionToNextStateRequest {
	r.message = &message
	return r
}

// Если установлено &#x60;true&#x60;, соискателю будет отправлено SMS-уведомление о приглашении. Обратите внимание, что в SMS-сообщении используется стандартный текст, изменить его нельзя
func (r ApiPutNegotiationsCollectionToNextStateRequest) SendSms(sendSms bool) ApiPutNegotiationsCollectionToNextStateRequest {
	r.sendSms = &sendSms
	return r
}

func (r ApiPutNegotiationsCollectionToNextStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutNegotiationsCollectionToNextStateExecute(r)
}

/*
PutNegotiationsCollectionToNextState Действия по откликам/приглашениям

Работодатель может изменять состояние (state) отклика для соискателя, чтобы повысить качество обратной связи и упростить работу со статистикой откликов.

Если работодатель, используя данный метод, отправляет соискателю сообщение об изменении состояния отклика/приглашения (поле `message` в теле запроса), это приведет также к изменению соискательского состояния отклика/приглашения.

Обязательность аргументов в теле запроса отличается для разных откликов/приглашений. Проверить, является ли аргумент обязательным можно в поле `actions.arguments`, которое возвращается для каждого отклика в [списке откликов/приглашений](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#действия-по-откликуприглашению-actions)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор [коллекции](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-negotiations) топиков, в которую будет перенесено состояние отклика
 @return ApiPutNegotiationsCollectionToNextStateRequest
*/
func (a *DefaultApiService) PutNegotiationsCollectionToNextState(ctx context.Context, id string) ApiPutNegotiationsCollectionToNextStateRequest {
	return ApiPutNegotiationsCollectionToNextStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) PutNegotiationsCollectionToNextStateExecute(r ApiPutNegotiationsCollectionToNextStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutNegotiationsCollectionToNextState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.topicId == nil {
		return nil, reportError("topicId is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "topic_id", r.topicId, "")
	if r.addressId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "address_id", r.addressId, "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "")
	}
	if r.sendSms != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "send_sms", r.sendSms, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutPrefNegotiationsOrderRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	order *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiPutPrefNegotiationsOrderRequest) HHUserAgent(hHUserAgent string) ApiPutPrefNegotiationsOrderRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор типа сортировки. Возможные значения представлены в поле &#x60;order_types&#x60; [коллекции откликов и приглашений](#tag/Otklikipriglasheniya-rabotodatelya/operation/get-negotiations). Не все типы сортировки из списка доступны для изменения
func (r ApiPutPrefNegotiationsOrderRequest) Order(order string) ApiPutPrefNegotiationsOrderRequest {
	r.order = &order
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiPutPrefNegotiationsOrderRequest) Locale(locale string) ApiPutPrefNegotiationsOrderRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiPutPrefNegotiationsOrderRequest) Host(host string) ApiPutPrefNegotiationsOrderRequest {
	r.host = &host
	return r
}

func (r ApiPutPrefNegotiationsOrderRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutPrefNegotiationsOrderExecute(r)
}

/*
PutPrefNegotiationsOrder Изменение предпочитаемой сортировки откликов

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор вакансии
 @return ApiPutPrefNegotiationsOrderRequest
*/
func (a *DefaultApiService) PutPrefNegotiationsOrder(ctx context.Context, id string) ApiPutPrefNegotiationsOrderRequest {
	return ApiPutPrefNegotiationsOrderRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) PutPrefNegotiationsOrderExecute(r ApiPutPrefNegotiationsOrderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PutPrefNegotiationsOrder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{id}/preferred_negotiations_order"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.order == nil {
		return nil, reportError("order is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "order", r.order, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRestoreVacancyFromHiddenRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	employerId string
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiRestoreVacancyFromHiddenRequest) HHUserAgent(hHUserAgent string) ApiRestoreVacancyFromHiddenRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiRestoreVacancyFromHiddenRequest) Locale(locale string) ApiRestoreVacancyFromHiddenRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiRestoreVacancyFromHiddenRequest) Host(host string) ApiRestoreVacancyFromHiddenRequest {
	r.host = &host
	return r
}

func (r ApiRestoreVacancyFromHiddenRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestoreVacancyFromHiddenExecute(r)
}

/*
RestoreVacancyFromHidden Восстановление вакансии из удаленных

Восстановить можно только удаленную из архива вакансию. Вакансия вернется в архив

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param employerId Идентификатор работодателя
 @param vacancyId Идентификатор вакансии
 @return ApiRestoreVacancyFromHiddenRequest
*/
func (a *DefaultApiService) RestoreVacancyFromHidden(ctx context.Context, employerId string, vacancyId string) ApiRestoreVacancyFromHiddenRequest {
	return ApiRestoreVacancyFromHiddenRequest{
		ApiService: a,
		ctx: ctx,
		employerId: employerId,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) RestoreVacancyFromHiddenExecute(r ApiRestoreVacancyFromHiddenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestoreVacancyFromHidden")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers/{employer_id}/vacancies/hidden/{vacancy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"employer_id"+"}", url.PathEscape(parameterValueToString(r.employerId, "employerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchEmployerRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	text *string
	area *string
	type_ *string
	onlyWithVacancies *bool
	sortBy *string
	page *float32
	perPage *float32
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSearchEmployerRequest) HHUserAgent(hHUserAgent string) ApiSearchEmployerRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Текст для поиска. Переданное значение ищется в названии и описании работодателя
func (r ApiSearchEmployerRequest) Text(text string) ApiSearchEmployerRequest {
	r.text = &text
	return r
}

// Идентификатор региона работодателя, множественный параметр. Идентификаторы регионов можно узнать в [справочнике регионов](#tag/Obshie-spravochniki/operation/get-areas)
func (r ApiSearchEmployerRequest) Area(area string) ApiSearchEmployerRequest {
	r.area = &area
	return r
}

// Тип работодателя, множественный параметр. Разрешенные значения перечислены в [справочнике](#tag/Obshie-spravochniki/operation/get-dictionaries) в поле &#x60;employer_type&#x60;
func (r ApiSearchEmployerRequest) Type_(type_ string) ApiSearchEmployerRequest {
	r.type_ = &type_
	return r
}

// Возвращать только работодателей у которых есть в данный момент открытые вакансии (&#x60;true&#x60;) или же всех (&#x60;false&#x60;). По умолчанию — &#x60;false&#x60;
func (r ApiSearchEmployerRequest) OnlyWithVacancies(onlyWithVacancies bool) ApiSearchEmployerRequest {
	r.onlyWithVacancies = &onlyWithVacancies
	return r
}

// Сортировка по имени (&#x60;by_name&#x60;) или по количеству открытых вакансий (&#x60;by_vacancies_open&#x60;). По умолчанию — &#x60;by_name&#x60;
func (r ApiSearchEmployerRequest) SortBy(sortBy string) ApiSearchEmployerRequest {
	r.sortBy = &sortBy
	return r
}

// Номер страницы с работодателями (считается от &#x60;0&#x60;, по умолчанию — &#x60;0&#x60;)
func (r ApiSearchEmployerRequest) Page(page float32) ApiSearchEmployerRequest {
	r.page = &page
	return r
}

// Количество элементов на страницу (по умолчанию — 20, максимум — 100 )
func (r ApiSearchEmployerRequest) PerPage(perPage float32) ApiSearchEmployerRequest {
	r.perPage = &perPage
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSearchEmployerRequest) Locale(locale string) ApiSearchEmployerRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSearchEmployerRequest) Host(host string) ApiSearchEmployerRequest {
	r.host = &host
	return r
}

func (r ApiSearchEmployerRequest) Execute() (*EmployersEmployersList, *http.Response, error) {
	return r.ApiService.SearchEmployerExecute(r)
}

/*
SearchEmployer Поиск работодателя

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше `5000`. Например, возможен запрос `per_page=10&page=499` (выдача с `4991` по `5000` работодателя), но запрос с `per_page=10&page=500` вернёт ошибку (выдача с `5001` до `5010` работодателя)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchEmployerRequest
*/
func (a *DefaultApiService) SearchEmployer(ctx context.Context) ApiSearchEmployerRequest {
	return ApiSearchEmployerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmployersEmployersList
func (a *DefaultApiService) SearchEmployerExecute(r ApiSearchEmployerRequest) (*EmployersEmployersList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployersEmployersList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchEmployer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/employers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.onlyWithVacancies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_with_vacancies", r.onlyWithVacancies, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForResumesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	text *string
	textLogic *string
	textField *string
	textPeriod *string
	ageFrom *string
	ageTo *string
	area *string
	relocation *string
	period *float32
	dateFrom *string
	dateTo *string
	educationLevel *string
	employment *string
	experience *string
	skill *string
	gender *string
	label *string
	language *string
	languageLevel *string
	metro *string
	currency *string
	salaryFrom *float32
	salaryTo *float32
	schedule *string
	orderBy *string
	citizenship *string
	workTicket *string
	educationalInstitution *string
	searchInResponses *bool
	byTextPrefix *bool
	driverLicenseTypes *string
	vacancyId *string
	page *float32
	perPage *float32
	professionalRole *string
	folder *string
	includeAllFolders *bool
	jobSearchStatus *string
	resume *string
	filterExpIndustry *string
	filterExpPeriod *string
	withJobSearchStatus *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSearchForResumesRequest) HHUserAgent(hHUserAgent string) ApiSearchForResumesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Поисковая фраза. Метод найдет резюме, в которых встречаются все слова заданной фразы.  Особенности:  * Можно указать несколько значений. Каждое дополнительное значение уточняет поиск. * В качестве поисковой фразы можно использовать [язык поисковых запросов](http://hh.ru/article.xml?articleId&#x3D;1175). * Специально для этого поля предусмотрено [автодополнение по подсказкам](#tag/Podskazki/operation/get-resume-search-keywords-suggests). * Для тонкой настройки по фразе можно использовать параметры &#x60;text.logic&#x60;, &#x60;text.field&#x60;, &#x60;text.period&#x60;. При использовании дополнительных &#x60;text.*&#x60; полей, необходимо указывать весь набор (триаду) параметров 
func (r ApiSearchForResumesRequest) Text(text string) ApiSearchForResumesRequest {
	r.text = &text
	return r
}

// Описывает, как производится поиск. Возможные значения перечислены в поле &#x60;resume_search_logic&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiSearchForResumesRequest) TextLogic(textLogic string) ApiSearchForResumesRequest {
	r.textLogic = &textLogic
	return r
}

// Описывает, где должны встречаться слова из поисковой фразы &#x60;text&#x60;. Можно указать несколько значений через запятую, например &#x60;?text.field&#x3D;education,keywords&#x60;. Возможные значения перечислены в поле &#x60;resume_search_fields&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries)
func (r ApiSearchForResumesRequest) TextField(textField string) ApiSearchForResumesRequest {
	r.textField = &textField
	return r
}

// Период опыта работы.  Параметр имеет смысл только при &#x60;text.field&#x60; равным одному из значений: &#x60;experience&#x60;, &#x60;experience_company&#x60;, &#x60;experience_position&#x60;, &#x60;experience_description&#x60;, но указывать его необходимо всегда при указании других &#x60;text.*&#x60;. Если параметр не имеет смысла, то его значение можно оставить пустым 
func (r ApiSearchForResumesRequest) TextPeriod(textPeriod string) ApiSearchForResumesRequest {
	r.textPeriod = &textPeriod
	return r
}

// Нижняя граница возраста соискателя в годах.  По умолчанию в выдачу добавляются также резюме с неуказанным возрастом. Для выдачи резюме только с указанным возрастом передайте значение &#x60;only_with_age&#x60; в параметре &#x60;label&#x60; 
func (r ApiSearchForResumesRequest) AgeFrom(ageFrom string) ApiSearchForResumesRequest {
	r.ageFrom = &ageFrom
	return r
}

// Верхняя граница возраста соискателя в годах.  По умолчанию в выдачу добавляются также резюме с неуказанным возрастом. Для выдачи резюме только с указанным возрастом передайте значение &#x60;only_with_age&#x60; в параметре &#x60;label&#x60; 
func (r ApiSearchForResumesRequest) AgeTo(ageTo string) ApiSearchForResumesRequest {
	r.ageTo = &ageTo
	return r
}

// Регион. Возможные значения указаны в [справочнике регионов](https://github.com/hhru/api/blob/master/docs/areas.md). Можно указать несколько значений.  По умолчанию выбираются резюме, в которых соискатели живут в указанных регионах или готовы в них переехать. Поменять это поведение поиска можно, указав параметр &#x60;relocation&#x60; 
func (r ApiSearchForResumesRequest) Area(area string) ApiSearchForResumesRequest {
	r.area = &area
	return r
}

// Готовность к переезду. Возможные значения указаны в поле &#x60;resume_search_relocation&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Необходимо указывать вместе с параметром &#x60;area&#x60; 
func (r ApiSearchForResumesRequest) Relocation(relocation string) ApiSearchForResumesRequest {
	r.relocation = &relocation
	return r
}

// Поиск ведется по резюме, опубликованным за указанный период в днях. Если период не указан, поиск ведется без ограничений по дате публикации 
func (r ApiSearchForResumesRequest) Period(period float32) ApiSearchForResumesRequest {
	r.period = &period
	return r
}

// Дата, от которой нужно начать поиск. Значение указывается в формате [ISO 8601](#date-format) — &#x60;YYYY-MM-DD&#x60; или с точностью до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Нельзя передавать вместе с параметром &#x60;period&#x60; 
func (r ApiSearchForResumesRequest) DateFrom(dateFrom string) ApiSearchForResumesRequest {
	r.dateFrom = &dateFrom
	return r
}

// Дата, до которой нужно искать. Значение указывается в формате [ISO 8601](#date-format) — &#x60;YYYY-MM-DD&#x60; или с точность до секунды &#x60;YYYY-MM-DDThh:mm:ss±hhmm&#x60;. Можно передавать только в паре с параметром &#x60;date_from&#x60;. Нельзя передавать вместе с параметром &#x60;period&#x60; 
func (r ApiSearchForResumesRequest) DateTo(dateTo string) ApiSearchForResumesRequest {
	r.dateTo = &dateTo
	return r
}

// Уровень образования. Возможные значения перечислены в поле &#x60;education_level&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Если параметр не указан, поиск ведется без ограничений на уровень образования 
func (r ApiSearchForResumesRequest) EducationLevel(educationLevel string) ApiSearchForResumesRequest {
	r.educationLevel = &educationLevel
	return r
}

// Тип занятости. Возможные значения перечислены в поле &#x60;employment&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) Employment(employment string) ApiSearchForResumesRequest {
	r.employment = &employment
	return r
}

// Опыт работы. Возможные значения перечислены в поле &#x60;experience&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiSearchForResumesRequest) Experience(experience string) ApiSearchForResumesRequest {
	r.experience = &experience
	return r
}

// Ключевые навыки. Указывается один или несколько идентификаторов ключевых навыков. Значения можно получить из поля &#x60;id&#x60; в [подсказке по ключевым навыкам](#tag/Podskazki/operation/get-skill-set-suggests) 
func (r ApiSearchForResumesRequest) Skill(skill string) ApiSearchForResumesRequest {
	r.skill = &skill
	return r
}

// Пол соискателя. Возможные значения перечислены в поле &#x60;gender&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries).  По умолчанию вне зависимости от значения параметра будут найдены резюме, в которых пол не указан, исключить из поисковой выдачи такие резюме можно с помощью параметра &#x60;label&#x3D;only_with_gender&#x60; 
func (r ApiSearchForResumesRequest) Gender(gender string) ApiSearchForResumesRequest {
	r.gender = &gender
	return r
}

// Дополнительный фильтр. Возможные значения перечислены в поле &#x60;resume_search_label&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) Label(label string) ApiSearchForResumesRequest {
	r.label = &label
	return r
}

// Знание языка. Можно указать несколько значений.  Возможные значения перечислены в [справочнике языков](#tag/Obshie-spravochniki/operation/get-languages) 
func (r ApiSearchForResumesRequest) Language(language string) ApiSearchForResumesRequest {
	r.language = &language
	return r
}

// Уровень знания языка. Можно указать несколько значений.  Возможные значения перечислены в поле &#x60;language_level&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiSearchForResumesRequest) LanguageLevel(languageLevel string) ApiSearchForResumesRequest {
	r.languageLevel = &languageLevel
	return r
}

// Линия, либо станция метро. Возможные значения перечислены в [справочнике метро](#tag/Obshie-spravochniki/operation/get-metro-stations) 
func (r ApiSearchForResumesRequest) Metro(metro string) ApiSearchForResumesRequest {
	r.metro = &metro
	return r
}

// Код валюты. Возможные значения перечислены в поле &#x60;currency.code&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiSearchForResumesRequest) Currency(currency string) ApiSearchForResumesRequest {
	r.currency = &currency
	return r
}

// Нижняя граница желаемой заработной платы (ЗП).  По умолчанию в выдачу добавляются также резюме с неуказанной ЗП. Для выдачи резюме только с указанной ЗП передайте параметр &#x60;label&#x3D;only_with_salary&#x60; 
func (r ApiSearchForResumesRequest) SalaryFrom(salaryFrom float32) ApiSearchForResumesRequest {
	r.salaryFrom = &salaryFrom
	return r
}

// Верхняя граница желаемой заработной платы (ЗП).  По умолчанию в выдачу добавляются также резюме с неуказанной ЗП. Для выдачи резюме только с указанной ЗП передайте параметр &#x60;label&#x3D;only_with_salary&#x60; 
func (r ApiSearchForResumesRequest) SalaryTo(salaryTo float32) ApiSearchForResumesRequest {
	r.salaryTo = &salaryTo
	return r
}

// График работы. Возможные значения перечислены в поле &#x60;schedule&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) Schedule(schedule string) ApiSearchForResumesRequest {
	r.schedule = &schedule
	return r
}

// Сортировка списка резюме. Возможные значения перечислены в поле &#x60;resume_search_order&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiSearchForResumesRequest) OrderBy(orderBy string) ApiSearchForResumesRequest {
	r.orderBy = &orderBy
	return r
}

// Страна гражданства соискателя. Возможные значения перечислены в [справочнике стран](https://github.com/hhru/api/blob/master/docs/areas.md#countries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) Citizenship(citizenship string) ApiSearchForResumesRequest {
	r.citizenship = &citizenship
	return r
}

// Страна, в которой у соискателя есть разрешение на работу. Возможные значения перечислены в [справочнике стран](https://github.com/hhru/api/blob/master/docs/areas.md#countries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) WorkTicket(workTicket string) ApiSearchForResumesRequest {
	r.workTicket = &workTicket
	return r
}

// Учебные заведения соискателя. В качестве параметров используются [подсказки по названиям университетов](#tag/Podskazki/operation/get-educational-institutions-suggests). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) EducationalInstitution(educationalInstitution string) ApiSearchForResumesRequest {
	r.educationalInstitution = &educationalInstitution
	return r
}

// Если &#x60;true&#x60;, то поиск осуществляется только по резюме, которыми соискатели откликались на вакансии компании текущего пользователя, если &#x60;false&#x60; — поиск осуществляется по всем резюме. По умолчанию — &#x60;false&#x60; 
func (r ApiSearchForResumesRequest) SearchInResponses(searchInResponses bool) ApiSearchForResumesRequest {
	r.searchInResponses = &searchInResponses
	return r
}

// Если &#x60;true&#x60;, включается поиск по префиксу. Для каждого параметра &#x60;text&#x60; будут находиться не только полные совпадения слов, но еще и слова, начинающиеся с &#x60;text&#x60;. По умолчанию — &#x60;false&#x60; 
func (r ApiSearchForResumesRequest) ByTextPrefix(byTextPrefix bool) ApiSearchForResumesRequest {
	r.byTextPrefix = &byTextPrefix
	return r
}

// Категории водительских прав соискателя. Возможные значения перечислены в поле &#x60;driver_license_types&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries) 
func (r ApiSearchForResumesRequest) DriverLicenseTypes(driverLicenseTypes string) ApiSearchForResumesRequest {
	r.driverLicenseTypes = &driverLicenseTypes
	return r
}

// Идентификатор вакансии для поиска похожих резюме. Необходимо передавать идентификатор активной вакансии работодателя или вакансии работодателя в архиве 
func (r ApiSearchForResumesRequest) VacancyId(vacancyId string) ApiSearchForResumesRequest {
	r.vacancyId = &vacancyId
	return r
}

// Номер страницы (считается от 0, по умолчанию — 0)
func (r ApiSearchForResumesRequest) Page(page float32) ApiSearchForResumesRequest {
	r.page = &page
	return r
}

// Количество элементов (по умолчанию — 20, максимальное значение — 100)
func (r ApiSearchForResumesRequest) PerPage(perPage float32) ApiSearchForResumesRequest {
	r.perPage = &perPage
	return r
}

// Профессиональная роль. Элемент справочника [профессиональных ролей](#tag/Obshie-spravochniki/operation/get-professional-roles-dictionary). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) ProfessionalRole(professionalRole string) ApiSearchForResumesRequest {
	r.professionalRole = &professionalRole
	return r
}

// Один или несколько идентификаторов папок с отобранными резюме. Если данный параметр передан, поиск будет ограничен содержимым указанных папок. Можно передавать идентификаторы нескольких папок, например: &#x60;folder&#x3D;111&amp;folder&#x3D;222&amp;folder&#x3D;333&#x60; 
func (r ApiSearchForResumesRequest) Folder(folder string) ApiSearchForResumesRequest {
	r.folder = &folder
	return r
}

// Признак, указывающий, нужно ли вести поиск по всем папкам с отобранными резюме.  Если у менеджера есть доступ к избранным папкам, то поиск проходит по умолчанию в избранных папках. Если передать параметр &#x60;false&#x60;, то поиск не будет ограничен папками. Если в одном запросе будут переданы параметры &#x60;folder&#x60; и &#x60;include_all_folders&#x60;, вернется ошибка &#x60;400 Bad Request&#x60; 
func (r ApiSearchForResumesRequest) IncludeAllFolders(includeAllFolders bool) ApiSearchForResumesRequest {
	r.includeAllFolders = &includeAllFolders
	return r
}

// Статус поиска работы.  Возможные значения перечислены в поле &#x60;job_search_statuses_employer&#x60; в [справочнике полей](#tag/Obshie-spravochniki/operation/get-dictionaries). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) JobSearchStatus(jobSearchStatus string) ApiSearchForResumesRequest {
	r.jobSearchStatus = &jobSearchStatus
	return r
}

// Идентификатор резюме для поиска похожих резюме 
func (r ApiSearchForResumesRequest) Resume(resume string) ApiSearchForResumesRequest {
	r.resume = &resume
	return r
}

// Обрабатывается совместно с параметром &#x60;filter_exp_period&#x60;. Идентификатор отрасли, в которой у соискателя должен присутствовать опыт работы. Возможные значения перечислены в [справочнике отраслей](#tag/Obshie-spravochniki/operation/get-industries) (поле id). Можно указать несколько значений 
func (r ApiSearchForResumesRequest) FilterExpIndustry(filterExpIndustry string) ApiSearchForResumesRequest {
	r.filterExpIndustry = &filterExpIndustry
	return r
}

// Период, за который у соискателя должен присутствовать опыт работы в отрасли, указанной в параметре &#x60;filter_exp_industry&#x60;.  Возможные значения:   * &#x60;all_time&#x60; - за все время * &#x60;last_year&#x60; - за последний год * &#x60;last_three_years&#x60; - за последние 3 года * &#x60;last_six_years&#x60; - за последние 6 лет.  По умолчанию равен &#x60;all_time&#x60; 
func (r ApiSearchForResumesRequest) FilterExpPeriod(filterExpPeriod string) ApiSearchForResumesRequest {
	r.filterExpPeriod = &filterExpPeriod
	return r
}

// Параметр для просмотра в резюме статуса поиска кандидата 
func (r ApiSearchForResumesRequest) WithJobSearchStatus(withJobSearchStatus bool) ApiSearchForResumesRequest {
	r.withJobSearchStatus = &withJobSearchStatus
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSearchForResumesRequest) Locale(locale string) ApiSearchForResumesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSearchForResumesRequest) Host(host string) ApiSearchForResumesRequest {
	r.host = &host
	return r
}

func (r ApiSearchForResumesRequest) Execute() (*ResumesSearchForResumesResponse, *http.Response, error) {
	return r.ApiService.SearchForResumesExecute(r)
}

/*
SearchForResumes Поиск резюме

Возвращает результаты поиска резюме.

Требуется наличие [платного доступа](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).

Некоторые параметры запроса могут принимать множественные значения: `key=value&key=value`. Если параметр может принимать несколько значений, об этом явно указано в его описании. Неизвестные параметры и параметры с ошибкой в названии игнорируются.

При указании параметров пагинации (`page`, `per_page`) работает ограничение: глубина возвращаемых результатов не может быть больше 2000. Например, возможен запрос `per_page=10&page=199` (выдача с 1991 по 2000 резюме), но запрос с `per_page=10&page=200` вернёт ошибку (выдача с 2001 до 2010 резюме)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchForResumesRequest
*/
func (a *DefaultApiService) SearchForResumes(ctx context.Context) ApiSearchForResumesRequest {
	return ApiSearchForResumesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumesSearchForResumesResponse
func (a *DefaultApiService) SearchForResumesExecute(r ApiSearchForResumesRequest) (*ResumesSearchForResumesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumesSearchForResumesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchForResumes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.textLogic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.logic", r.textLogic, "")
	}
	if r.textField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.field", r.textField, "")
	}
	if r.textPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text.period", r.textPeriod, "")
	}
	if r.ageFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age_from", r.ageFrom, "")
	}
	if r.ageTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "age_to", r.ageTo, "")
	}
	if r.area != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "area", r.area, "")
	}
	if r.relocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relocation", r.relocation, "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "")
	}
	if r.dateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "")
	}
	if r.dateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "")
	}
	if r.educationLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "education_level", r.educationLevel, "")
	}
	if r.employment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "employment", r.employment, "")
	}
	if r.experience != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "experience", r.experience, "")
	}
	if r.skill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skill", r.skill, "")
	}
	if r.gender != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender", r.gender, "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "")
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	}
	if r.languageLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language.level", r.languageLevel, "")
	}
	if r.metro != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metro", r.metro, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.salaryFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary_from", r.salaryFrom, "")
	}
	if r.salaryTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "salary_to", r.salaryTo, "")
	}
	if r.schedule != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schedule", r.schedule, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.citizenship != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "citizenship", r.citizenship, "")
	}
	if r.workTicket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "work_ticket", r.workTicket, "")
	}
	if r.educationalInstitution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "educational_institution", r.educationalInstitution, "")
	}
	if r.searchInResponses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_in_responses", r.searchInResponses, "")
	}
	if r.byTextPrefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "by_text_prefix", r.byTextPrefix, "")
	}
	if r.driverLicenseTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "driver_license_types", r.driverLicenseTypes, "")
	}
	if r.vacancyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vacancy_id", r.vacancyId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.professionalRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "professional_role", r.professionalRole, "")
	}
	if r.folder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "folder", r.folder, "")
	}
	if r.includeAllFolders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_all_folders", r.includeAllFolders, "")
	}
	if r.jobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_search_status", r.jobSearchStatus, "")
	}
	if r.resume != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resume", r.resume, "")
	}
	if r.filterExpIndustry != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_exp_industry", r.filterExpIndustry, "")
	}
	if r.filterExpPeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_exp_period", r.filterExpPeriod, "")
	}
	if r.withJobSearchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_job_search_status", r.withJobSearchStatus, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonOneOfErrorsBadRequestAndBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v SearchForResumes403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForVacancyDraftDuplicatesRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	draftId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSearchForVacancyDraftDuplicatesRequest) HHUserAgent(hHUserAgent string) ApiSearchForVacancyDraftDuplicatesRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSearchForVacancyDraftDuplicatesRequest) Locale(locale string) ApiSearchForVacancyDraftDuplicatesRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSearchForVacancyDraftDuplicatesRequest) Host(host string) ApiSearchForVacancyDraftDuplicatesRequest {
	r.host = &host
	return r
}

func (r ApiSearchForVacancyDraftDuplicatesRequest) Execute() (*VacancyDuplicates, *http.Response, error) {
	return r.ApiService.SearchForVacancyDraftDuplicatesExecute(r)
}

/*
SearchForVacancyDraftDuplicates Проверка наличия дубликатов вакансии

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param draftId Идентификатор черновика вакансии
 @return ApiSearchForVacancyDraftDuplicatesRequest
*/
func (a *DefaultApiService) SearchForVacancyDraftDuplicates(ctx context.Context, draftId string) ApiSearchForVacancyDraftDuplicatesRequest {
	return ApiSearchForVacancyDraftDuplicatesRequest{
		ApiService: a,
		ctx: ctx,
		draftId: draftId,
	}
}

// Execute executes the request
//  @return VacancyDuplicates
func (a *DefaultApiService) SearchForVacancyDraftDuplicatesExecute(r ApiSearchForVacancyDraftDuplicatesRequest) (*VacancyDuplicates, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VacancyDuplicates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SearchForVacancyDraftDuplicates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/drafts/{draft_id}/duplicates"
	localVarPath = strings.Replace(localVarPath, "{"+"draft_id"+"}", url.PathEscape(parameterValueToString(r.draftId, "draftId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendCodeForVerifyPhoneInResumeRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	hHUserAgent *string
	phone *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSendCodeForVerifyPhoneInResumeRequest) HHUserAgent(hHUserAgent string) ApiSendCodeForVerifyPhoneInResumeRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Телефон на который надо отправить подтверждающий код
func (r ApiSendCodeForVerifyPhoneInResumeRequest) Phone(phone string) ApiSendCodeForVerifyPhoneInResumeRequest {
	r.phone = &phone
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSendCodeForVerifyPhoneInResumeRequest) Locale(locale string) ApiSendCodeForVerifyPhoneInResumeRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSendCodeForVerifyPhoneInResumeRequest) Host(host string) ApiSendCodeForVerifyPhoneInResumeRequest {
	r.host = &host
	return r
}

func (r ApiSendCodeForVerifyPhoneInResumeRequest) Execute() (*ResumePhoneGenerateCodeGenerateCode, *http.Response, error) {
	return r.ApiService.SendCodeForVerifyPhoneInResumeExecute(r)
}

/*
SendCodeForVerifyPhoneInResume Отправить код подтверждения для телефона резюме

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendCodeForVerifyPhoneInResumeRequest
*/
func (a *DefaultApiService) SendCodeForVerifyPhoneInResume(ctx context.Context) ApiSendCodeForVerifyPhoneInResumeRequest {
	return ApiSendCodeForVerifyPhoneInResumeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResumePhoneGenerateCodeGenerateCode
func (a *DefaultApiService) SendCodeForVerifyPhoneInResumeExecute(r ApiSendCodeForVerifyPhoneInResumeRequest) (*ResumePhoneGenerateCodeGenerateCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResumePhoneGenerateCodeGenerateCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendCodeForVerifyPhoneInResume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resume_phone_generate_code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}
	if r.phone == nil {
		return localVarReturnValue, nil, reportError("phone is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "phone", r.phone, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendNegotiationMessageRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	nid string
	hHUserAgent *string
	locale *string
	host *string
	message *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSendNegotiationMessageRequest) HHUserAgent(hHUserAgent string) ApiSendNegotiationMessageRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSendNegotiationMessageRequest) Locale(locale string) ApiSendNegotiationMessageRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSendNegotiationMessageRequest) Host(host string) ApiSendNegotiationMessageRequest {
	r.host = &host
	return r
}

// Сообщение отклика/приглашения
func (r ApiSendNegotiationMessageRequest) Message(message string) ApiSendNegotiationMessageRequest {
	r.message = &message
	return r
}

func (r ApiSendNegotiationMessageRequest) Execute() (*NegotiationsMessageSent, *http.Response, error) {
	return r.ApiService.SendNegotiationMessageExecute(r)
}

/*
SendNegotiationMessage Отправка нового сообщения

Запрос отправляет новое сообщение в рамках переписки.

Отправить новое сообщение можно, если:

* Работодатель пригласил соискателя на вакансию.
* Соискатель оставил отклик на вакансию.

Если вакансия была отправлена в архив или соискатель удалил резюме, переписка будет недоступна. Работодатель также может вручную отключить переписку для вакансии.

‼️ Обратите внимание, что методы для работы с сообщениями в рамках отклика/приглашения от имени [соискателя](https://api.hh.ru/openapi/redoc#tag/Perepiska-(otklikipriglasheniya)-dlya-soiskatelya/operation/get-negotiation-messages) и 
  [менеджера работодателя](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D0%BE%D1%82%D0%BA%D0%BB%D0%B8%D0%BA%D0%B5%D0%BF%D1%80%D0%B8%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D0%B8) устарели, и новые возможности [чатов](https://feedback.hh.ru/knowledge-base/article/1290) в них не будут поддерживаться.
  В связи с этим переписка может некорректно отображаться


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nid Идентификатор отклика/приглашения
 @return ApiSendNegotiationMessageRequest
*/
func (a *DefaultApiService) SendNegotiationMessage(ctx context.Context, nid string) ApiSendNegotiationMessageRequest {
	return ApiSendNegotiationMessageRequest{
		ApiService: a,
		ctx: ctx,
		nid: nid,
	}
}

// Execute executes the request
//  @return NegotiationsMessageSent
func (a *DefaultApiService) SendNegotiationMessageExecute(r ApiSendNegotiationMessageRequest) (*NegotiationsMessageSent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsMessageSent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendNegotiationMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{nid}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterValueToString(r.nid, "nid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v SendNegotiationMessage403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v SendNegotiationMessage404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendNegotiationMessage_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	nid string
	hHUserAgent *string
	locale *string
	host *string
	message *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiSendNegotiationMessage_0Request) HHUserAgent(hHUserAgent string) ApiSendNegotiationMessage_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiSendNegotiationMessage_0Request) Locale(locale string) ApiSendNegotiationMessage_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiSendNegotiationMessage_0Request) Host(host string) ApiSendNegotiationMessage_0Request {
	r.host = &host
	return r
}

// Сообщение отклика/приглашения
func (r ApiSendNegotiationMessage_0Request) Message(message string) ApiSendNegotiationMessage_0Request {
	r.message = &message
	return r
}

func (r ApiSendNegotiationMessage_0Request) Execute() (*NegotiationsMessageSent, *http.Response, error) {
	return r.ApiService.SendNegotiationMessage_30Execute(r)
}

/*
SendNegotiationMessage_0 Отправка нового сообщения

Запрос отправляет новое сообщение в рамках переписки.

Отправить новое сообщение можно, если:

* Работодатель пригласил соискателя на вакансию.
* Соискатель оставил отклик на вакансию.

Если вакансия была отправлена в архив или соискатель удалил резюме, переписка будет недоступна. Работодатель также может вручную отключить переписку для вакансии.

‼️ Обратите внимание, что методы для работы с сообщениями в рамках отклика/приглашения от имени [соискателя](https://api.hh.ru/openapi/redoc#tag/Perepiska-(otklikipriglasheniya)-dlya-soiskatelya/operation/get-negotiation-messages) и 
  [менеджера работодателя](https://github.com/hhru/api/blob/master/docs/employer_negotiations.md#%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-%D0%BE%D1%82%D0%BA%D0%BB%D0%B8%D0%BA%D0%B5%D0%BF%D1%80%D0%B8%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D0%B8) устарели, и новые возможности [чатов](https://feedback.hh.ru/knowledge-base/article/1290) в них не будут поддерживаться.
  В связи с этим переписка может некорректно отображаться


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nid Идентификатор отклика/приглашения
 @return ApiSendNegotiationMessage_0Request
*/
func (a *DefaultApiService) SendNegotiationMessage_30(ctx context.Context, nid string) ApiSendNegotiationMessage_0Request {
	return ApiSendNegotiationMessage_0Request{
		ApiService: a,
		ctx: ctx,
		nid: nid,
	}
}

// Execute executes the request
//  @return NegotiationsMessageSent
func (a *DefaultApiService) SendNegotiationMessage_30Execute(r ApiSendNegotiationMessage_0Request) (*NegotiationsMessageSent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NegotiationsMessageSent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendNegotiationMessage_30")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/negotiations/{nid}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"nid"+"}", url.PathEscape(parameterValueToString(r.nid, "nid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return localVarReturnValue, nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v SendNegotiationMessage403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v SendNegotiationMessage404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApplicantCommentRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	applicantId string
	commentId string
	hHUserAgent *string
	locale *string
	host *string
	text *string
	accessType *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiUpdateApplicantCommentRequest) HHUserAgent(hHUserAgent string) ApiUpdateApplicantCommentRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiUpdateApplicantCommentRequest) Locale(locale string) ApiUpdateApplicantCommentRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiUpdateApplicantCommentRequest) Host(host string) ApiUpdateApplicantCommentRequest {
	r.host = &host
	return r
}

// Текст комментария
func (r ApiUpdateApplicantCommentRequest) Text(text string) ApiUpdateApplicantCommentRequest {
	r.text = &text
	return r
}

// Тип доступа. Доступные значения перечислены [в справочнике](#tag/Obshie-spravochniki/operation/get-dictionaries) в поле &#x60;applicant_comment_access_type&#x60;
func (r ApiUpdateApplicantCommentRequest) AccessType(accessType string) ApiUpdateApplicantCommentRequest {
	r.accessType = &accessType
	return r
}

func (r ApiUpdateApplicantCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateApplicantCommentExecute(r)
}

/*
UpdateApplicantComment Обновление комментария

Метод требует наличия [платного доступа для работодателя](#tag/Uslugi-rabotodatelya/operation/get-payable-api-method-access).

Автор комментария может изменить его текст и тип доступа. Если параметр не передан, то его значение останется прежним


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicantId Идентификатор соискателя, который можно узнать из поля `owner` [в резюме](https://github.com/hhru/api/blob/master/docs/employer_resumes.md#owner-field)
 @param commentId Идентификатор комментария, который можно узнать в [списке комментариев](#tag/Kommentarii-k-soiskatelyu/operation/get-applicant-comments-list)
 @return ApiUpdateApplicantCommentRequest
*/
func (a *DefaultApiService) UpdateApplicantComment(ctx context.Context, applicantId string, commentId string) ApiUpdateApplicantCommentRequest {
	return ApiUpdateApplicantCommentRequest{
		ApiService: a,
		ctx: ctx,
		applicantId: applicantId,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateApplicantCommentExecute(r ApiUpdateApplicantCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateApplicantComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/applicant_comments/{applicant_id}/{comment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicant_id"+"}", url.PathEscape(parameterValueToString(r.applicantId, "applicantId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"comment_id"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "")
	}
	if r.accessType != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "access_type", r.accessType, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSavedResumeSearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	name *string
	subscription *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiUpdateSavedResumeSearchRequest) HHUserAgent(hHUserAgent string) ApiUpdateSavedResumeSearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Новое имя сохраненного поиска
func (r ApiUpdateSavedResumeSearchRequest) Name(name string) ApiUpdateSavedResumeSearchRequest {
	r.name = &name
	return r
}

// Статус подписки
func (r ApiUpdateSavedResumeSearchRequest) Subscription(subscription bool) ApiUpdateSavedResumeSearchRequest {
	r.subscription = &subscription
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiUpdateSavedResumeSearchRequest) Locale(locale string) ApiUpdateSavedResumeSearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiUpdateSavedResumeSearchRequest) Host(host string) ApiUpdateSavedResumeSearchRequest {
	r.host = &host
	return r
}

func (r ApiUpdateSavedResumeSearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSavedResumeSearchExecute(r)
}

/*
UpdateSavedResumeSearch Обновление сохраненного поиска резюме

У сохраненного поиска можно изменить имя (`name`) и статус подписки (`subscription`). В одном запросе можно передать только один из параметров

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска
 @return ApiUpdateSavedResumeSearchRequest
*/
func (a *DefaultApiService) UpdateSavedResumeSearch(ctx context.Context, id string) ApiUpdateSavedResumeSearchRequest {
	return ApiUpdateSavedResumeSearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateSavedResumeSearchExecute(r ApiUpdateSavedResumeSearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSavedResumeSearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/resumes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.subscription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subscription", r.subscription, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorsCommonConflictBothChangedErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSavedVacancySearchRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	id string
	hHUserAgent *string
	name *string
	subscription *bool
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiUpdateSavedVacancySearchRequest) HHUserAgent(hHUserAgent string) ApiUpdateSavedVacancySearchRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Новое имя сохраненного поиска
func (r ApiUpdateSavedVacancySearchRequest) Name(name string) ApiUpdateSavedVacancySearchRequest {
	r.name = &name
	return r
}

// Статус подписки
func (r ApiUpdateSavedVacancySearchRequest) Subscription(subscription bool) ApiUpdateSavedVacancySearchRequest {
	r.subscription = &subscription
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiUpdateSavedVacancySearchRequest) Locale(locale string) ApiUpdateSavedVacancySearchRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiUpdateSavedVacancySearchRequest) Host(host string) ApiUpdateSavedVacancySearchRequest {
	r.host = &host
	return r
}

func (r ApiUpdateSavedVacancySearchRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSavedVacancySearchExecute(r)
}

/*
UpdateSavedVacancySearch Обновление сохраненного поиска вакансий

У сохраненного поиска можно изменить имя (`name`) и статус подписки (`subscription`). В одном запросе можно передать только один из параметров

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Идентификатор сохраненного поиска
 @return ApiUpdateSavedVacancySearchRequest
*/
func (a *DefaultApiService) UpdateSavedVacancySearch(ctx context.Context, id string) ApiUpdateSavedVacancySearchRequest {
	return ApiUpdateSavedVacancySearchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateSavedVacancySearchExecute(r ApiUpdateSavedVacancySearchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSavedVacancySearch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/saved_searches/vacancies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.subscription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subscription", r.subscription, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorsCommonBadArgumentErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsCommonBadAuthorizationErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorsCommonConflictBothChangedErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVacancyProlongationRequest struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiVacancyProlongationRequest) HHUserAgent(hHUserAgent string) ApiVacancyProlongationRequest {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiVacancyProlongationRequest) Locale(locale string) ApiVacancyProlongationRequest {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiVacancyProlongationRequest) Host(host string) ApiVacancyProlongationRequest {
	r.host = &host
	return r
}

func (r ApiVacancyProlongationRequest) Execute() (*http.Response, error) {
	return r.ApiService.VacancyProlongationExecute(r)
}

/*
VacancyProlongation Продление вакансии

Продлевает срок размещения указанной вакансии.

Условия продления:

* Стоимость продления вакансии равна стоимости новой публикации.
* Стандартные вакансии можно продлевать, если с момента предыдущего продления прошло не менее 1 минуты.
* Вакансии "стандарт-плюс" можно продлевать не ранее, чем за 7 дней до окончания срока публикации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiVacancyProlongationRequest
*/
func (a *DefaultApiService) VacancyProlongation(ctx context.Context, vacancyId string) ApiVacancyProlongationRequest {
	return ApiVacancyProlongationRequest{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) VacancyProlongationExecute(r ApiVacancyProlongationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VacancyProlongation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/prolongate"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyProlongateForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVacancyProlongation_0Request struct {
	ctx context.Context
	ApiService *DefaultApiService
	vacancyId string
	hHUserAgent *string
	locale *string
	host *string
}

// Название приложения и контактная почта разработчика (см. [Информация о клиенте](#section/Obshaya-informaciya/Trebovaniya-k-zaprosam)) 
func (r ApiVacancyProlongation_0Request) HHUserAgent(hHUserAgent string) ApiVacancyProlongation_0Request {
	r.hHUserAgent = &hHUserAgent
	return r
}

// Идентификатор локали (см. [Локализация](#tag/Obshie-spravochniki/operation/get-locales)) 
func (r ApiVacancyProlongation_0Request) Locale(locale string) ApiVacancyProlongation_0Request {
	r.locale = &locale
	return r
}

// Доменное имя сайта (см. [Выбор сайта](#section/Obshaya-informaciya/Vybor-sajta)) 
func (r ApiVacancyProlongation_0Request) Host(host string) ApiVacancyProlongation_0Request {
	r.host = &host
	return r
}

func (r ApiVacancyProlongation_0Request) Execute() (*http.Response, error) {
	return r.ApiService.VacancyProlongation_31Execute(r)
}

/*
VacancyProlongation_0 Продление вакансии

Продлевает срок размещения указанной вакансии.

Условия продления:

* Стоимость продления вакансии равна стоимости новой публикации.
* Стандартные вакансии можно продлевать, если с момента предыдущего продления прошло не менее 1 минуты.
* Вакансии "стандарт-плюс" можно продлевать не ранее, чем за 7 дней до окончания срока публикации


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vacancyId Идентификатор вакансии
 @return ApiVacancyProlongation_0Request
*/
func (a *DefaultApiService) VacancyProlongation_31(ctx context.Context, vacancyId string) ApiVacancyProlongation_0Request {
	return ApiVacancyProlongation_0Request{
		ApiService: a,
		ctx: ctx,
		vacancyId: vacancyId,
	}
}

// Execute executes the request
func (a *DefaultApiService) VacancyProlongation_31Execute(r ApiVacancyProlongation_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VacancyProlongation_31")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vacancies/{vacancy_id}/prolongate"
	localVarPath = strings.Replace(localVarPath, "{"+"vacancy_id"+"}", url.PathEscape(parameterValueToString(r.vacancyId, "vacancyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hHUserAgent == nil {
		return nil, reportError("hHUserAgent is required and must be specified")
	}

	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	} else {
		var defaultValue string = "RU"
		r.locale = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "")
	} else {
		var defaultValue string = "hh.ru"
		r.host = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "HH-User-Agent", r.hHUserAgent, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorsVacancyProlongateForbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorsCommonNotFoundErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
